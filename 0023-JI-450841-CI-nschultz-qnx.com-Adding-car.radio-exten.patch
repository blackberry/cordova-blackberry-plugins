From 640e74f892dd6d2c679b1e6c4b7aac187023014d Mon Sep 17 00:00:00 2001
From: Marc Lapierre <marc@eternallabs.com>
Date: Tue, 20 Aug 2013 15:28:06 -0400
Subject: [PATCH 23/61] JI:450841 CI:nschultz@qnx.com Adding car.radio
 extension

---
 plugin/com.qnx.radio/plugin.xml                  |   34 ++
 plugin/com.qnx.radio/src/blackberry10/context.js |   64 +++
 plugin/com.qnx.radio/src/blackberry10/index.js   |  264 +++++++++
 plugin/com.qnx.radio/src/blackberry10/radio.js   |  322 +++++++++++
 plugin/com.qnx.radio/www/client.js               |  637 ++++++++++++++++++++++
 5 files changed, 1321 insertions(+)
 create mode 100644 plugin/com.qnx.radio/plugin.xml
 create mode 100644 plugin/com.qnx.radio/src/blackberry10/context.js
 create mode 100644 plugin/com.qnx.radio/src/blackberry10/index.js
 create mode 100644 plugin/com.qnx.radio/src/blackberry10/radio.js
 create mode 100644 plugin/com.qnx.radio/www/client.js

diff --git a/plugin/com.qnx.radio/plugin.xml b/plugin/com.qnx.radio/plugin.xml
new file mode 100644
index 0000000..c112ee8
--- /dev/null
+++ b/plugin/com.qnx.radio/plugin.xml
@@ -0,0 +1,34 @@
+<!--
+Copyright 2013  QNX Software Systems Limited
+
+Licensed under the Apache License, Version 2.0 (the "License"). You
+may not reproduce, modify or distribute this software except in
+compliance with the License. You may obtain a copy of the License
+at: http://www.apache.org/licenses/LICENSE-2.0.
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" basis,
+WITHOUT WARRANTIES OF ANY KIND, either express or implied.
+This file may contain contributions from others, either as
+contributors under the License or as licensors under other terms.
+Please review this entire file for other proprietary rights or license
+notices, as well as the applicable QNX License Guide at
+http://www.qnx.com/legal/licensing/document_archive/current_matrix.pdf
+for other information.
+-->
+<plugin xmlns="http://www.phonegap.com/ns/plugins/1.0"
+	id="com.qnx.radio"
+	version="1.0.0">
+	<js-module src="www/client.js">
+		<clobbers target="qnx.radio" />
+	</js-module>
+
+	<platform name="blackberry10">
+		<source-file src="src/blackberry10/index.js" />
+		<source-file src="src/blackberry10/context.js" />
+		<source-file src="src/blackberry10/radio.js" />
+		<config-file target="www/config.xml" parent="/widget">
+			<feature name="com.qnx.radio" value="com.qnx.radio" />
+		</config-file>
+	</platform>
+</plugin>
diff --git a/plugin/com.qnx.radio/src/blackberry10/context.js b/plugin/com.qnx.radio/src/blackberry10/context.js
new file mode 100644
index 0000000..cbd5b7c
--- /dev/null
+++ b/plugin/com.qnx.radio/src/blackberry10/context.js
@@ -0,0 +1,64 @@
+/*
+ * Copyright 2013  QNX Software Systems Limited
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"). You
+ * may not reproduce, modify or distribute this software except in
+ * compliance with the License. You may obtain a copy of the License
+ * at: http://www.apache.org/licenses/LICENSE-2.0.
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTIES OF ANY KIND, either express or implied.
+ * This file may contain contributions from others, either as
+ * contributors under the License or as licensors under other terms.
+ * Please review this entire file for other proprietary rights or license
+ * notices, as well as the applicable QNX License Guide at
+ * http://www.qnx.com/legal/licensing/document_archive/current_matrix.pdf
+ * for other information.
+ */
+
+/**
+ * The event context for application events
+ */
+
+var _radio = require("./radio");
+
+/**
+ * Exports are the publicly accessible functions
+ */
+module.exports = {
+	/**
+	 * Method called when the first listener is added for an event
+	 * @param event {String} The event name
+	 * @param trigger {Function} The trigger function to call when the event is fired
+	 */
+	addEventListener: function (event, trigger) {
+		if (event && trigger) {
+			switch (event) {
+				case "radioUpdate":
+					_radio.setTriggerUpdate(trigger);
+					break;
+				case "presetUpdate":
+					_radio.setTriggerPresets(trigger);
+					break;
+			}
+		}
+	},
+
+	/**
+	 * Method called when the last listener is removed for an event
+	 * @param event {String} The event name
+	 */
+	removeEventListener: function (event) {
+		if (event) {
+			switch (event) {
+				case "radioUpdate":
+					_radio.setTriggerUpdate(null);
+					break;
+				case "presetUpdate":
+					_radio.setTriggerPresets(null);
+					break;
+			}
+		}
+	}
+};
diff --git a/plugin/com.qnx.radio/src/blackberry10/index.js b/plugin/com.qnx.radio/src/blackberry10/index.js
new file mode 100644
index 0000000..41c1f28
--- /dev/null
+++ b/plugin/com.qnx.radio/src/blackberry10/index.js
@@ -0,0 +1,264 @@
+/*
+ * Copyright 2013  QNX Software Systems Limited
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"). You
+ * may not reproduce, modify or distribute this software except in
+ * compliance with the License. You may obtain a copy of the License
+ * at: http://www.apache.org/licenses/LICENSE-2.0.
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTIES OF ANY KIND, either express or implied.
+ * This file may contain contributions from others, either as
+ * contributors under the License or as licensors under other terms.
+ * Please review this entire file for other proprietary rights or license
+ * notices, as well as the applicable QNX License Guide at
+ * http://www.qnx.com/legal/licensing/document_archive/current_matrix.pdf
+ * for other information.
+ */
+
+/**
+ * Allows control of radio tuners, presets, and stations.
+ */
+
+var _wwfix = require("../../lib/wwfix"),
+	_radio = require("./radio"),
+	_context = require("./context"),
+	_eventResults = {};
+
+/**
+ * Initializes the extension 
+ */
+function init() {
+	try {
+		_radio.init();
+	} catch (ex) {
+		console.error('Error in webworks ext: radio/index.js:init():', ex);
+	}
+}
+init();
+
+/**
+ * Exports are the publicly accessible functions
+ */
+module.exports = {
+
+	/**
+	 * Turn on event dispatching for a specific event name
+	 * @param {Function} success Function to call if the operation is a success
+	 * @param {Function} fail Function to call if the operation fails
+	 * @param {Object} args The arguments supplied
+	 * @param {Object} env Environment variables
+	 */
+	startEvent: function (success, fail, args, env) {
+		var result = new PluginResult(args, env)
+		var fixedArgs = _wwfix.parseArgs(args);
+		try {
+			if (fixedArgs && fixedArgs.eventName) {
+				_eventResults[fixedArgs.eventName] = result;
+				_context.addEventListener(fixedArgs.eventName, function (data) {
+					result.callbackOk(data, true);
+				});
+				result.noResult(true);
+			} else {
+				throw "Invalid eventName";
+			}
+		} catch (e) {
+			result.error("error in startEvent: " + JSON.stringify(e), false);
+		}
+   },
+
+	/**
+	 * Turn off event dispatching for a specific event name
+	 * @param {Function} success Function to call if the operation is a success
+	 * @param {Function} fail Function to call if the operation fails
+	 * @param {Object} args The arguments supplied
+	 * @param {Object} env Environment variables
+	 */
+	stopEvent: function (success, fail, args, env) {
+		var result = new PluginResult(args, env);
+		var fixedArgs = _wwfix.parseArgs(args);
+		try {
+			if (fixedArgs && fixedArgs.eventName) {
+				//disable the event trigger
+				_context.removeEventListener(fixedArgs.eventName);
+				result.ok(undefined, false);
+
+				//cleanup
+				_eventResults[fixedArgs.eventName].noResult(false);
+				delete _eventResults[fixedArgs.eventName];
+			} else {
+				throw "Invalid eventName";
+			}
+		} catch (e) {
+			result.error("error in stopEvent: " + JSON.stringify(e), false);
+		}
+	},
+
+	/**
+	 * Returns the list of available tuners.
+	 * @param success {Function} Function to call if the operation is a success
+	 * @param fail {Function} Function to call if the operation fails
+	 * @param args {Object} The arguments supplied. Available arguments for this call are: N/A
+	 * @param env {Object} Environment variables
+	 */
+	getTuners: function(success, fail, args, env) {
+		var result = new PluginResult(args, env)
+		try {
+			var data = _radio.getTuners();
+			result.ok(data, false);
+		} catch (e) {
+			result.error(JSON.stringify(e), false);
+		}
+	},
+			
+	/**
+	 * Sets the active tuner by name.
+	 * @param success {Function} Function to call if the operation is a success
+	 * @param fail {Function} Function to call if the operation fails
+	 * @param args {Object} The arguments supplied
+	 * @param env {Object} Environment variables
+	 */
+	setTuner: function(success, fail, args, env) {
+		var result = new PluginResult(args, env)
+		var fixedArgs = _wwfix.parseArgs(args);
+		try {
+			_radio.setTuner(fixedArgs.tuner);
+			result.ok(undefined, false);
+		} catch (e) {
+			result.error(JSON.stringify(e), false);
+		}
+	},
+	
+	/**
+	 * Tune to a specific station, optionally targeting a specific tuner. If the specified
+	 * tuner is not the active tuner, then the station will be automatically selected the next
+	 * time that tuner is set as active.
+	 * @param success {Function} Function to call if the operation is a success
+	 * @param fail {Function} Function to call if the operation fails
+	 * @param args {Object} The arguments supplied
+	 * @param env {Object} Environment variables
+	 */
+	setStation: function(success, fail, args, env) {
+		var result = new PluginResult(args, env)
+		var fixedArgs = _wwfix.parseArgs(args);
+		try {
+			var tuner = (typeof fixedArgs.tuner !== 'undefined') ? fixedArgs.tuner : _radio.getStatus().tuner;
+			_radio.setStation(fixedArgs.station, tuner);
+			result.ok(undefined, false);
+		} catch (e) {
+			result.error(JSON.stringify(e), false);
+		}
+	},
+	
+	/**
+	 * Get the presets for the current tuner. Optionally, a tuner name can be specified, returning
+	 * presets for the specified tuner.
+	 * @param success {Function} Function to call if the operation is a success
+	 * @param fail {Function} Function to call if the operation fails
+	 * @param args {Object} The arguments supplied
+	 * @param env {Object} Environment variables
+	 */
+	getPresets: function(success, fail, args, env) {
+		var result = new PluginResult(args, env)
+		var fixedArgs = _wwfix.parseArgs(args);
+		try {
+			var tuner = (typeof fixedArgs.tuner !== 'undefined') ? fixedArgs.tuner : _radio.getStatus().tuner;
+			var data = _radio.getPresets(tuner);
+			result.ok(data, false);
+		} catch (e) {
+			result.error(JSON.stringify(e), false);
+		}
+	},
+	
+	/**
+	 * Sets the entire list of presets for the specified tuner(s).
+	 * @param success {Function} Function to call if the operation is a success
+	 * @param fail {Function} Function to call if the operation fails
+	 * @param args {Object} The arguments supplied
+	 * @param env {Object} Environment variables
+	 */
+	setPreset: function(success, fail, args, env) {
+		var result = new PluginResult(args, env)
+		var fixedArgs = _wwfix.parseArgs(args);
+		try {
+			var tuner = (typeof fixedArgs.tuner !== 'undefined') ? fixedArgs.tuner : _radio.getStatus().tuner
+			var station = (typeof fixedArgs.station !== 'undefined') ? fixedArgs.station : _radio.getStatus().station
+			_radio.setPreset(fixedArgs.index, fixedArgs.group, station, tuner);
+			result.ok(undefined, false);
+		} catch (e) {
+			result.error(JSON.stringify(e), false);
+		}
+	},
+	
+	/**
+	 * Seek for the next radio station in the given direction
+	 * @param success {Function} Function to call if the operation is a success
+	 * @param fail {Function} Function to call if the operation fails
+	 * @param args {Object} The arguments supplied
+	 * @param env {Object} Environment variables
+	 */
+	seek: function(success, fail, args, env) {
+		var result = new PluginResult(args, env)
+		var fixedArgs = _wwfix.parseArgs(args);
+		try {
+			_radio.seek(fixedArgs.direction);
+			result.ok(undefined, false);
+		} catch (e) {
+			result.error(JSON.stringify(e), false);
+		}
+	},
+	
+	/**
+	 * Scan for available radio stations in the given direction
+	 * @param success {Function} Function to call if the operation is a success
+	 * @param fail {Function} Function to call if the operation fails
+	 * @param args {Object} The arguments supplied
+	 * @param env {Object} Environment variables
+	 */
+	scan: function(success, fail, args, env) {
+		var result = new PluginResult(args, env)
+		var fixedArgs = _wwfix.parseArgs(args);
+		try {
+			_radio.scan(fixedArgs.direction);
+			result.ok(undefined, false);
+		} catch (e) {
+			result.error(JSON.stringify(e), false);
+		}
+	},
+	
+	/**
+	 * Stop scanning
+	 * @param success {Function} Function to call if the operation is a success
+	 * @param fail {Function} Function to call if the operation fails
+	 * @param args {Object} The arguments supplied
+	 * @param env {Object} Environment variables
+	 */
+	scanStop: function(success, fail, args, env) {
+		var result = new PluginResult(args, env)
+		try {
+			_radio.scanStop();
+			result.ok(undefined, false);
+		} catch (e) {
+			result.error(JSON.stringify(e), false);
+		}
+	},
+	
+	/**
+	 * Get the current station metadata.
+	 * @param success {Function} Function to call if the operation is a success
+	 * @param fail {Function} Function to call if the operation fails
+	 * @param args {Object} The arguments supplied. Available arguments for this call are: N/A
+	 * @param env {Object} Environment variables
+	 */
+	getStatus: function(success, fail, args, env) {
+		var result = new PluginResult(args, env)
+		try {
+			var data = _radio.getStatus();
+			result.ok(data, false);
+		} catch (e) {
+			result.error(JSON.stringify(e), false);
+		}
+	},
+};
+
diff --git a/plugin/com.qnx.radio/src/blackberry10/radio.js b/plugin/com.qnx.radio/src/blackberry10/radio.js
new file mode 100644
index 0000000..2322a49
--- /dev/null
+++ b/plugin/com.qnx.radio/src/blackberry10/radio.js
@@ -0,0 +1,322 @@
+/*
+ * Copyright 2013  QNX Software Systems Limited
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"). You
+ * may not reproduce, modify or distribute this software except in
+ * compliance with the License. You may obtain a copy of the License
+ * at: http://www.apache.org/licenses/LICENSE-2.0.
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTIES OF ANY KIND, either express or implied.
+ * This file may contain contributions from others, either as
+ * contributors under the License or as licensors under other terms.
+ * Please review this entire file for other proprietary rights or license
+ * notices, as well as the applicable QNX License Guide at
+ * http://www.qnx.com/legal/licensing/document_archive/current_matrix.pdf
+ * for other information.
+ */
+
+/**
+ * The abstraction layer for radio functionality.
+ */
+
+var	_pps = qnx.webplatform.pps,
+	_tunersPPS,
+	_statusPPS,
+	_statusWriterPPS,
+	_commandPPS,
+	_triggerUpdate,
+	_triggerPresets,
+	_scanTimer,
+	SIMULATION_MODE = true;
+
+/**
+ * Get the current status.
+ * @return {Object} A radio status object.
+ * Ex:
+ * 
+ * {
+ * 	tuner: 'fm',
+ * 	station: 91.5,
+ * 	artist: 'Bjork',
+ * 	genre: 'News & Entertainment',
+ * 	song: 'All is Full of Love',
+ * 	stationName: 'CBC Radio 1',
+ * 	hd: false
+ * }
+ */
+function getStatus() {
+	var status = _statusPPS.data.status;
+	
+	return {
+		tuner		: status.tuner,
+		station 	: status[status.tuner].station,
+		artist		: status.artist,
+		genre		: status.genre,
+		song		: status.song,
+		stationName	: status.station,
+		hd			: status.hd
+	};
+}
+
+/**
+ * Returns the list of available tuners.
+ * @return {Object} An object containing attributes corresponding to each tuner object. The attribute name
+ * is the name of the tuner.
+ */
+function getTuners() {
+	var tuners = [];
+	var keys = Object.keys(_tunersPPS.data.tuners);
+	for (var i=0; i<keys.length; i++) {
+		var tuner = {
+			tuner: keys[i],
+			type: _tunersPPS.data.tuners[keys[i]].type
+		}
+		switch (tuner.type) {
+			case 'analog': 
+				tuner.settings = {
+					rangeMin: _tunersPPS.data.tuners[keys[i]].rangeMin,
+					rangeMax: _tunersPPS.data.tuners[keys[i]].rangeMax,
+					rangeStep: _tunersPPS.data.tuners[keys[i]].rangeStep,
+				};
+				break;
+
+			default:
+				console.error('car.radio::getTuners: Unknown tuner type: ' + tuner.type);
+				continue;
+		}
+		tuners.push(tuner);
+	}
+	return tuners;
+};
+
+/**
+ * Get the presets for the current tuner. Optionally, a tuner name can be specified, returning
+ * presets for the specified tuner.
+ * @param {String} tuner The tuner for the presets 
+ * @return {Array} An array of presets.
+ */
+function getPresets(tuner) {
+		var presets = [];
+
+		var ppsPresets = _statusPPS.data.status[tuner].presets;
+		for (var i=0; i<ppsPresets.length; i++) {
+			presets.push({
+				tuner: tuner,
+				group: tuner + '1',
+				index: i,
+				station: ppsPresets[i]
+			});
+		}
+		return presets;
+};
+
+/**
+ * Exports are the publicly accessible functions
+ */
+module.exports = {
+	/**
+	 * Initializes the extension 
+	 */
+	init: function() {
+		//_tunersPPS
+		_tunersPPS = _pps.createObject("/pps/radio/tuners", _pps.PPSMode.DELTA);
+		_tunersPPS.open(_pps.FileMode.RDONLY);
+		
+		//_statusPPS
+		_statusPPS = _pps.createObject("/pps/radio/status", _pps.PPSMode.DELTA);
+		_statusPPS.onNewData = function(data) {
+			//status updates
+			if (_triggerUpdate) {
+				_triggerUpdate(getStatus());
+			}
+			//preset updates
+			if (_triggerPresets && data && data.changed) {
+				var tuners = getTuners();
+				for (var i=0; i<tuners.length; i++) {
+					if (typeof data.changed[tuners[i].tuner] !== 'undefined') {
+						_triggerPresets(getPresets(tuners[i].tuner));
+					}
+				}
+			}
+		};
+		_statusPPS.open(_pps.FileMode.RDONLY);
+		
+		//writing pps commands
+		_commandPPS = _pps.createObject("/pps/radio/status", _pps.PPSMode.DELTA);
+		if (SIMULATION_MODE) {
+			_commandPPS.open(_pps.FileMode.WRONLY);
+		} else {
+			_commandPPS.open(_pps.FileMode.WRONLY);
+		}
+
+		//status writer, used to save presets
+		_statusWriterPPS = _pps.createObject();
+		_statusWriterPPS.open("/pps/radio/status", JNEXT.PPS_WRONLY);
+	},
+		
+	/**
+	 * Sets the trigger function to call when a status event is fired
+	 * @param trigger {Function} The trigger function to call when the event is fired
+	 */
+	setTriggerUpdate: function(trigger) {
+		_triggerUpdate = trigger;
+	},
+	
+
+	/**
+	 * Sets the trigger function to call when a preset event is fired
+	 * @param trigger {Function} The trigger function to call when the event is fired
+	 */
+	setTriggerPresets: function(trigger) {
+		_triggerPresets = trigger;
+	},
+	
+	/**
+	 * Returns the list of available tuners.
+	 * @return {Object} An object containing attributes corresponding to each tuner object. The attribute name
+	 * is the name of the tuner.
+	 */
+	getTuners: function() {
+		return getTuners();
+	},
+
+	/**
+	 * Sets the active tuner by name.
+	 * @param tuner {String} The name of tuner to set as active
+	 */
+	setTuner: function(tuner) {
+		_commandPPS.write({tuner: tuner});
+	},	
+	
+	/**
+	 * Tune to a specific station, optionally targeting a specific tuner. If the specified
+	 * tuner is not the active tuner, then the station will be automatically selected the next
+	 * time that tuner is set as active.
+	 * @param station {Number} The target station
+	 * @param tuner {String} (optional) The target tuner name
+	 */
+	setStation: function(station, tuner) {
+		if (SIMULATION_MODE) {
+			var obj = {};
+			obj[tuner] = _statusPPS.data.status[tuner];
+			obj[tuner].station = station;
+			
+			_commandPPS.write(obj);
+		} else {
+			// If the station is not for the active tuner, then write the selected station
+			// directly to the status PPS object since nothing needs to happen at the radio
+			// service level.
+			if(tuner != _statusPPS.data.status.tuner) {
+				var obj = {};
+				obj[tuner] = _statusPPS.data.status[tuner];
+				obj[tuner].station = station;
+
+				_statusWriterPPS.write(obj);
+			}
+			
+			// If the station is for the current tuner, then send the tune command to the command PPS
+			_commandPPS.write({ tune: station });
+		}
+	},
+	
+	/**
+	 * Get the presets for the current tuner. Optionally, a tuner name can be specified, returning
+	 * presets for the specified tuner.
+	 * @param {String} tuner The tuner for the presets 
+	 * @return {Array} An array of presets.
+	 */
+	getPresets: function(tuner) {
+		return getPresets(tuner);
+	},
+	
+	/**
+	 * Sets the current station as a preset at the specified index. A station and tuner can optionally
+	 * be specified to set the non-current station as a preset, and/or for the non-active tuner. 
+	 * @param index {Number} The preset index
+	 * @param group {Number} The preset group
+	 * @param station {Number} (optional) The station to set as the preset. If not specified, the current station will be used.
+	 * @param tuner {String} (optional) The station's tuner. If not specified, the active tuner will be used.
+	 */
+	setPreset: function(index, group, station, tuner) {
+		var obj = {};
+		obj[tuner] = _statusPPS.data.status[tuner];
+		obj[tuner].presets[index] = station;
+		
+		// TODO: Ensure station preset is within the range of the specified tuner
+		// TODO: Handle group
+		_statusWriterPPS.write(obj);
+	},
+	
+	/**
+	 * Seek for the next radio station in the given direction
+	 * @param direction {String} The direction to seek ('up' or 'down')
+	 */
+	seek: function(direction) {
+		if (SIMULATION_MODE) {
+			var tuner = _tunersPPS.data.tuners[_statusPPS.data.status.tuner];
+			
+			var numSteps = (tuner.rangeMax - tuner.rangeMin) / tuner.rangeStep;
+			var rand = Math.ceil(Math.random() / 5 * numSteps);
+			if (direction == 'down') {
+				rand = -rand;
+			}
+			
+			var currStation = parseFloat(_statusPPS.data.status[_statusPPS.data.status.tuner].station);
+			var targetStation = currStation + (rand  * tuner.rangeStep);
+			if (targetStation < tuner.rangeMin) {
+				targetStation = tuner.rangeMax - (tuner.rangeMin - targetStation);
+			} else if (targetStation > tuner.rangeMax) {
+				targetStation = tuner.rangeMin + (targetStation - tuner.rangeMax);
+			}
+			
+			//ensure proper number of decimals
+			var strStation = new String(currStation)
+			var decpos = strStation.indexOf('.');
+			if (decpos > -1) {
+				targetStation = new Number(targetStation + '').toFixed(strStation.length - decpos - 1);
+			}
+			
+			this.setStation(targetStation, _statusPPS.data.status.tuner);
+		} else {
+			_commandPPS.write({ seek: direction });
+		}
+	},
+	
+	/**
+	 * Scan for available radio stations in the given direction.
+	 * @param direction {String} The direction to scan ('up' or 'down')
+	 */
+	scan: function(direction) {
+		if (_scanTimer !== undefined) {
+			clearInterval(_scanTimer);
+		}
+
+		var self = this;
+			_scanTimer = setInterval(function() { self.seek(direction) }, 3000);
+			this.seek(direction);
+	},
+	
+	/**
+	 * Stop station scanning if in progress.
+	 */
+	scanStop: function() {
+		if(_scanTimer !== undefined) {
+			clearInterval(_scanTimer);
+		}
+		
+		//get the server side to stop seeking in the middle of a seek.
+		if (!SIMULATION_MODE) {
+			_commandPPS.write({ seek: "stop" });
+		}
+	},
+	
+	/**
+	 * Get the current status.
+	 * @return {Object} A radio status object.
+	 */
+	getStatus: function() {
+		return getStatus();
+	},
+};
diff --git a/plugin/com.qnx.radio/www/client.js b/plugin/com.qnx.radio/www/client.js
new file mode 100644
index 0000000..1311058
--- /dev/null
+++ b/plugin/com.qnx.radio/www/client.js
@@ -0,0 +1,637 @@
+/*
+ * Copyright 2013  QNX Software Systems Limited
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"). You
+ * may not reproduce, modify or distribute this software except in
+ * compliance with the License. You may obtain a copy of the License
+ * at: http://www.apache.org/licenses/LICENSE-2.0.
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTIES OF ANY KIND, either express or implied.
+ * This file may contain contributions from others, either as
+ * contributors under the License or as licensors under other terms.
+ * Please review this entire file for other proprietary rights or license
+ * notices, as well as the applicable QNX License Guide at
+ * http://www.qnx.com/legal/licensing/document_archive/current_matrix.pdf
+ * for other information.
+ */
+
+/**
+ * @module car.radio
+ * @static
+ *
+ * @description Manages the radio interface
+ */
+
+var _ID = "com.qnx.radio",
+	_self = {},
+	_utils = cordova.require('cordova/utils'),
+	_watchesRadio = {};
+	_watchesPresets = {};
+
+/**
+ * Handles radio update events
+ * @param data {Array} The updated data provided by the event 
+ * @private
+ */
+function onUpdateRadio(data) {
+	var keys = Object.keys(_watchesRadio);
+	for (var i=0; i<keys.length; i++) {
+		setTimeout(_watchesRadio[keys[i]](data), 0);
+	}
+}
+
+/**
+ * Handles preset update events 
+ * @param data {Array} The updated data provided by the event 
+ * @private
+ */
+function onUpdatePresets(data) {
+	var keys = Object.keys(_watchesPresets);
+	for (var i=0; i<keys.length; i++) {
+		setTimeout(_watchesPresets[keys[i]](data), 0);
+	}
+}
+
+/**
+ * Watch for metadata updates
+ * @param {Function} callback The function to call when a change is detected.
+ * @return {Number} An ID for the added watch.
+ * @memberOf module:car.radio
+ * @method watchRadio 
+ * @example
+ * 
+ * //define a callback function
+ * function myCallback(metadata) {
+ *		console.log("tuner = " + data.tuner + "\n" +
+ *					"artist = " + data.artist + "\n" +
+ *					"genre = " + data.genre + "\n" +
+ *					"song = " + data.song + "\n" +
+ *					"station = " + data.station + "\n" +
+ *					"stationName = " + data.stationName + "\n" +
+ *					"hd = " + data.hd
+ *		);
+ * }
+ * 
+ * var watchId = car.radio.watchRadio(myCallback);
+ */
+_self.watchRadio = function (callback) {
+	var watchId = _utils.createUUID();
+	
+	_watchesRadio[watchId] = callback;
+	if (Object.keys(_watchesRadio).length === 1) {
+		window.cordova.exec(onUpdateRadio, null, _ID, 'startEvent', { eventName: 'radioupdate' }, false);
+	}
+
+	return watchId;
+};
+
+/**
+ * Watch for preset updates
+ * @param {Function} callback The function to call when a change is detected.
+ * @return {Number} An ID for the added watch.
+ * @memberOf module:car.radio
+ * @method watchPresets  
+ * @example
+ * 
+ * function myCallback(presets) {
+ *		//iterate through all the presets
+ *		for (var i=0; i&lt;presets.length; i++) {
+ *			console.log("preset tuner = " + presets[i].tuner + "\n" +
+ *						"preset station = " + presets[i].station + "\n" +
+ *						"preset index = " + presets[i].index + "\n" +
+ *						"preset group = " + presets[i].group
+ *			);
+ *		}
+ * }
+ * 
+ * var watchId = car.radio.watchPresets(myCallback);
+ */
+_self.watchPresets = function (callback) {
+	var watchId = _utils.createUUID();
+	
+	_watchesPresets[watchId] = callback;
+	if (Object.keys(_watchesPresets).length === 1) {
+		window.cordova.exec(onUpdatePresets, null, _ID, 'startEvent', { eventName: 'presetUpdate' }, false);
+	}
+
+	return watchId;
+};
+
+/**
+ * Stop watching for metadata updates
+ * @param {Number} watchId The watch ID as returned by <i>car.radio.watchRadio()</i> or <i>car.radio.watchPresets()</i>.
+ * @memberOf module:car.radio
+ * @method cancelWatch   
+ * @example
+ * 
+ * car.radio.cancelWatch(watchId);
+ */
+_self.cancelWatch = function (watchId) {
+	//is this a radio events watch?
+	if (_watchesRadio[watchId]) {
+		delete _watchesRadio[watchId];
+		if (Object.keys(_watchesRadio).length === 0) {
+			window.cordova.exec(null, null, _ID, 'stopEvent', { eventName: 'radioUpdate' }, false);
+		}
+	} else if (_watchesPresets[watchId]) {
+		delete _watchesPresets[watchId];
+		if (Object.keys(_watchesPresets).length === 0) {
+			window.cordova.exec(null, null, _ID, 'stopEvent', { eventName: 'presetUpdate' }, false);
+		}
+	}
+};
+
+/**
+ * Return the list of available tuners
+ * @param {Function} successCallback The function to call on success.
+ * @param {Function} [errorCallback] The function to call if there is an error.
+ * @memberOf module:car.radio
+ * @method getTuners  
+ * @example 
+ *
+ * //define your callback function(s)
+ * function successCallback(tuners) {
+ *		//iterate through all the tuners
+ *		for (var i=0; i&lt;tuners.length; i++) {
+ *			console.log("tuner name = " + tuners[i].tuner + "\n" +
+ *						"tuner type = " + tuners[i].type + "\n" +
+ *						"tuner range min = " + tuners[i].settings.rangeMin + "\n" +
+ *						"tuner range max = " + tuners[i].settings.rangeMax + "\n" +
+ *						"tuner range step = " + tuners[i].settings.rangeStep
+ *			);
+ *		}
+ * }
+ *
+ * function errorCallback(error) {
+ *		console.log(error.code, error.msg);
+ * }
+ *
+ * //call the method
+ * car.radio.getTuners(successCallback, errorCallback);
+ *
+ *
+ *
+ * @example REST
+ *
+ * Request:
+ * http://&lt;car-ip&gt;/car/radio/getTuners
+ *
+ * Success Response:
+ * {
+ *		code: 1,
+ *		data: [ 
+ * 			{ 
+ *				tuner: 'am', 
+ *				type: 'analog', 
+ *				settings: {
+ *					rangeMin: 880,
+ *					rangeMax: 1600,
+ *					rangeStep: 10
+ *				}
+ *			}, { 
+ *				tuner: 'fm', 
+ *				type: 'analog', 
+ *				settings: {
+ *					rangeMin: 88.9,
+ *					rangeMax: 107.1,
+ *					rangeStep: 0.2
+ *				}
+ *			}
+ *		]
+ * }
+ *
+ * Error Response:
+ * {
+ *		code: -1,
+ *		msg: "An error has occurred"
+ * }
+ */
+_self.getTuners = function(successCallback, errorCallback) {
+	window.cordova.exec(successCallback, errorCallback, _ID, 'getTuners', null, false);
+};
+		
+/**
+ * Set the active tuner by name
+ * @param {String} tuner The name of tuner to set as active.
+ * @param {Function} [successCallback] The function to call on success.
+ * @param {Function} [errorCallback] The function to call if there is an error.
+ * @memberOf module:car.radio
+ * @method setTuner
+ * @example 
+ *
+ * //define your callback function(s)
+ * function successCallback() {
+ *		console.log('tuner was successfully set');
+ * }
+ *
+ * function errorCallback(error) {
+ *		console.log(error.code, error.msg);
+ * }
+ *
+ * //call the method
+ * car.radio.setTuner('fm', successCallback, errorCallback);
+ *
+ *
+ *
+ * @example REST
+ *
+ * Request:
+ * http://&lt;car-ip&gt;/car/radio/setTuner?tuner=fm
+ *
+ * Success Response:
+ * {
+ *		code: 1,
+ * }
+ *
+ * Error Response:
+ * {
+ *		code: -1,
+ *		msg: "An error has occurred"
+ * }
+ */
+_self.setTuner = function(tuner, successCallback, errorCallback) {
+	var args = { 
+		tuner: tuner 
+	};
+	window.cordova.exec(successCallback, errorCallback, _ID, 'setTuner', args, false);
+};
+
+/**
+ * @description <p>Tune to a specific station, optionally targeting a specific tuner
+ * <p>If the specified tuner is not the active tuner, then the station will be 
+ * automatically selected the next time that tuner is set as active.
+ * @param {Number} station The target station.
+ * @param {Function} successCallback The function to call on success.
+ * @param {Function} [errorCallback] The function to call if there is an error.
+ * @param {String} [tuner] The tuner name. If not specified, the active tuner is used.
+ * @memberOf module:car.radio
+ * @method setStation
+ * @example 
+ *
+ * //define your callback function(s)
+ * function successCallback() {
+ *		console.log('station was successfully set');
+ * }
+ *
+ * function errorCallback(error) {
+ *		console.log(error.code, error.msg);
+ * }
+ *
+ * //call the method
+ * car.radio.setStation(88.5, successCallback, errorCallback);
+ *
+ *
+ *
+ * @example REST
+ *
+ * Request:
+ * http://&lt;car-ip&gt;/car/radio/setStation?station=88.5
+ *
+ * Success Response:
+ * {
+ *		code: 1,
+ * }
+ *
+ * Error Response:
+ * {
+ *		code: -1,
+ *		msg: "An error has occurred"
+ * }
+ */
+_self.setStation = function(station, successCallback, errorCallback, tuner) {
+	var args = { 
+		station: station 
+	};
+	if (tuner) {
+		args.tuner = tuner;
+	}
+	window.cordova.exec(successCallback, errorCallback, _ID, 'setStation', args, false);
+};
+
+/**
+ * @description <p>Get the presets for the current tuner
+ * <p>Optionally, a tuner name can be specified, returning
+ * presets for the specified tuner.
+ * @param {Function} successCallback The function to call on success.
+ * @param {Function} [errorCallback] The function to call if there is an error.
+ * @param {String} [tuner] The tuner of the presets. If not specified, the active tuner is used.
+ * @memberOf module:car.radio
+ * @method getPresets
+ * @example 
+ *
+ * //define your callback function(s)
+ * function successCallback(presets) {
+ *		//iterate through all the presets
+ *		for (var i=0; i&lt;presets.length; i++) {
+ *			console.log("preset tuner = " + presets[i].tuner + "\n" +
+ *						"preset station = " + presets[i].station + "\n" +
+ *						"preset index = " + presets[i].index + "\n" +
+ *						"preset group = " + presets[i].group
+ *			);
+ *		}
+ * }
+ *
+ * function errorCallback(error) {
+ *		console.log(error.code, error.msg);
+ * }
+ *
+ * //call the method
+ * car.radio.getPresets(successCallback, errorCallback);
+ *
+ *
+ *
+ * @example REST
+ *
+ * Request:
+ * http://&lt;car-ip&gt;/car/radio/getPresets
+ *
+ * Success Response:
+ * {
+ *		code: 1,
+ *		data: [ 
+ * 			{ 
+ *				tuner: 'am', 
+ *				station: '880', 
+ *				index: 0, 
+ *				group: 'am1', 
+ *			}, { 
+ *				tuner: 'am', 
+ *				station: '1010', 
+ *				index: 1, 
+ *				group: 'am1', 
+ *			},{
+ *				...	
+ *			}
+ *		]
+ * }
+ *
+ * Error Response:
+ * {
+ *		code: -1,
+ *		msg: "An error has occurred"
+ * }
+ */
+_self.getPresets = function(successCallback, errorCallback, tuner) {
+	var args = {};
+	if (tuner) {
+		args.tuner = tuner;
+	}
+    window.cordova.exec(successCallback, errorCallback, _ID, 'getPresets', args, false);
+};
+
+/**
+ * @description <p>Set the current station as a preset at the specified index
+ * <p>You can optionally specify a different station and tuner as a preset. 
+ * @param {Number} index The preset index.
+ * @param {String} group The preset group.
+ * @param {Number} [station] The station to set as the preset. If this is not specified, the current station is used.
+ * @param {String} [tuner] The tuner of the presets. If not specified, the active tuner is used.
+ * @param {Function} [successCallback] The function to call on success.
+ * @param {Function} [errorCallback] The function to call if there is an error.
+ * @memberOf module:car.radio
+ * @method setPreset
+ * @example 
+ *
+ * //define your callback function(s)
+ * function successCallback() {
+ *		console.log('preset was successfully set');
+ * }
+ *
+ * function errorCallback(error) {
+ *		console.log(error.code, error.msg);
+ * }
+ *
+ * //call the method
+ * car.radio.setPreset(0, 'am1', 1030, 'am', successCallback, errorCallback);
+ *
+ *
+ *
+ * @example REST
+ *
+ * Request:
+ * http://&lt;car-ip&gt;/car/radio/setPreset?index=0&group=am1&station=1030&tuner=am
+ *
+ * Success Response:
+ * {
+ *		code: 1,
+ * }
+ *
+ * Error Response:
+ * {
+ *		code: -1,
+ *		msg: "An error has occurred"
+ * }
+ */
+_self.setPreset = function(index, group, station, tuner, successCallback, errorCallback) {
+	var args = { 
+		index: index,
+		group: group
+	};
+	if (station) {
+		args["station"] = station;
+	}
+	if (tuner) {
+		args["tuner"] = tuner;
+	}
+	window.cordova.exec(successCallback, errorCallback, _ID, 'setPreset', args, false);
+};
+
+/**
+ * Seek for the next radio station in the specified direction
+ * @param {String} direction The direction to seek ('up' or 'down').
+ * @param {Function} [successCallback] The function to call on success.
+ * @param {Function} [errorCallback] The function to call if there is an error.
+ * @memberOf module:car.radio
+ * @method seek
+ * @example 
+ *
+ * //define your callback function(s)
+ * function successCallback() {
+ *		console.log('seek was successfully called');
+ * }
+ *
+ * function errorCallback(error) {
+ *		console.log(error.code, error.msg);
+ * }
+ *
+ * //call the method
+ * car.radio.seek('up', successCallback, errorCallback);
+ *
+ *
+ *
+ * @example REST
+ *
+ * Request:
+ * http://&lt;car-ip&gt;/car/radio/seek?direction=up
+ *
+ * Success Response:
+ * {
+ *		code: 1,
+ * }
+ *
+ * Error Response:
+ * {
+ *		code: -1,
+ *		msg: "An error has occurred"
+ * }
+ */
+_self.seek = function(direction, successCallback, errorCallback) {
+	var args = { 
+		direction: direction 
+	};
+    window.cordova.exec(successCallback, errorCallback, _ID, 'seek', args, false);
+};
+
+/**
+ * Scan for available radio stations in the specified direction
+ * @param {String} direction The direction to seek ('up' or 'down').
+ * @param {Function} [successCallback] The function to call on success.
+ * @param {Function} [errorCallback] The function to call if there is an error.
+ * @memberOf module:car.radio
+ * @method scan
+ * @example 
+ *
+ * //define your callback function(s)
+ * function successCallback() {
+ *		console.log('scan was successfully called');
+ * }
+ *
+ * function errorCallback(error) {
+ *		console.log(error.code, error.msg);
+ * }
+ *
+ * //call the method
+ * car.radio.scan('up', successCallback, errorCallback);
+ *
+ *
+ *
+ * @example REST
+ *
+ * Request:
+ * http://&lt;car-ip&gt;/car/radio/scan?direction=up
+ *
+ * Success Response:
+ * {
+ *		code: 1,
+ * }
+ *
+ * Error Response:
+ * {
+ *		code: -1,
+ *		msg: "An error has occurred"
+ * }
+ */
+_self.scan = function(direction, successCallback, errorCallback) {
+	var args = { 
+		direction: direction 
+	};
+    window.cordova.exec(successCallback, errorCallback, _ID, 'scan', args, false);
+};
+
+/**
+ * Stop station scanning if in progress
+ * @param {Function} [successCallback] The function to call on success.
+ * @param {Function} [errorCallback] The function to call if there is an error.
+ * @memberOf module:car.radio
+ * @method scanStop
+ * @example 
+ *
+ * //define your callback function(s)
+ * function successCallback() {
+ *		console.log('scanStop was successfully called');
+ * }
+ *
+ * function errorCallback(error) {
+ *		console.log(error.code, error.msg);
+ * }
+ *
+ * //call the method
+ * car.radio.scanStop(successCallback, errorCallback);
+ *
+ *
+ *
+ * @example REST
+ *
+ * Request:
+ * http://&lt;car-ip&gt;/car/radio/scanStop
+ *
+ * Success Response:
+ * {
+ *		code: 1,
+ * }
+ *
+ * Error Response:
+ * {
+ *		code: -1,
+ *		msg: "An error has occurred"
+ * }
+ */
+_self.scanStop = function(successCallback, errorCallback) {
+    window.cordova.exec(successCallback, errorCallback, _ID, 'scanStop', null, false);
+};
+
+/**
+ * Get the current station metadata
+ * @param {Function} [successCallback] The function to call on success.
+ * @param {Function} [errorCallback] The function to call if there is an error.
+ * @memberOf module:car.radio
+ * @method getStatus
+ * @example 
+ *
+ * //define your callback function(s)
+ * function successCallback(data) {
+ *			console.log("tuner = " + data.tuner + "\n" +
+ *						"artist = " + data.artist + "\n" +
+ *						"genre = " + data.genre + "\n" +
+ *						"song = " + data.song + "\n" +
+ *						"station = " + data.station + "\n" +
+ *						"stationName = " + data.stationName + "\n" +
+ *						"hd = " + data.hd
+ *			);
+ *		}
+ * }
+ *
+ * function errorCallback(error) {
+ *		console.log(error.code, error.msg);
+ * }
+ *
+ * //call the method
+ * car.radio.getStatus(successCallback, errorCallback);
+ *
+ *
+ *
+ * @example REST
+ *
+ * Request:
+ * http://&lt;car-ip&gt;/car/radio/getStatus
+ *
+ * Success Response:
+ * {
+ *		code: 1,
+ *		data: {
+ *     		tuner: 'fm'
+ *     		artist: 'Bjork',
+ *     		genre: 'News & Entertainment',
+ *     		song: 'All is Full of Love',
+ *     		station: 91.5,
+ *     		stationName: 'CBC Radio 1',
+ *     		hd: false
+ *		}
+ * }
+ *
+ * Error Response:
+ * {
+ *		code: -1,
+ *		msg: "An error has occurred"
+ * }
+ */
+_self.getStatus = function(successCallback, errorCallback) {
+	window.cordova.exec(successCallback, errorCallback, _ID, 'getStatus', null, false);
+};
+
+
+//Export
+module.exports = _self;
+
-- 
1.7.10.msysgit.1

