From b592adf4e3f8fb021ad532c6e55cc2aa5df6fa22 Mon Sep 17 00:00:00 2001
From: Marc Lapierre <marc@eternallabs.com>
Date: Thu, 26 Sep 2013 10:50:12 -0400
Subject: [PATCH 33/61] JI:450841 CI:nschultz@qnx.com Contains changes to
 qnx.bluetooth and added qnx.bluetooth.pbap as well as
 qnx.phone

---
 plugin/com.qnx.bluetooth.pbap/plugin.xml           |   36 ++
 .../src/blackberry10/context.js                    |   64 ++++
 .../src/blackberry10/index.js                      |  245 +++++++++++++
 .../src/blackberry10/pbap.js                       |  312 ++++++++++++++++
 .../src/blackberry10/servicestate.js               |   28 ++
 .../src/blackberry10/servicestatus.js              |   28 ++
 plugin/com.qnx.bluetooth.pbap/www/client.js        |  385 ++++++++++++++++++++
 plugin/com.qnx.bluetooth/plugin.xml                |    1 +
 .../src/blackberry10/bluetooth.js                  |  141 ++++++-
 .../com.qnx.bluetooth/src/blackberry10/context.js  |   64 ++++
 plugin/com.qnx.bluetooth/src/blackberry10/index.js |  118 +++++-
 plugin/com.qnx.bluetooth/www/client.js             |   86 ++++-
 plugin/com.qnx.phone/plugin.xml                    |   34 ++
 plugin/com.qnx.phone/src/blackberry10/context.js   |   76 ++++
 plugin/com.qnx.phone/src/blackberry10/index.js     |  241 ++++++++++++
 plugin/com.qnx.phone/src/blackberry10/phone.js     |  218 +++++++++++
 plugin/com.qnx.phone/www/client.js                 |  189 ++++++++++
 17 files changed, 2256 insertions(+), 10 deletions(-)
 create mode 100644 plugin/com.qnx.bluetooth.pbap/plugin.xml
 create mode 100644 plugin/com.qnx.bluetooth.pbap/src/blackberry10/context.js
 create mode 100644 plugin/com.qnx.bluetooth.pbap/src/blackberry10/index.js
 create mode 100644 plugin/com.qnx.bluetooth.pbap/src/blackberry10/pbap.js
 create mode 100644 plugin/com.qnx.bluetooth.pbap/src/blackberry10/servicestate.js
 create mode 100644 plugin/com.qnx.bluetooth.pbap/src/blackberry10/servicestatus.js
 create mode 100644 plugin/com.qnx.bluetooth.pbap/www/client.js
 create mode 100644 plugin/com.qnx.bluetooth/src/blackberry10/context.js
 create mode 100644 plugin/com.qnx.phone/plugin.xml
 create mode 100644 plugin/com.qnx.phone/src/blackberry10/context.js
 create mode 100644 plugin/com.qnx.phone/src/blackberry10/index.js
 create mode 100644 plugin/com.qnx.phone/src/blackberry10/phone.js
 create mode 100644 plugin/com.qnx.phone/www/client.js

diff --git a/plugin/com.qnx.bluetooth.pbap/plugin.xml b/plugin/com.qnx.bluetooth.pbap/plugin.xml
new file mode 100644
index 0000000..5a7f9a5
--- /dev/null
+++ b/plugin/com.qnx.bluetooth.pbap/plugin.xml
@@ -0,0 +1,36 @@
+<!--
+Copyright 2013  QNX Software Systems Limited
+
+Licensed under the Apache License, Version 2.0 (the "License"). You
+may not reproduce, modify or distribute this software except in
+compliance with the License. You may obtain a copy of the License
+at: http://www.apache.org/licenses/LICENSE-2.0.
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" basis,
+WITHOUT WARRANTIES OF ANY KIND, either express or implied.
+This file may contain contributions from others, either as
+contributors under the License or as licensors under other terms.
+Please review this entire file for other proprietary rights or license
+notices, as well as the applicable QNX License Guide at
+http://www.qnx.com/legal/licensing/document_archive/current_matrix.pdf
+for other information.
+-->
+<plugin xmlns="http://www.phonegap.com/ns/plugins/1.0"
+	id="com.qnx.bluetooth.pbap"
+	version="1.0.0">
+	<js-module src="www/client.js">
+		<clobbers target="qnx.bluetooth.pbap" />
+	</js-module>
+
+	<platform name="blackberry10">
+		<source-file src="src/blackberry10/index.js" />
+		<source-file src="src/blackberry10/context.js" />
+		<source-file src="src/blackberry10/pbap.js" />
+		<source-file src="src/blackberry10/servicestate.js" />
+		<source-file src="src/blackberry10/servicestatus.js" />
+		<config-file target="www/config.xml" parent="/widget">
+			<feature name="com.qnx.bluetooth.pbap" value="com.qnx.bluetooth.pbap" />
+		</config-file>
+	</platform>
+</plugin>
diff --git a/plugin/com.qnx.bluetooth.pbap/src/blackberry10/context.js b/plugin/com.qnx.bluetooth.pbap/src/blackberry10/context.js
new file mode 100644
index 0000000..fa0d69b
--- /dev/null
+++ b/plugin/com.qnx.bluetooth.pbap/src/blackberry10/context.js
@@ -0,0 +1,64 @@
+/*
+ * Copyright 2013  QNX Software Systems Limited
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"). You
+ * may not reproduce, modify or distribute this software except in
+ * compliance with the License. You may obtain a copy of the License
+ * at: http://www.apache.org/licenses/LICENSE-2.0.
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTIES OF ANY KIND, either express or implied.
+ * This file may contain contributions from others, either as
+ * contributors under the License or as licensors under other terms.
+ * Please review this entire file for other proprietary rights or license
+ * notices, as well as the applicable QNX License Guide at
+ * http://www.qnx.com/legal/licensing/document_archive/current_matrix.pdf
+ * for other information.
+ */
+
+/**
+ * The event context for contact service events.
+ */
+
+var _pbap = require("./pbap");
+
+/**
+ * Exports are the publicly accessible functions
+ */
+module.exports = {
+	/**
+	 * Method called when the first listener is added for an event
+	 * @param event {String} The event name
+	 * @param trigger {Function} The trigger function to call when the event is fired
+	 */
+	addEventListener: function (event, trigger) {
+		if (event && trigger) {
+			switch (event) {
+				case "bluetoothpbapstatechange":
+					_pbap.setStateChangedTrigger(trigger);
+					break;
+				case "bluetoothpbapstatuschange":
+					_pbap.setStatusChangedTrigger(trigger);
+					break;
+			}
+		}
+	},
+
+	/**
+	 * Method called when the last listener is removed for an event
+	 * @param event {String} The event name
+	 */
+	removeEventListener: function (event) {
+		if (event) {
+			switch (event) {
+				case "bluetoothpbapstatechange":
+					_pbap.setStateChangedTrigger(null);
+					break;
+				case "bluetoothpbapstatuschange":
+					_pbap.setStatusChangedTrigger(null);
+					break;
+			}
+		}
+	}
+};
diff --git a/plugin/com.qnx.bluetooth.pbap/src/blackberry10/index.js b/plugin/com.qnx.bluetooth.pbap/src/blackberry10/index.js
new file mode 100644
index 0000000..bb03739
--- /dev/null
+++ b/plugin/com.qnx.bluetooth.pbap/src/blackberry10/index.js
@@ -0,0 +1,245 @@
+/*
+ * Copyright 2013  QNX Software Systems Limited
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"). You
+ * may not reproduce, modify or distribute this software except in
+ * compliance with the License. You may obtain a copy of the License
+ * at: http://www.apache.org/licenses/LICENSE-2.0.
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTIES OF ANY KIND, either express or implied.
+ * This file may contain contributions from others, either as
+ * contributors under the License or as licensors under other terms.
+ * Please review this entire file for other proprietary rights or license
+ * notices, as well as the applicable QNX License Guide at
+ * http://www.qnx.com/legal/licensing/document_archive/current_matrix.pdf
+ * for other information.
+ */
+
+/**
+ * Allows access to device contact PIM storage.
+ */
+var _wwfix = require("../../lib/wwfix"),
+	_actionMap = {
+		/**
+		 * @event
+		 * Triggered when the contact service state has changed.
+		 */
+		bluetoothpbapstatechange: {
+			context: require("./context"),
+			event: "bluetoothpbapstatechange",
+			triggerEvent: "bluetoothpbapstatechange",
+			trigger: function (pluginResult, data) {
+				pluginResult.callbackOk(data, true);
+			} 
+		},
+		/**
+		 * @event
+		 * Triggered when the contact service status has changed.
+		 */
+		bluetoothpbapstatuschange: {
+			context: require("./context"),
+			event: "bluetoothpbapstatuschange",
+			triggerEvent: "bluetoothpbapstatuschange",
+			trigger: function (pluginResult, data) {
+				pluginResult.callbackOk(data, true);
+			} 
+		}
+	},
+	_pbap = require("./pbap"),
+	_listeners = {};
+
+/**
+ * Initializes the extension 
+ */
+function init() {
+	try {
+		_pbap.init();
+	} catch (ex) {
+		console.error('Error in webworks ext: blueooth.pbap/index.js:init():', ex);
+	}
+}
+init();
+
+/**
+ * Exports are the publicly accessible functions
+ */
+module.exports = {
+
+	/**
+	 * Turn on event dispatching for a specific event name
+	 * @param {Function} success Function to call if the operation is a success
+	 * @param {Function} fail Function to call if the operation fails
+	 * @param {Object} args The arguments supplied
+	 * @param {Object} env Environment variables
+	 */
+	startEvent: function (success, fail, args, env) {
+		var result = new PluginResult(args, env);
+		try {
+			var fixedArgs = _wwfix.parseArgs(args),
+			 	eventName = fixedArgs.eventName,
+				context = _actionMap[eventName].context,
+				systemEvent = _actionMap[eventName].event,
+				listener = _actionMap[eventName].trigger.bind(null, result);
+
+			if (!_listeners[eventName]) {
+				_listeners[eventName] = {};
+			}
+
+			if (_listeners[eventName][env.webview.id]) {
+				//TODO: Stop all listeners on plugin reset and renable this error
+				//result.error("Underlying listener for " + eventName + " already already running for webview " + env.webview.id);
+				context.removeEventListener(systemEvent, _listeners[eventName][env.webview.id]);
+			}
+
+			context.addEventListener(systemEvent, listener);
+			_listeners[eventName][env.webview.id] = listener;
+			result.noResult(true);
+ 		} catch (e) {
+			_eventResult.error("error in startEvent: " + JSON.stringify(e), false);
+		}
+   },
+
+	/**
+	 * Turn off event dispatching for a specific event name
+	 * @param {Function} success Function to call if the operation is a success
+	 * @param {Function} fail Function to call if the operation fails
+	 * @param {Object} args The arguments supplied
+	 * @param {Object} env Environment variables
+	 */
+	stopEvent: function (success, fail, args, env) {
+		var result = new PluginResult(args, env);
+		try {
+			var fixedArgs = _wwfix.parseArgs(args),
+			 	eventName = fixedArgs.eventName,
+				context = _actionMap[eventName].context,
+				systemEvent = _actionMap[eventName].event,
+				listener;
+
+		if (!_listeners || !_listeners[eventName] || !_listeners[eventName][env.webview.id]) {
+			result.error("Underlying listener for " + eventName + " never started for webview " + env.webview.id);
+		} else {
+			listener = _listeners[eventName][env.webview.id];
+			context.removeEventListener(systemEvent, listener);
+			delete _listeners[eventName][env.webview.id];
+			result.noResult(false);
+		}
+		} catch (e) {
+			_eventResult.error("error in stopEvent: " + JSON.stringify(e), false);
+		}
+	},
+
+	/**
+	 * 
+	 * @param success {Function} Function to call if the operation is a success
+	 * @param fail {Function} Function to call if the operation fails
+	 * @param args {Object} The arguments supplied. Available arguments for this call are: N/A
+	 * @param env {Object} Environment variables
+	 */
+	find: function(success, fail, args, env) {
+		var result = new PluginResult(args, env);
+		try {
+			var fixedArgs = _wwfix.parseArgs(args);
+			var data = _pbap.find(typeof(fixedArgs['filter']) === 'object' ? fixedArgs['filter'] : null,
+									typeof(fixedArgs['orderBy']) === 'string' ? fixedArgs['orderBy'] : null,
+									typeof(fixedArgs['isAscending']) === 'boolean' ? fixedArgs['isAscending'] : null,
+									typeof(fixedArgs['limit']) === 'number' ? fixedArgs['limit'] : null,
+									typeof(fixedArgs['offset']) === 'number' ? fixedArgs['offset'] : null);
+			result.ok(data, false);
+		} catch (e) {
+			result.error(JSON.stringify(e), false);
+		}
+	},
+
+	/**
+	 * Creates or updates a contact.
+	 * @param success {Function} Function to call if the operation is a success
+	 * @param fail {Function} Function to call if the operation fails
+	 * @param args {Object} The arguments supplied. Available arguments for this call are: N/A
+	 * @param env {Object} Environment variables
+	 */
+	save: function(success, fail, args, env) {
+		var result = new PluginResult(args, env);
+		try {
+			var fixedArgs = _wwfix.parseArgs(args);
+			_pbap.save(fixedArgs.contact);
+			result.ok(undefined, false);
+		} catch (e) {
+			result.error(JSON.stringify(e), false);
+		}
+	},
+
+	/**
+	 * Removes a contact.
+	 * @param success {Function} Function to call if the operation is a success
+	 * @param fail {Function} Function to call if the operation fails
+	 * @param args {Object} The arguments supplied. Available arguments for this call are: N/A
+	 * @param env {Object} Environment variables
+	 */
+	remove: function(success, fail, args, env) {
+		var result = new PluginResult(args, env);
+		try {
+			var fixedArgs = _wwfix.parseArgs(args);
+			_pbap.remove(fixedArgs.contact);
+			result.ok(undefined, false);
+		} catch (e) {
+			result.error(JSON.stringify(e), false);
+		}
+	},
+	
+	/**
+	 * Gets the current state of the contact service.
+	 * @param success {Function} Function to call if the operation is a success
+	 * @param fail {Function} Function to call if the operation fails
+	 * @param args {Object} The arguments supplied. Available arguments for this call are: N/A
+	 * @param env {Object} Environment variables
+	 */
+	getState: function(success, fail, args, env) {
+		var result = new PluginResult(args, env);
+		try {
+			var fixedArgs = _wwfix.parseArgs(args);
+			var data = _pbap.getState();
+			result.ok(data, false);
+		} catch (e) {
+			result.error(JSON.stringify(e), false);
+		}
+	},
+
+	/**
+	 * Gets the current status of the contact service.
+	 * @param success {Function} Function to call if the operation is a success
+	 * @param fail {Function} Function to call if the operation fails
+	 * @param args {Object} The arguments supplied. Available arguments for this call are: N/A
+	 * @param env {Object} Environment variables
+	 */
+	getStatus: function(success, fail, args, env) {
+		var result = new PluginResult(args, env);
+		try {
+			var fixedArgs = _wwfix.parseArgs(args);
+			var data = _pbap.getStatus();
+			result.ok(data, false);
+		} catch (e) {
+			result.error(JSON.stringify(e), false);
+		}
+	},
+	
+	/**
+	 * Forces a phone book resynchronization with the connected device.
+	 * @param success {Function} Function to call if the operation is a success
+	 * @param fail {Function} Function to call if the operation fails
+	 * @param args {Object} The arguments supplied. Available arguments for this call are: N/A
+	 * @param env {Object} Environment variables
+	 */
+	refresh: function(success, fail, args, env) {
+		var result = new PluginResult(args, env)
+		try {
+			var fixedArgs = _wwfix.parseArgs(args);
+			_pbap.refresh();
+			result.ok(undefined, false);
+		} catch (e) {
+			result.error(JSON.stringify(e), false);
+		}
+	}
+};
+
diff --git a/plugin/com.qnx.bluetooth.pbap/src/blackberry10/pbap.js b/plugin/com.qnx.bluetooth.pbap/src/blackberry10/pbap.js
new file mode 100644
index 0000000..1ed474f
--- /dev/null
+++ b/plugin/com.qnx.bluetooth.pbap/src/blackberry10/pbap.js
@@ -0,0 +1,312 @@
+/*
+ * Copyright 2013  QNX Software Systems Limited
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"). You
+ * may not reproduce, modify or distribute this software except in
+ * compliance with the License. You may obtain a copy of the License
+ * at: http://www.apache.org/licenses/LICENSE-2.0.
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTIES OF ANY KIND, either express or implied.
+ * This file may contain contributions from others, either as
+ * contributors under the License or as licensors under other terms.
+ * Please review this entire file for other proprietary rights or license
+ * notices, as well as the applicable QNX License Guide at
+ * http://www.qnx.com/legal/licensing/document_archive/current_matrix.pdf
+ * for other information.
+ */
+
+/**
+ * The abstraction layer for Bluetooth PBAP functionality.
+ * Note that this currently only supports contacts sychnronized via Bluetooth PBAP.
+ */
+
+var	_pps = qnx.webplatform.pps,
+	_qdb = require('../../lib/qdb'),
+	_statusPPS,
+	_commandPPS,
+	ServiceState = require('./servicestate'),
+	ServiceStatus = require('./servicestatus'),
+	_stateChangedTrigger,
+	_statusChangedTrigger,
+	_db;
+
+// PBAP status PPS object constants
+var PBAP_STATE_CONNECTING = 'CONNECTING',
+	PBAP_STATE_CONNECTED = 'CONNECTED',
+	PBAP_STATE_DISCONNECTED = 'DISCONNECTED',
+	PBAP_STATUS_COMPLETE = 'COMPLETE',
+	PBAP_STATUS_PROCESSING = 'PROCESSING',
+	PBAP_STATUS_FAIL = 'FAILED';
+
+/**
+ * PBAP status PPS object change handler. Responsible for firing
+ * the extension events.
+ * @param event {Event} The PPS change event
+ */
+function onStatusEvent(event) {
+	// State change
+	if(_stateChangedTrigger && event && event.data && event.data.state) {
+		_stateChangedTrigger(pbapStateToServiceState(event.data.state));
+	}
+
+	// Status change
+	if(event && event.data && event.data.status) {
+		if(_statusChangedTrigger && event && event.data && event.data.status) {
+			_statusChangedTrigger(pbapStatusToServiceStatus(event.data.status));
+		}
+	}
+}
+
+/**
+ * Converts the PBAP-specific contacts service state string into a state constant
+ * defined in the qnx.bluetooth.pbap extension.
+ * @param pbapState {String} The PBAP state string.
+ * @returns {String} A qnx.bluetooth.pbap state constant.
+ */
+function pbapStateToServiceState(pbapState) {
+	var state = null;
+	switch(pbapState) {
+		case PBAP_STATE_CONNECTED:		state = ServiceState.STATE_CONNECTED;		break;
+		case PBAP_STATE_DISCONNECTED:	state = ServiceState.STATE_DISCONNECTED;	break;
+		case PBAP_STATE_CONNECTING:		state = ServiceState.STATE_CONNECTING;		break;
+	}
+	return state;
+}
+
+/**
+ * Converts the PBAP-specific contacts service status string into a status constant
+ * defined in the qnx.bluetooth.pbap extension. Note that the only action we can execute
+ * on the PBAP control object is to refresh, and so the only status reported (ready, processing, fail)
+ * is strictly related to the refresh action.
+ * @param pbapStatus {String} The PBAP status string.
+ * @returns {String} A qnx.bluetooth.pbap status constant.
+ */
+function pbapStatusToServiceStatus(pbapStatus) {
+	var status = null;
+	switch(pbapStatus) {
+		case PBAP_STATUS_COMPLETE:		status = ServiceStatus.STATUS_READY;		break;
+		case PBAP_STATUS_PROCESSING:	status = ServiceStatus.STATUS_REFRESHING;	break;
+		case PBAP_STATUS_FAIL:			status = ServiceStatus.STATUS_ERROR;		break;
+	}
+	return status;
+}
+
+/** 
+ * Converts a FilterExpression used for the find operation into a string.
+ * Note that this is specific to PBAP, and each contacts service would have
+ * to define their own function to suit its needs.
+ * @param filterExpression {qnx.bluetooth.pbap.FilterExpression} The FilterExpression object.
+ * @return {String} A SQL string for use on the PBAP contacts_view view.
+ */
+function filterExpressionToString(filterExpression) {
+	// FIXME: There's an opportunity to perform an SQL injection attack here
+	var str = '';
+	
+	if(typeof(filterExpression) === 'object' &&
+			filterExpression.hasOwnProperty('leftField') &&
+			filterExpression.hasOwnProperty('operator') &&
+			filterExpression.hasOwnProperty('rightField')) {
+		str = '(';
+		
+		// Add the left field
+		if(typeof(filterExpression.leftField) === 'object') {
+			str += filterExpressionToString(filterExpression.leftField);
+		} else {
+			str += filterExpression.leftField;
+		}
+		
+		// Add the operator
+		str += ' ' + filterExpression.operator + ' ';
+		
+		// Add the right field
+		if(typeof(filterExpression.rightField) === 'object') {
+			str += filterExpressionToString(filterExpression.rightField);
+		} else if(typeof(filterExpression.rightField) === 'number') {
+			str += filterExpression.rightField;
+		} else {
+			str += '\'' + filterExpression.rightField + '\'';
+		}
+		
+		str += ')';
+	} else {
+		console.error('Unrecognized FilterExpression object.', filterExpression);
+	}
+	
+	return str;
+}
+
+/**
+ * Exports are the publicly accessible functions
+ */
+module.exports = {
+	/** Constants **/
+	COMMAND_REFRESH: 'SYNC_START',
+	
+	/**
+	 * Initializes the extension.
+	 */
+	init: function() {
+		try {
+			//_statusPPS
+			_statusPPS = _pps.createObject("/pps/services/bluetooth/phonebook/status", _pps.PPSMode.DELTA);
+			_statusPPS.onNewData = onStatusEvent;
+			_statusPPS.open(_pps.FileMode.RDONLY);
+		} catch(ex) {
+			var err = 'qnx.phonebook::init [pbap.js] Error opening /pps/services/bluetooth/phonebook/status';
+			console.error(err);
+			throw new Error(err);
+		}
+		
+		try {
+			//writing pps commands
+			_commandPPS = _pps.createObject("/pps/services/bluetooth/phonebook/control", _pps.PPSMode.DELTA);
+			_commandPPS.open(_pps.FileMode.WRONLY);
+		} catch(ex) {
+			var err = 'qnx.phonebook::init [pbap.js] Error opening /pps/services/bluetooth/phonebook/control';
+			console.error(err);
+			throw new Error(err);
+		}
+		
+		// Create database object
+		_db = _qdb.createObject();
+		if (!_db || !_db.open('/dev/qdb/phonebook')) {
+			var err = 'qnx.phonebook::init [pbap.js] Error opening db; path=/dev/qdb/phonebook';
+			console.error(err);
+			throw new Error(err);
+		}
+	},
+	
+	/**
+	 * Sets the trigger function to call when an event is fired
+	 * @param trigger {Function} The trigger function to call when an event is fired
+	 */
+	setStateChangedTrigger: function(trigger) {
+		_stateChangedTrigger = trigger;
+	},
+	
+	/**
+	 * Sets the trigger function to call when an event is fired
+	 * @param trigger {Function} The trigger function to call when an event is fired
+	 */
+	setStatusChangedTrigger: function(trigger) {
+		_statusChangedTrigger = trigger;
+	},
+	
+	/**
+	 * Returns an array of zero or more contacts.
+	 * @param filterExpression {qnx.bluetooth.pbap.FilterExpression} (Optional) The FilterExpression to apply.
+	 * @param orderBy {String} (Optional) The field used to order the results.
+	 * @param isAscending {Boolean} (Optional) If orderBy is specified, changes the direction of the sort to ascending
+	 * if true, descending if false. Defaults to false.
+	 * @param limit {Number} (Optional) The maximum number of results to return.
+	 * @param offset {Number} (Optional) The offset for the results.
+	 * @returns
+	 */
+	find: function(filterExpression, orderBy, isAscending, limit, offset) {
+		var sql = 'SELECT * FROM contacts_view' +
+					(typeof(filterExpression) === 'object' && filterExpression ? ' WHERE ' + filterExpressionToString(filterExpression) : '') +
+					(typeof(orderBy) === 'string' ? ' ORDER BY ' + orderBy + (typeof(isAscending) === 'boolean' && isAscending ? ' ASC' : ' DESC') : '') +
+					' LIMIT ' + (typeof(limit) === 'number' ? limit : -1) +
+					' OFFSET ' + (typeof(offset) === 'number' ? offset : 0);
+		
+		// Get the array of results
+		var result = _qdb.resultToArray(_db.query(sql));
+		
+		if(result.length > 0) {
+			// Must return objects which client can convert into Contact instances. 
+
+			// In the case of PBAP, we already know that this particular database view contains the right fields,
+			// but we need to convert the property names to camel cased rather than underscore-delimited.
+			
+			// Build an array of property names that need to be renamed. We should only have
+			// to do this once, since all of the property names will be the same for each
+			// record.
+			var propsToRename = [];
+			for(var prop in result[0]) {
+				if(prop.indexOf('_') >= 0) {
+					propsToRename.push(prop);
+				}
+			}
+			
+			// Now we can iterate through each of the records in the result and rename the properties
+			for(var i=0; i < result.length; i++) {
+				for(var j=0; j < propsToRename.length; j++) {
+					// Add the renamed property to the record
+					result[i][propsToRename[j].replace(/_([a-zA-Z])/g, function(match, letter) { return letter.toUpperCase(); }).replace('_', '')] = result[i][propsToRename[j]];
+					
+					// Remove the old underscore property from the record
+					delete result[i][propsToRename[j]];					
+				}
+			}
+		}
+		
+		return result;
+	},
+	
+	/**
+	 * Saves a contact to the device PIM storage.
+	 * @param contact {qnx.bluetooth.pbap.Contact} The contact to create or update.
+	 * @return {Number} The existing or new unique identifier for the contact.
+	 */
+	save: function(contact) {
+		var err = 'qnx.bluetooth.pbap::save [pbap.js] is not supported';
+		console.error(err);
+		throw Error(err);
+	},
+	
+	/**
+	 * Removes a contact from the device PIM storage.
+	 * @param contact {qnx.bluetooth.pbap.Contact} The contact to remove.
+	 */
+	remove: function(contact) {
+		var err = 'qnx.bluetooth.pbap::remove [pbap.js] is not supported';
+		console.error(err);
+		throw Error(err);
+	},
+	
+	/**
+	 * Gets the current state of the contact service.
+	 * @param service {String} The contact service.
+	 * @returns {String} The contact service state. A null value is returned if the state is not available.
+	 */
+	getState: function() {
+		var state = null;
+		if(_statusPPS.data.status && _statusPPS.data.status.state) {
+			state = pbapStateToServiceState(_statusPPS.data.status.state);
+		} else {
+			console.warn('/pps/services/bluetooth/phonebook/status state attribute does not exist.');
+		}
+		return state;
+	},
+	
+	/**
+	 * Gets the current status of the contact service.
+	 * @param service {String} The contact service.
+	 * @returns {String} The phone book service status. A null value is returned if the status is not available.
+	 */
+	getStatus: function() {
+		var state = null;
+		if(_statusPPS.data.status && _statusPPS.data.status.status) {
+			state = pbapStatusToServiceStatus(_statusPPS.data.status.status);
+		} else {
+			console.warn('/pps/services/bluetooth/phonebook/status status attribute does not exist.');
+		}
+		return state;
+	},
+	
+	/**
+	 * Forces the contacts in the PIM storage to refresh.
+	 * @param service {String} The contact service.
+	 */
+	refresh: function() {
+		try {
+			_commandPPS.write({'[n]command': this.COMMAND_REFRESH});
+		} catch(ex) {
+			var err = 'qnx.bluetooth.pbap::refresh [pbap.js] Failed to write refresh command to /pps/services/bluetooth/phonebook/control.';
+			console.error(err);
+			throw new Error(err);
+		}
+	}
+};
diff --git a/plugin/com.qnx.bluetooth.pbap/src/blackberry10/servicestate.js b/plugin/com.qnx.bluetooth.pbap/src/blackberry10/servicestate.js
new file mode 100644
index 0000000..25eff8d
--- /dev/null
+++ b/plugin/com.qnx.bluetooth.pbap/src/blackberry10/servicestate.js
@@ -0,0 +1,28 @@
+/*
+ * Copyright 2013  QNX Software Systems Limited
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"). You
+ * may not reproduce, modify or distribute this software except in
+ * compliance with the License. You may obtain a copy of the License
+ * at: http://www.apache.org/licenses/LICENSE-2.0.
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTIES OF ANY KIND, either express or implied.
+ * This file may contain contributions from others, either as
+ * contributors under the License or as licensors under other terms.
+ * Please review this entire file for other proprietary rights or license
+ * notices, as well as the applicable QNX License Guide at
+ * http://www.qnx.com/legal/licensing/document_archive/current_matrix.pdf
+ * for other information.
+ */
+
+/**
+ * The contact service state constants.
+ * State constants must be consistent with those defined in the qnx.bluetooth.pbap client.js.
+ */
+module.exports = {
+	STATE_CONNECTING:	'STATE_CONNECTING',
+	STATE_CONNECTED:	'STATE_CONNECTED',
+	STATE_DISCONNECTED:	'STATE_DISCONNECTED'
+};
\ No newline at end of file
diff --git a/plugin/com.qnx.bluetooth.pbap/src/blackberry10/servicestatus.js b/plugin/com.qnx.bluetooth.pbap/src/blackberry10/servicestatus.js
new file mode 100644
index 0000000..fe6be25
--- /dev/null
+++ b/plugin/com.qnx.bluetooth.pbap/src/blackberry10/servicestatus.js
@@ -0,0 +1,28 @@
+/*
+ * Copyright 2013  QNX Software Systems Limited
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"). You
+ * may not reproduce, modify or distribute this software except in
+ * compliance with the License. You may obtain a copy of the License
+ * at: http://www.apache.org/licenses/LICENSE-2.0.
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTIES OF ANY KIND, either express or implied.
+ * This file may contain contributions from others, either as
+ * contributors under the License or as licensors under other terms.
+ * Please review this entire file for other proprietary rights or license
+ * notices, as well as the applicable QNX License Guide at
+ * http://www.qnx.com/legal/licensing/document_archive/current_matrix.pdf
+ * for other information.
+ */
+
+/**
+ * The contact service status constants.
+ * Status constants must be consistent with those defined in the qnx.bluetooth.pbap client.js.
+ */
+module.exports = {
+	STATUS_READY:		'STATUS_READY',
+	STATUS_REFRESHING:	'STATUS_REFRESHING',
+	STATUS_ERROR:		'STATUS_ERROR',
+};
\ No newline at end of file
diff --git a/plugin/com.qnx.bluetooth.pbap/www/client.js b/plugin/com.qnx.bluetooth.pbap/www/client.js
new file mode 100644
index 0000000..7d28c6d
--- /dev/null
+++ b/plugin/com.qnx.bluetooth.pbap/www/client.js
@@ -0,0 +1,385 @@
+/*
+ * Copyright 2013  QNX Software Systems Limited
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"). You
+ * may not reproduce, modify or distribute this software except in
+ * compliance with the License. You may obtain a copy of the License
+ * at: http://www.apache.org/licenses/LICENSE-2.0.
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTIES OF ANY KIND, either express or implied.
+ * This file may contain contributions from others, either as
+ * contributors under the License or as licensors under other terms.
+ * Please review this entire file for other proprietary rights or license
+ * notices, as well as the applicable QNX License Guide at
+ * http://www.qnx.com/legal/licensing/document_archive/current_matrix.pdf
+ * for other information.
+ */
+
+
+/**
+ * Allows access to address book information over Bluetooth PBAP.
+ *
+ * <h3>Events</h3>
+ * <dl><dt><h4>bluetoothpbapstatechange</h4></dt>
+ * <dd><p>Fired when the state of a service has changed</p>
+ * <h5>Event data</h5>
+ * <p>{Object}</p>
+ * <h5>Example</h5>
+ * <pre><code>{
+ *      service: 'SERVICE_BLUETOOTH',
+ *      state: 'STATE_CONNECTED'
+ * }</code></pre></dd></dl>
+ *
+ * <dl><dt><h4>bluetoothpbapstatuschange</h4></dt>
+ * <dd><p>Fired when the status of the contact service has changed,
+ * e.g. the contact store is refreshing or service is ready</p>
+ * <h5>Event data</h5>
+ * <p>{Object}</p>
+ * <h5>Example</h5>
+ * <pre><code>{
+ *      service: 'SERVICE_BLUETOOTH'
+ *      status: 'REFRESHING'
+ *}</code></pre></dd></dl>
+ * 
+ * @module qnx.bluetooth.pbap
+ * @static
+ * @deprecated
+ */
+ 
+
+var _ID = "com.qnx.bluetooth.pbap",
+	_events = ["bluetoothpbapstatechange", "bluetoothpbapstatuschange"];
+
+
+_events.map(function (eventName) {
+	var channel = cordova.addDocumentEventHandler(eventName),
+		success = function (data) {
+			channel.fire(data);
+		},
+		fail = function (error) {
+			console.log("Error initializing " + eventName + " listener: ", error);
+		};
+
+	channel.onHasSubscribersChange = function () {
+		if (this.numHandlers === 1) {
+			window.cordova.exec(success, fail, _ID, "startEvent", {eventName: eventName});
+		} else if (this.numHandlers === 0) {
+			window.cordova.exec(null, null, _ID, "stopEvent", {eventName: eventName});
+		}
+	};
+});
+
+
+/**
+ * @static
+ * The <code>qnx.bluetooth.pbap.Contact</code> constructor function. Contact object instances represent contacts
+ * stored on the device from which the PBAP contacts were synchronized.
+ * @param {Object} [properties] The properties argument can be used to initialize the Contact instance's properties.
+ * 
+ * @example
+ * // The following code demonstrates how to create a new Contact object with its name
+ * // defaulted to 'John Doe'
+ * var contact = new qnx.bluetooth.pbap.Contact({ firstName: 'John', lastName: 'Doe'});
+ * 
+ * @property {String} anniversary The anniversary of the Contact in ISO 8601 format.
+ * @property {String} birthday The birthday of the Contact in ISO 8601 format.
+ * @property {String} categories A comma-separated list of categories to which this Contact belongs.
+ * @property {String} company The Contact's company.
+ * @property {String} email1 Primary email address.
+ * @property {String} email2 Secondary email address.
+ * @property {String} email3 Tertiary email address.
+ * @property {String} faxPhone The Contact's fax number.
+ * @property {String} firstName First name.
+ * @property {String} homeAddress1 Primary home address information.
+ * @property {String} homeAddress2 Secondary home address inofrmation.
+ * @property {String} homeAddressCity Home address city.
+ * @property {String} homeAddressCountry Home address country.
+ * @property {String} homeAddressStateProvince Home address state or province.
+ * @property {String} homeAddressZipPostal Home address zip or postal code.
+ * @property {String} homePhone Primary home phone number.
+ * @property {String} homePhone2 Secondary home phone number.
+ * @property {String} jobTitle The Contact's job title.
+ * @property {String} lastName Last name.
+ * @property {String} mobilePhone Mobile phone number.
+ * @property {String} note Additional contact information.
+ * @property {String} otherPhone Other phone number.
+ * @property {String} pagerPhone Pager number.
+ * @property {String} picture The fully qualified system path to the Contact's photo.
+ * @property {String} pin The Contact's device PIN.
+ * @property {String} title The Contact's title or titles.
+ * @property {String} uid Unique identifier for this Contact.
+ * @property {String} user1 User-defined field.
+ * @property {String} user2 User-defined field.
+ * @property {String} user3 User-defined field.
+ * @property {String} user4 User-defined field.
+ * @property {String} webpage The Contact's webpage URI.
+ * @property {String} workAddress1 Primary work address information.
+ * @property {String} workAddress2 Secondary work address information.
+ * @property {String} workAddressCity Work address city.
+ * @property {String} workAddressCountry Work address country.
+ * @property {String} workAddressStateProvince Work address state or province.
+ * @property {String} workAddressZipPostal Work address zip or postal code.
+ * @property {String} workPhone Primary work phone number.
+ * @property {String} workPhone2 Secondary work phone number.
+ */
+function Contact(properties) {
+	this.anniversary = null;
+	this.birthday = null;
+	this.categories = null;
+	this.company = null;
+	this.email1 = null;
+	this.email2 = null;
+	this.email3 = null;
+	this.faxPhone = null;
+	this.firstName = null;
+	this.homeAddress1 = null;
+	this.homeAddress2 = null;
+	this.homeAddressCity = null;
+	this.homeAddressCountry = null;
+	this.homeAddressStateProvince = null;
+	this.homeAddressZipPostal = null;
+	this.homePhone = null;
+	this.homePhone2 = null;
+	this.jobTitle = null;
+	this.lastName = null;
+	this.mobilePhone = null;
+	this.note = null;
+	this.otherPhone = null;
+	this.pagerPhone = null;
+	this.picture = null;
+	this.pin = null;
+	this.title = null;
+	this.uid = null;
+	this.user1 = null;
+	this.user2 = null;
+	this.user3 = null;
+	this.user4 = null;
+	this.webpage = null;
+	this.workAddress1 = null;
+	this.workAddress2 = null;
+	this.workAddressCity = null;
+	this.workAddressCountry = null;
+	this.workAddressStateProvince = null;
+	this.workAddressZipPostal = null;
+	this.workPhone = null;
+	this.workPhone2 = null;
+	
+	// Initialize properties
+	for(var prop in properties) {
+		if(this.hasOwnProperty(prop)) {
+			this[prop] = properties[prop];
+		}
+	};
+	
+	/**
+	 * qnx.bluetooth.pbap.Contact instance function to create or update the Contact in the device PIM storage.
+	 * If creating a new contact, the Contact's uid property will be updated to the new unique identifier for the
+	 * created Contact.
+	 * @inner
+	 * @deprecated Unsupported.
+	 */
+	this.save = function() {
+   		var value = null,
+			success = function (data, response) {
+				this.uid = data;
+			}.bind(this),
+			fail = function (data, response) {
+				throw data;
+			};
+
+		try {
+			window.cordova.exec(success, fail, _ID, 'save', { contact: this });
+		} catch (e) {
+			console.error(e);
+		}
+	};
+	
+	/**
+	 * qnx.bluetooth.pbap.Contact instance function to remove this Contact from the device PIM storage.
+	 * @inner
+	 * @deprecated Unsupported.
+	 */
+	this.remove = function() {
+		window.cordova.exec(null, null, _ID, 'remove', { contact: this });
+	};
+};
+
+/**
+ * @static
+ * The <code>qnx.bluetooth.pbap.FilterExpression</code> constructor function. <code>FilterExpression</code> objects
+ * can be used to filter the results of the <code>qnx.bluetooth.pbap.find()</code> function.
+ * @param {String|qnx.bluetooth.pbap.FilterExpression} leftField The field name or FilterExpression.
+ * @param {String} operator The filter operator, e.g. '=', '<', '>', '<>', 'LIKE', 'AND', 'OR'.
+ * @param {String|qnx.bluetooth.pbap.FilterExpression} rightField The field value or additional FilterExpression.
+ * 
+ * @example
+ * // The following code demonstrates how to create a new FilterExpression and get a
+ * // list of contacts filtered by last name = 'Doe'
+ * var filter = new qnx.bluetooth.pbap.FilterExpression(qnx.bluetooth.pbap.FIELD_LAST_NAME, '=', 'Doe'),
+ *     filteredContacts = qnx.bluetooth.pbap.find(filter);
+ * 
+ * @example
+ * // The leftField and rightField properties can also be FilterExpression objects themselves,
+ * // allowing the construction of complex filter expressions. The following code demonstrates
+ * // how to find a contact whose home number or mobile number is '555-555-5555'
+ * var filter = new qnx.bluetooth.pbap.FilterExpression(
+ *         new qnx.bluetooth.pbap.FilterExpression(qnx.bluetooth.pbap.FIELD_HOME_PHONE, '=', '555-555-5555'),
+ *         'OR',
+ *         new qnx.bluetooth.pbap.FilterExpression(qnx.bluetooth.pbap.FIELD_MOBILE_PHONE, '=', '555-555-5555')),
+ *     filteredContacts = qnx.bluetooth.pbap.find(filter);
+ * 
+ * @property {String|qnx.bluetooth.pbap.FilterExpression} leftField The field name or FilterExpression.
+ * @property {String} operator The filter operator, e.g. '=', '<', '>', '<>', 'LIKE', 'AND', 'OR'.
+ * @property {String|qnx.bluetooth.pbap.FilterExpression} rightField The field value or additional FilterExpression.
+ */
+function FilterExpression(leftField, operator, rightField) {
+	this.leftField = leftField;
+	this.operator = operator;
+	this.rightField = rightField;
+};
+
+/*
+ * Exports are the publicly accessible functions
+ */
+module.exports = {
+	/* State constants */
+	/** PBAP service in process of connecting*/
+	STATE_CONNECTING:	'STATE_CONNECTING',
+	/** PBAP service connected state */
+	STATE_CONNECTED:	'STATE_CONNECTED',
+	/** PBAP service disconnected state */
+	STATE_DISCONNECTED:	'STATE_DISCONNECTED',
+	
+	/* Status constants */
+	/** PBAP service ready status */
+	STATUS_READY:		'STATUS_READY',
+	/** PBAP service refreshing status */
+	STATUS_REFRESHING:	'STATUS_REFRESHING',
+	/** PBAP service error status */
+	STATUS_ERROR:		'STATUS_ERROR',
+
+	/* Filter constants */
+	/** <code>homePhone</code> field name for use in FilterExpression */
+	FIELD_HOME_PHONE:'home_phone',
+	/** <code>homePhone2</code> field name for use in FilterExpression */
+	FIELD_HOME_PHONE_2:'home_phone_2',
+	/** <code>workPhone</code> field name for use in FilterExpression */
+	FIELD_WORK_PHONE:'work_phone',
+	/** <code>workPhone2</code> field name for use in FilterExpression */
+	FIELD_WORK_PHONE_2:'work_phone_2',
+	/** <code>mobilePhone</code> field name for use in FilterExpression */
+	FIELD_MOBILE_PHONE:'mobile_phone',
+	/** <code>otherPhone</code> field name for use in FilterExpression */
+	FIELD_OTHER_PHONE:'other_phone',
+	/** <code>firstName</code> field name for use in FilterExpression */
+	FIELD_FIRST_NAME:'first_name',
+	/** <code>lastName</code> field name for use in FilterExpression */
+	FIELD_LAST_NAME:'last_name',
+	/** <code>email1</code> field name for use in FilterExpression */
+	FIELD_EMAIL_1:'email_1',
+	/** <code>email2</code> field name for use in FilterExpression */
+	FIELD_EMAIL_2:'email_2',
+	/** <code>email3</code> field name for use in FilterExpression */
+	FIELD_EMAIL_3:'email_3',
+
+	Contact: Contact,
+	
+	FilterExpression: FilterExpression,
+	
+	/**
+	 * Returns an array of zero or more {@link qnx.bluetooth.pbap.Contact} instances.
+	 * @param {qnx.bluetooth.pbap.FilterExpression} [filter] The
+	 * <code>qnx.bluetooth.pbap.FilterExpression</code> to apply against the phone book database.
+	 * @param {String} [orderBy] The field name to order by. If this parameter is
+	 * not specified, the results will be sorted first by last name ascending, then first name ascending.
+	 * @param {Boolean} [isAscending] If an <code>orderBy</code> parameter is supplied, changes the order
+	 * direction to ascending if true, descending if false. If an <code>orderBy</code> parameter
+	 * is not specified, <code>isAscending</code> has no effect. Defaults to false.
+	 * @param {Number} [limit] The maximum number of Contact instances to return. Defaults to -1 (no limit).
+	 * @param {Number} [offset] Specifies the record offset. Defaults to 0 (no offset).
+	 */
+	find: function(filter, orderBy, isAscending, limit, offset) {
+		var args = {};
+		
+		if (filter instanceof FilterExpression)	{ args['filter'] = filter; }
+		if (typeof(orderBy) === 'string')		{ args['orderBy'] = orderBy; }
+		if (typeof(isAscending) === 'boolean')	{ args['isAscending'] = isAscending; }
+		if (typeof(limit) === 'number')			{ args['limit'] = limit; }
+		if (typeof(offset) === 'number')		{ args['offset'] = offset; }
+		
+   		var value = null,
+			success = function (data, response) {
+				var contacts = [];
+				for(var result in data) {
+					contacts.push(new Contact(data[result]));
+				}
+				value = contacts;
+			},
+			fail = function (data, response) {
+				throw data;
+			};
+
+		try {
+			window.cordova.exec(success, fail, _ID, 'find', args);
+		} catch (e) {
+			console.error(e);
+		}
+
+		return value;
+	},
+	
+	/**
+	 * Get the current state of the PBAP service
+	 * @returns {String} The contact service state. Possible values are
+	 * qnx.bluetooth.pbap state constants, or null if the service state is not available
+	 */
+	getState: function() {
+   		var value = null,
+			success = function (data, response) {
+				value = data;
+			},
+			fail = function (data, response) {
+				throw data;
+			};
+
+		try {
+			window.cordova.exec(success, fail, _ID, 'getState', null);
+		} catch (e) {
+			console.error(e);
+		}
+
+		return value;
+	},
+
+	/**
+	 * Get the current status of the PBAP service
+	 * @returns {String} The contact service status. Possible values are
+	 * qnx.bluetooth.pbap status constants, or null if the service status is not available
+	 */
+	getStatus: function() {
+   		var value = null,
+			success = function (data, response) {
+				value = data;
+			},
+			fail = function (data, response) {
+				throw data;
+			};
+
+		try {
+			window.cordova.exec(success, fail, _ID, 'getStatus', null);
+		} catch (e) {
+			console.error(e);
+		}
+
+		return value;
+	},
+
+	/**
+	 * Force the PBAP phone book data to be refreshed from the device
+	 */
+	refresh: function() {
+		window.cordova.exec(null, null, _ID, 'refresh');
+	}
+};
\ No newline at end of file
diff --git a/plugin/com.qnx.bluetooth/plugin.xml b/plugin/com.qnx.bluetooth/plugin.xml
index 3ea5c09..9a97f82 100644
--- a/plugin/com.qnx.bluetooth/plugin.xml
+++ b/plugin/com.qnx.bluetooth/plugin.xml
@@ -25,6 +25,7 @@ for other information.
 
 	<platform name="blackberry10">
 		<source-file src="src/blackberry10/index.js" />
+		<source-file src="src/blackberry10/context.js" />
 		<source-file src="src/blackberry10/bluetooth.js" />
 		<config-file target="www/config.xml" parent="/widget">
 			<feature name="com.qnx.bluetooth" value="com.qnx.bluetooth" />
diff --git a/plugin/com.qnx.bluetooth/src/blackberry10/bluetooth.js b/plugin/com.qnx.bluetooth/src/blackberry10/bluetooth.js
index 32d300a..6f46f99 100644
--- a/plugin/com.qnx.bluetooth/src/blackberry10/bluetooth.js
+++ b/plugin/com.qnx.bluetooth/src/blackberry10/bluetooth.js
@@ -25,13 +25,52 @@ var _pps = qnx.webplatform.pps,
 	_pairedDevicesPPS,
 	_controlPPS,
 	_statusPPS,
+	_servicesPPS,
 
-	_pairedDevices = {};
+	_pairedDevices = {},
 
+	_serviceConnectedTrigger,
+	_serviceDisconnectedTrigger;
+
+/* TODO Please make sure that constants below are identical to ones in client.js*/
 /* TODO Please make sure that constants below are identical to ones in client.js*/
+/** To exchange Legacy pin (usually hardcoded) */
+var LEGACY_PIN = "LEGACY_PIN",
+	/** To allow remote device connect */
+	AUTHORIZE = "AUTHORIZE",
+	/** Request to display dialog to enter authorization passkey */
+	PASS_KEY = "PASS_KEY",
+	/** Request to display dialog to confirm displayed  passkey*/
+	ACCEPT_PASS_KEY = "ACCEPT_PASS_KEY",
+	/** Request to display dialog display passkey*/
+	DISPLAY_PASS_KEY = "DISPLAY_PASS_KEY",
+	/** Defines Handsfree Profile ID */
+	SERVICE_HFP = "0x111E",
+	/** Defines Message Access Profile ID */
+	SERVICE_MAP = "0x1134",
+	/** Defines Serial Port Profile ID */
+	SERVICE_SPP = "0x1101",
+	/** Defines Phonebook Access Profile ID */
+	SERVICE_PBAP = "0x1130",
+	/** Defines Personal Area Network ID */
+	SERVICE_PAN = "0x1115",
+	/** Defines Phonebook Access Profile ID */
+	SERVICE_AVRCP = "0x110B",
+	/** Defines All allowed Profiles ID for current device*/
+	SERVICE_ALL = "ALL";
+
+	/** Non-discoverable or connectable. */
+	DEVICE_NOT_ACCESSIBLE = 0;
+	/** General discoverable and connectable. */
+	DEVICE_GENERAL_ACCESSIBLE = 1;
+	/** Limited discoverable and connectable. */
+	DEVICE_LIMITED_ACCESSIBLE = 2;
+	/** Connectable but not discoverable. */
+	DEVICE_CONNECTABLE_ONLY = 3;
+	/** Discoverable but not connectable. */
+	DEVICE_DISCOVERABLE_ONLY = 4;
+
 
-/** Defines All allowed Profiles ID for current device*/
-var SERVICE_ALL = "ALL";
 
 
 /* TODO Please make sure that constants above are identical to ones in client.js*/
@@ -70,15 +109,75 @@ function onStatusPPSChange(event) {
 				// deleting device from local list of devices when it was deleted by pps-bluetooth from the list of paired devices
 				delete _pairedDevices[mac];
 				break;
+			/* Event indicated that one of the services is connected */
+			case "BTMGR_EVENT_SERVICE_CONNECTED":
+				if (_serviceConnectedTrigger && event.data.data2) {
+					var triggerEvent = {mac:mac, serviceid:event.data.data2};
+					_serviceConnectedTrigger(triggerEvent);
+				}
+				break;
+			/* Event indicated that all allowed services connected */
+			case "BTMGR_EVENT_CONNECT_ALL_SUCCESS":
+				if (_serviceConnectedTrigger && mac) {
+					var triggerEvent = {mac:mac, serviceid:SERVICE_ALL};
+					_serviceConnectedTrigger(triggerEvent);
+				}
+				break;
+			/* Event indicated that one of the services is disconnected */
+			case "BTMGR_EVENT_SERVICE_DISCONNECTED":
+				if (_serviceDisconnectedTrigger && event.data.data2) {
+					var triggerEvent = {mac:mac, serviceid:event.data.data2};
+					_serviceDisconnectedTrigger(triggerEvent);
+				}
+				break;
+			/* Event indicated that all allowed services disconnected */
+			case "BTMGR_EVENT_DISCONNECT_ALL_SUCCESS":
+				if (_serviceDisconnectedTrigger) {
+					var triggerEvent = {mac:mac, serviceid:SERVICE_ALL};
+					_serviceDisconnectedTrigger(triggerEvent);
+				}
+				break;
 		}
 	}
 }
 
+/**
+ * Event handler to process services object change event.
+ * I return snapshot of the whole status object when change detected
+ * */
+function onServicesPPSChange() {
+
+	var devices = {};
+	if(_servicesPPS && _servicesPPS.ppsObj) {
+		devices[SERVICE_HFP] = _servicesPPS.ppsObj['hfp'];
+		devices[SERVICE_SPP] = _servicesPPS.ppsObj['spp'];
+		devices[SERVICE_PBAP] = _servicesPPS.ppsObj['pbap'];
+		devices[SERVICE_MAP] = _servicesPPS.ppsObj['map'];
+		devices[SERVICE_PAN] = _servicesPPS.ppsObj['pan'];
+		devices[SERVICE_AVRCP] = _servicesPPS.ppsObj['avrcp'];
+	}
+	_serviceStateChanged(devices);
+}
 
 /**
  * Exports are the publicly accessible functions
  */
 module.exports = {
+	/**
+	 * Sets the trigger function to call when a service connected fired
+	 * @param trigger {Function} The trigger function to call when the event is fired
+	 */
+	setServiceConnectedTrigger:function (trigger) {
+		_serviceConnectedTrigger = trigger;
+	},
+
+	/**
+	 * Sets the trigger function to call when service disconnected fired
+	 * @param trigger {Function} The trigger function to call when the event is fired
+	 */
+	setServiceDisconnectedTrigger:function (trigger) {
+		_serviceDisconnectedTrigger = trigger;
+	},
 
 	/**
 	 * Initializes the extension,
@@ -103,6 +202,12 @@ module.exports = {
 		_statusPPS = _pps.createObject("/pps/services/bluetooth/status", _pps.PPSMode.DELTA);
 		_statusPPS.onNewData = onStatusPPSChange;
 		_statusPPS.open(_pps.FileMode.RDONLY);
+
+		/* Initialise PPS object which indicates what services currently connected and what is MAC of devices */
+		_servicesPPS = _pps.createObject("/pps/services/bluetooth/services", _pps.PPSMode.DELTA);
+		_servicesPPS.onNewData = onServicesPPSChange;
+		_servicesPPS.open(_pps.FileMode.RDONLY);
+
 	},
 
 	/**
@@ -138,4 +243,34 @@ module.exports = {
 	getPaired:function () {
 		return _pairedDevices;
 	},
+
+	/**
+	 * Gets a list of connected devices for bluetooth services.
+	 * @param service {String} (optional) The bluetooth service.
+	 */
+	getConnectedDevices: function(service) {
+		var devices = {};
+		if(_servicesPPS && _servicesPPS.ppsObj) {
+			if(!service || service == SERVICE_HFP || service == SERVICE_ALL) {
+				devices[SERVICE_HFP] = _servicesPPS.ppsObj['hfp'];
+			}
+			if(!service || service == SERVICE_SPP || service == SERVICE_ALL) {
+				devices[SERVICE_SPP] = _servicesPPS.ppsObj['spp'];
+			}
+			if(!service || service == SERVICE_PBAP || service == SERVICE_ALL) {
+				devices[SERVICE_PBAP] = _servicesPPS.ppsObj['pbap'];
+			}
+			if(!service || service == SERVICE_MAP || service == SERVICE_ALL) {
+				devices[SERVICE_MAP] = _servicesPPS.ppsObj['map'];
+			}
+			if(!service || service == SERVICE_PAN || service == SERVICE_ALL) {
+				devices[SERVICE_PAN] = _servicesPPS.ppsObj['pan'];
+			}
+			if(!service || service == SERVICE_AVRCP || service == SERVICE_ALL) {
+				devices[SERVICE_AVRCP] = _servicesPPS.ppsObj['avrcp'];
+			}
+		}
+		return devices;
+	},
+
 };
diff --git a/plugin/com.qnx.bluetooth/src/blackberry10/context.js b/plugin/com.qnx.bluetooth/src/blackberry10/context.js
new file mode 100644
index 0000000..542cf6f
--- /dev/null
+++ b/plugin/com.qnx.bluetooth/src/blackberry10/context.js
@@ -0,0 +1,64 @@
+/*
+ * Copyright 2013  QNX Software Systems Limited
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"). You
+ * may not reproduce, modify or distribute this software except in
+ * compliance with the License. You may obtain a copy of the License
+ * at: http://www.apache.org/licenses/LICENSE-2.0.
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTIES OF ANY KIND, either express or implied.
+ * This file may contain contributions from others, either as
+ * contributors under the License or as licensors under other terms.
+ * Please review this entire file for other proprietary rights or license
+ * notices, as well as the applicable QNX License Guide at
+ * http://www.qnx.com/legal/licensing/document_archive/current_matrix.pdf
+ * for other information.
+ */
+
+/**
+ * The event context for Bluetooth events
+ */
+
+var _bluetooth = require("./bluetooth");
+
+/**
+ * Exports are the publicly accessible functions
+ */
+module.exports = {
+	/**
+	 * Method called when the first listener is added for an event
+	 * @param event {String} The event name
+	 * @param trigger {Function} The trigger function to call when the event is fired
+	 */
+	addEventListener:function (event, trigger) {
+		if (event && trigger) {
+			switch (event) {
+				case "bluetoothserviceconnected":
+					_bluetooth.setServiceConnectedTrigger(trigger);
+					break;
+				case "bluetoothservicedisconnected":
+					_bluetooth.setServiceDisconnectedTrigger(trigger);
+					break;
+			}
+		}
+	},
+
+	/**
+	 * Method called when the last listener is removed for an event
+	 * @param event {String} The event name
+	 */
+	removeEventListener:function (event) {
+		if (event) {
+			switch (event) {
+				case "bluetoothserviceconnected":
+					_bluetooth.setServiceConnectedTrigger(null);
+					break;
+				case "bluetoothservicedisconnected":
+					_bluetooth.setServiceDisconnectedTrigger(null);
+					break;
+			}
+		}
+	}
+};
diff --git a/plugin/com.qnx.bluetooth/src/blackberry10/index.js b/plugin/com.qnx.bluetooth/src/blackberry10/index.js
index 496bc55..098a587 100644
--- a/plugin/com.qnx.bluetooth/src/blackberry10/index.js
+++ b/plugin/com.qnx.bluetooth/src/blackberry10/index.js
@@ -22,7 +22,34 @@
  */
 
 var _wwfix = require("../../lib/wwfix"),
-	_bluetooth = require("./bluetooth");
+	_bluetooth = require("./bluetooth"),
+	_actionMap = {
+		/**
+		 * @event
+		 * Triggered when the contact service state has changed.
+		 */
+		bluetoothserviceconnected: {
+			context: require("./context"),
+			event: "bluetoothserviceconnected",
+			triggerEvent: "bluetoothserviceconnected",
+			trigger: function (pluginResult, data) {
+				pluginResult.callbackOk(data, true);
+			} 
+		},
+		/**
+		 * @event
+		 * Triggered when the contact service status has changed.
+		 */
+		bluetoothservicedisconnected: {
+			context: require("./context"),
+			event: "bluetoothservicedisconnected",
+			triggerEvent: "bluetoothservicedisconnected",
+			trigger: function (pluginResult, data) {
+				pluginResult.callbackOk(data, true);
+			} 
+		}
+	},
+	_listeners = {};
 
 /**
  * Initializes the extension
@@ -41,6 +68,69 @@ init();
  */
 module.exports = {
 	/**
+	 * Turn on event dispatching for a specific event name
+	 * @param {Function} success Function to call if the operation is a success
+	 * @param {Function} fail Function to call if the operation fails
+	 * @param {Object} args The arguments supplied
+	 * @param {Object} env Environment variables
+	 */
+	startEvent: function (success, fail, args, env) {
+		var result = new PluginResult(args, env);
+		try {
+			var fixedArgs = _wwfix.parseArgs(args),
+			 	eventName = fixedArgs.eventName,
+				context = _actionMap[eventName].context,
+				systemEvent = _actionMap[eventName].event,
+				listener = _actionMap[eventName].trigger.bind(null, result);
+
+			if (!_listeners[eventName]) {
+				_listeners[eventName] = {};
+			}
+
+			if (_listeners[eventName][env.webview.id]) {
+				//TODO: Stop all listeners on plugin reset and renable this error
+				//result.error("Underlying listener for " + eventName + " already already running for webview " + env.webview.id);
+				context.removeEventListener(systemEvent, _listeners[eventName][env.webview.id]);
+			}
+
+			context.addEventListener(systemEvent, listener);
+			_listeners[eventName][env.webview.id] = listener;
+			result.noResult(true);
+ 		} catch (e) {
+			_eventResult.error("error in startEvent: " + JSON.stringify(e), false);
+		}
+   },
+
+	/**
+	 * Turn off event dispatching for a specific event name
+	 * @param {Function} success Function to call if the operation is a success
+	 * @param {Function} fail Function to call if the operation fails
+	 * @param {Object} args The arguments supplied
+	 * @param {Object} env Environment variables
+	 */
+	stopEvent: function (success, fail, args, env) {
+		var result = new PluginResult(args, env);
+		try {
+			var fixedArgs = _wwfix.parseArgs(args),
+			 	eventName = fixedArgs.eventName,
+				context = _actionMap[eventName].context,
+				systemEvent = _actionMap[eventName].event,
+				listener;
+
+		if (!_listeners || !_listeners[eventName] || !_listeners[eventName][env.webview.id]) {
+			result.error("Underlying listener for " + eventName + " never started for webview " + env.webview.id);
+		} else {
+			listener = _listeners[eventName][env.webview.id];
+			context.removeEventListener(systemEvent, listener);
+			delete _listeners[eventName][env.webview.id];
+			result.noResult(false);
+		}
+		} catch (e) {
+			_eventResult.error("error in stopEvent: " + JSON.stringify(e), false);
+		}
+	},
+
+	/**
 	 * Connects to specified service on device
 	 * @param success {Function} Function to call if the operation is a success
 	 * @param fail {Function} Function to call if the operation fails
@@ -52,7 +142,7 @@ module.exports = {
 	 * @param env {Object} Environment variables
 	 */
 	connectService:function (success, fail, args, env) {
-		var result = new PluginResult(args, env)
+		var result = new PluginResult(args, env);
 		try {
 			var fixedArgs = _wwfix.parseArgs(args);
 			var data = _bluetooth.connectService(fixedArgs.service, fixedArgs.mac);
@@ -81,6 +171,28 @@ module.exports = {
 		} catch (e) {
 			result.error(JSON.stringify(e), false);
 		}
-	}
+	},
+
+	/**
+	 * Gets a list of connected devices for bluetooth services.
+	 * @param success {Function} Function to call if the operation is a success
+	 * @param fail {Function} Function to call if the operation fails
+	 * @param args {Object} The arguments supplied. Available arguments for this call are:
+	 *	{
+	 *		*: {Mixed},	//the arguments for this function are dynamic and could be anything
+	 *		[...]
+	 *	}
+	 * @param env {Object} Environment variables
+	 */
+	getConnectedDevices:function (success, fail, args, env) {
+		var result = new PluginResult(args, env)
+		try {
+			args = _wwfix.parseArgs(args);
+			var data = _bluetooth.getConnectedDevices(args.service);
+			result.ok(data, false);
+		} catch (e) {
+			result.error(JSON.stringify(e), false);
+		}
+	},
 };
 
diff --git a/plugin/com.qnx.bluetooth/www/client.js b/plugin/com.qnx.bluetooth/www/client.js
index e638860..f9e8534 100644
--- a/plugin/com.qnx.bluetooth/www/client.js
+++ b/plugin/com.qnx.bluetooth/www/client.js
@@ -25,15 +25,70 @@
  */
 
 
-var _ID = "com.qnx.bluetooth";
+var _ID = "com.qnx.bluetooth",
+	_events = ["bluetoothserviceconnected", "bluetoothservicedisconnected"];
+
+
+_events.map(function (eventName) {
+	var channel = cordova.addDocumentEventHandler(eventName),
+		success = function (data) {
+			channel.fire(data);
+		},
+		fail = function (error) {
+			console.log("Error initializing " + eventName + " listener: ", error);
+		};
+
+	channel.onHasSubscribersChange = function () {
+		if (this.numHandlers === 1) {
+			window.cordova.exec(success, fail, _ID, "startEvent", {eventName: eventName});
+		} else if (this.numHandlers === 0) {
+			window.cordova.exec(null, null, _ID, "stopEvent", {eventName: eventName});
+		}
+	};
+});
+
 
 /*
  * Exports are the publicly accessible functions
  */
 module.exports = {
-
+	/* TODO Please make sure that constants below are identical to ones in bluetooth.js*/
+	/** To exchange legacy PIN (usually hardcoded) */
+	LEGACY_PIN:"LEGACY_PIN",
+	/** To allow remote device connect. */
+	AUTHORIZE:"AUTHORIZE",
+	/** Request to display dialog to enter authorization passkey */
+	PASS_KEY:"PASS_KEY",
+	/** Request to display dialog to confirm displayed  passkey*/
+	ACCEPT_PASS_KEY:"ACCEPT_PASS_KEY",
+	/** Request to display dialog display passkey*/
+	DISPLAY_PASS_KEY:"DISPLAY_PASS_KEY",
+	/** Defines Handsfree Profile ID */
+	SERVICE_HFP:"0x111E",
+	/** Defines Message Access Profile ID */
+	SERVICE_MAP:"0x1134",
+	/** Defines Serial Port Profile ID */
+	SERVICE_SPP:"0x1101",
+	/** Defines Phonebook Access Profile ID */
+	SERVICE_PBAP:"0x1130",
+	/** Defines Personal Area Network ID */
+	SERVICE_PAN : "0x1115",
+	/** Defines Advanced Audio Distribution Profile / Audio/Video Remote Control Profile ID */
+	SERVICE_AVRCP : "0x110B",
 	/** Defines all allowed Profile ID for current device*/
-	SERVICE_ALL: "ALL",
+	SERVICE_ALL:"ALL",
+
+	/** Not discoverable or connectable. */
+	DEVICE_NOT_ACCESSIBLE:0,
+	/** General discoverable and connectable. */
+	DEVICE_GENERAL_ACCESSIBLE:1,
+	/** Limited discoverable and connectable. */
+	DEVICE_LIMITED_ACCESSIBLE:2,
+	/** Connectable but not discoverable. */
+	DEVICE_CONNECTABLE_ONLY:3,
+	/** Discoverable but not connectable. */
+	DEVICE_DISCOVERABLE_ONLY:4,
+
 
 	/**
 	 * Connect to specified service on device with specified MAC address
@@ -59,9 +114,32 @@ module.exports = {
 
 		try {
 			window.cordova.exec(success, fail, _ID, 'getPaired', null);
-			return value;
 		} catch (e) {
 			console.error(e);
 		}
+		return value;
+	},
+
+	/**
+	 * Get a list of connected devices for Bluetooth services
+	 * @param {String} service [optional] The Bluetooth service (e.g. SERVICE_HFP)
+	 */
+	getConnectedDevices:function (service) {
+   		var value = null,
+   			args = (typeof service == "string") ? { service: service } : null ,
+			success = function (data, response) {
+				value = data;
+			},
+			fail = function (data, response) {
+				throw data;
+			};
+
+		try {
+			window.cordova.exec(success, fail, _ID, 'getConnectedDevices', args);
+		} catch (e) {
+			console.error(e);
+		}
+
+		return value;
 	},
 };
\ No newline at end of file
diff --git a/plugin/com.qnx.phone/plugin.xml b/plugin/com.qnx.phone/plugin.xml
new file mode 100644
index 0000000..b37919d
--- /dev/null
+++ b/plugin/com.qnx.phone/plugin.xml
@@ -0,0 +1,34 @@
+<!--
+Copyright 2013  QNX Software Systems Limited
+
+Licensed under the Apache License, Version 2.0 (the "License"). You
+may not reproduce, modify or distribute this software except in
+compliance with the License. You may obtain a copy of the License
+at: http://www.apache.org/licenses/LICENSE-2.0.
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" basis,
+WITHOUT WARRANTIES OF ANY KIND, either express or implied.
+This file may contain contributions from others, either as
+contributors under the License or as licensors under other terms.
+Please review this entire file for other proprietary rights or license
+notices, as well as the applicable QNX License Guide at
+http://www.qnx.com/legal/licensing/document_archive/current_matrix.pdf
+for other information.
+-->
+<plugin xmlns="http://www.phonegap.com/ns/plugins/1.0"
+	id="com.qnx.phone"
+	version="1.0.0">
+	<js-module src="www/client.js">
+		<clobbers target="qnx.phone" />
+	</js-module>
+
+	<platform name="blackberry10">
+		<source-file src="src/blackberry10/index.js" />
+		<source-file src="src/blackberry10/context.js" />
+		<source-file src="src/blackberry10/phone.js" />
+		<config-file target="www/config.xml" parent="/widget">
+			<feature name="com.qnx.phone" value="com.qnx.phone" />
+		</config-file>
+	</platform>
+</plugin>
diff --git a/plugin/com.qnx.phone/src/blackberry10/context.js b/plugin/com.qnx.phone/src/blackberry10/context.js
new file mode 100644
index 0000000..70a7158
--- /dev/null
+++ b/plugin/com.qnx.phone/src/blackberry10/context.js
@@ -0,0 +1,76 @@
+/*
+ * Copyright 2013  QNX Software Systems Limited
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"). You
+ * may not reproduce, modify or distribute this software except in
+ * compliance with the License. You may obtain a copy of the License
+ * at: http://www.apache.org/licenses/LICENSE-2.0.
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTIES OF ANY KIND, either express or implied.
+ * This file may contain contributions from others, either as
+ * contributors under the License or as licensors under other terms.
+ * Please review this entire file for other proprietary rights or license
+ * notices, as well as the applicable QNX License Guide at
+ * http://www.qnx.com/legal/licensing/document_archive/current_matrix.pdf
+ * for other information.
+ */
+
+/**
+ * The event context for Handsfree events
+ */
+
+var _phone = require("./phone");
+
+/**
+ * Exports are the publicly accessible functions
+ */
+module.exports = {
+	/**
+	 * Method called when the first listener is added for an event
+	 * @param event {String} The event name
+	 * @param trigger {Function} The trigger function to call when the event is fired
+	 */
+	addEventListener:function (event, trigger) {
+		if (event && trigger) {
+			switch (event) {
+				case "phoneready":
+					_phone.setPhoneReadyTrigger(trigger);
+					break;
+				case "phonedialing":
+					_phone.setPhoneDialingTrigger(trigger);
+					break;
+				case "phonecallactive":
+					_phone.setPhoneCallActiveTrigger(trigger);
+					break;
+				case "phoneincoming":
+					_phone.setPhoneIncomingTrigger(trigger);
+					break;
+			}
+		}
+	},
+
+	/**
+	 * Method called when the last listener is removed for an event
+	 * @param event {String} The event name
+	 */
+	removeEventListener:function (event) {
+		if (event) {
+			switch (event) {
+				case "phoneready":
+					_phone.setPhoneReadyTrigger(null);
+					break;
+				case "phonedialing":
+					_phone.setPhoneDialingTrigger(null);
+					break;
+				case "phonecallactive":
+					_phone.setPhoneCallActiveTrigger(null);
+					break;
+				case "phoneincoming":
+					_phone.setPhoneIncomingTrigger(null);
+					break;
+			}
+		}
+	}
+};
diff --git a/plugin/com.qnx.phone/src/blackberry10/index.js b/plugin/com.qnx.phone/src/blackberry10/index.js
new file mode 100644
index 0000000..472d796
--- /dev/null
+++ b/plugin/com.qnx.phone/src/blackberry10/index.js
@@ -0,0 +1,241 @@
+/*
+ * Copyright 2013  QNX Software Systems Limited
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"). You
+ * may not reproduce, modify or distribute this software except in
+ * compliance with the License. You may obtain a copy of the License
+ * at: http://www.apache.org/licenses/LICENSE-2.0.
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTIES OF ANY KIND, either express or implied.
+ * This file may contain contributions from others, either as
+ * contributors under the License or as licensors under other terms.
+ * Please review this entire file for other proprietary rights or license
+ * notices, as well as the applicable QNX License Guide at
+ * http://www.qnx.com/legal/licensing/document_archive/current_matrix.pdf
+ * for other information.
+ */
+
+/**
+ * Defines Phone operations
+ */
+
+var _wwfix = require("../../lib/wwfix"),
+	_phone = require("./phone"),
+	_appEvents = require("./../../lib/events/applicationEvents"),
+	_actionMap = {
+		/**
+		 * @event
+		 * Triggered when ready to accept commands (HFP connected and not busy)
+		 */
+		phoneready:{
+			context:require("./context"),
+			event:"phoneready",
+			triggerEvent: "phoneready",
+			trigger: function (pluginResult, data) {
+				pluginResult.callbackOk(data, true);
+			} 
+		},
+		/**
+		 * @event
+		 * Triggered when phone is dialing out
+		 */
+		phonedialing:{
+			context:require("./context"),
+			event:"phonedialing",
+			triggerEvent: "phonedialing",
+			trigger: function (pluginResult, data) {
+				pluginResult.callbackOk(data, true);
+			} 
+		},
+		/**
+		 * @event
+		 * Triggered when phone has active call
+		 */
+		phonecallactive:{
+			context:require("./context"),
+			event:"phonecallactive",
+			triggerEvent: "phonecallactive",
+			trigger: function (pluginResult, data) {
+				pluginResult.callbackOk(data, true);
+			} 
+		},
+		/**
+		 * @event
+		 * Triggered when there is incoming call
+		 */
+		phoneincoming:{
+			context:require("./context"),
+			event:"phoneincoming",
+			triggerEvent: "phoneincoming",
+			trigger: function (pluginResult, data) {
+				pluginResult.callbackOk(data, true);
+			} 
+		}
+	},
+	_listeners = {};
+
+/**
+ * Initializes the extension 
+ */
+function init() {
+	try {
+		_phone.init();
+	} catch (ex) {
+		console.error('Error in webworks ext: phone/index.js:init():', ex);
+	}
+}
+init();
+
+/**
+ * Exports are the publicly accessible functions
+ */
+module.exports = {
+
+	/**
+	 * Turn on event dispatching for a specific event name
+	 * @param {Function} success Function to call if the operation is a success
+	 * @param {Function} fail Function to call if the operation fails
+	 * @param {Object} args The arguments supplied
+	 * @param {Object} env Environment variables
+	 */
+	startEvent: function (success, fail, args, env) {
+		var result = new PluginResult(args, env);
+		try {
+			var fixedArgs = _wwfix.parseArgs(args),
+			 	eventName = fixedArgs.eventName,
+				context = _actionMap[eventName].context,
+				systemEvent = _actionMap[eventName].event,
+				listener = _actionMap[eventName].trigger.bind(null, result);
+
+			if (!_listeners[eventName]) {
+				_listeners[eventName] = {};
+			}
+
+			if (_listeners[eventName][env.webview.id]) {
+				//TODO: Stop all listeners on plugin reset and renable this error
+				//result.error("Underlying listener for " + eventName + " already already running for webview " + env.webview.id);
+				context.removeEventListener(systemEvent, _listeners[eventName][env.webview.id]);
+			}
+
+			context.addEventListener(systemEvent, listener);
+			_listeners[eventName][env.webview.id] = listener;
+			result.noResult(true);
+ 		} catch (e) {
+			_eventResult.error("error in startEvent: " + JSON.stringify(e), false);
+		}
+   },
+
+	/**
+	 * Turn off event dispatching for a specific event name
+	 * @param {Function} success Function to call if the operation is a success
+	 * @param {Function} fail Function to call if the operation fails
+	 * @param {Object} args The arguments supplied
+	 * @param {Object} env Environment variables
+	 */
+	stopEvent: function (success, fail, args, env) {
+		var result = new PluginResult(args, env);
+		try {
+			var fixedArgs = _wwfix.parseArgs(args),
+			 	eventName = fixedArgs.eventName,
+				context = _actionMap[eventName].context,
+				systemEvent = _actionMap[eventName].event,
+				listener;
+
+		if (!_listeners || !_listeners[eventName] || !_listeners[eventName][env.webview.id]) {
+			result.error("Underlying listener for " + eventName + " never started for webview " + env.webview.id);
+		} else {
+			listener = _listeners[eventName][env.webview.id];
+			context.removeEventListener(systemEvent, listener);
+			delete _listeners[eventName][env.webview.id];
+			result.noResult(false);
+		}
+		} catch (e) {
+			_eventResult.error("error in stopEvent: " + JSON.stringify(e), false);
+		}
+	},
+
+	/**
+	 * Dial a number
+	 * @param success {Function} Function to call if the operation is a success
+	 * @param fail {Function} Function to call if the operation fails
+	 * @param args {Object} The arguments supplied. Available arguments for this call are: N/A
+	 * @param env {Object} Environment variables
+	 */
+	dial: function(success, fail, args, env) {
+		var result = new PluginResult(args, env);
+		try {
+			var fixedArgs = _wwfix.parseArgs(args);
+			var data = _phone.dial(fixedArgs.number);
+			result.ok(data, false);
+		} catch (e) {
+			result.error(JSON.stringify(e), false);
+		}
+	},
+	/**
+	 * Accept incoming call
+	 * @param success {Function} Function to call if the operation is a success
+	 * @param fail {Function} Function to call if the operation fails
+	 * @param args {Object} The arguments supplied. Available arguments for this call are: N/A
+	 * @param env {Object} Environment variables
+	 */
+	accept: function(success, fail, args, env) {
+		var result = new PluginResult(args, env);
+		try {
+			_phone.accept();
+			result.ok(undefined, false);
+		} catch (e) {
+			result.error(JSON.stringify(e), false);
+		}
+	},
+	/**
+	 * Hangs up current active call
+	 * @param success {Function} Function to call if the operation is a success
+	 * @param fail {Function} Function to call if the operation fails
+	 * @param args {Object} The arguments supplied. Available arguments for this call are: N/A
+	 * @param env {Object} Environment variables
+	 */
+	hangup: function(success, fail, args, env) {
+		var result = new PluginResult(args, env);
+		try {
+			_phone.hangup();
+			result.ok(undefined, false);
+		} catch (e) {
+			result.error(JSON.stringify(e), false);
+		}
+	},
+	/**
+	 * Redials last called number
+	 * @param success {Function} Function to call if the operation is a success
+	 * @param fail {Function} Function to call if the operation fails
+	 * @param args {Object} The arguments supplied. Available arguments for this call are: N/A
+	 * @param env {Object} Environment variables
+	 */
+	redial: function(success, fail, args, env) {
+		var result = new PluginResult(args, env);
+		try {
+			_phone.redial();
+			result.ok(undefined, false);
+		} catch (e) {
+			result.error(JSON.stringify(e), false);
+		}
+	},
+	/**
+	 * Return current state of phone
+	 * @param success {Function} Function to call if the operation is a success
+	 * @param fail {Function} Function to call if the operation fails
+	 * @param args {Object} The arguments supplied. Available arguments for this call are: N/A
+	 * @param env {Object} Environment variables
+	 */
+	getState: function(success, fail, args, env) {
+		var result = new PluginResult(args, env);
+		try {
+			var data = _phone.getState();
+			result.ok(data, false);
+		} catch (e) {
+			result.error(JSON.stringify(e), false);
+		}
+	}
+};
+
diff --git a/plugin/com.qnx.phone/src/blackberry10/phone.js b/plugin/com.qnx.phone/src/blackberry10/phone.js
new file mode 100644
index 0000000..be131b3
--- /dev/null
+++ b/plugin/com.qnx.phone/src/blackberry10/phone.js
@@ -0,0 +1,218 @@
+/*
+ * Copyright 2013  QNX Software Systems Limited
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"). You
+ * may not reproduce, modify or distribute this software except in
+ * compliance with the License. You may obtain a copy of the License
+ * at: http://www.apache.org/licenses/LICENSE-2.0.
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTIES OF ANY KIND, either express or implied.
+ * This file may contain contributions from others, either as
+ * contributors under the License or as licensors under other terms.
+ * Please review this entire file for other proprietary rights or license
+ * notices, as well as the applicable QNX License Guide at
+ * http://www.qnx.com/legal/licensing/document_archive/current_matrix.pdf
+ * for other information.
+ */
+
+/**
+ * The abstraction layer for HFP functionality,
+ * at the moment this is only one default implementation
+ */
+
+var _pps = qnx.webplatform.pps,
+	_hfpControlPPS,
+	_phoneReadyTrigger,
+	_phoneDialingTrigger,
+	_phoneIncomingTrigger,
+	_phoneCallActiveTrigger;
+
+var lastNumber = null;
+var callId = null;
+
+/**
+ * phone status, indicates that Handsfree is up and running but not connected to any particular device
+ * */
+var HFP_INITIALIZED = "HFP_INITIALIZED";
+/**
+ * Handsfree status, indicates that Handsfree is successfully connected to the device
+ * */
+var HFP_CONNECTED_IDLE = "HFP_CONNECTED_IDLE";
+/**
+ * Handsfree status, indicates that Handsfree is dialing out
+ * */
+var HFP_CALL_OUTGOING_DIALING = "HFP_CALL_OUTGOING_DIALING";
+/**
+ * phone status, indicates that there is active phone call at the moment
+ * */
+var HFP_CALL_ACTIVE = "HFP_CALL_ACTIVE";
+/**
+ * Handsfree status, indicates that there is incoming call
+ * */
+var HFP_CALL_INCOMING = "HFP_CALL_INCOMING";
+
+/**
+ * Defines identifier for HFP service
+ * */
+var SERVICE_HFP = "SERVICE_HFP";
+
+/**
+ * Exports are the publicly accessible functions
+ */
+module.exports = {
+	/**
+	 * Initializes the extension
+	 */
+	init:function () {
+		//readerPPS
+		_hfpControlPPS = _pps.createObject("/pps/services/handsfree/control", _pps.PPSMode.DELTA);
+
+		try{
+			_hfpControlPPS.open(_pps.FileMode.WRONLY);
+		} catch (e) {
+			throw new Error("qnx.phone::init [phone.js] PPS object /pps/services/handsfree/status cannot be opened")
+		}
+
+		_hfpStatusPPS = _pps.createObject("/pps/services/handsfree/status", _pps.PPSMode.DELTA);
+		_hfpStatusPPS.onNewData = function (event) {
+			if (event && event.data && event.data.cmd_status) {
+				var cmd_status = event.data.cmd_status;
+				// TODO Add code to process cmd_status, will fire error event with appropriate message (require extra HFP backend works)
+			}
+
+			if (event && event.data && event.data.state) {
+				var state = event.data.state;
+
+				switch (state) {
+					case HFP_CONNECTED_IDLE:
+						if (_phoneReadyTrigger) {
+							_phoneReadyTrigger({service:SERVICE_HFP});
+						}
+						break;
+					case HFP_CALL_OUTGOING_DIALING:
+						// FIXME: The state_param event property should ALWAYS have the phone number for this event
+						callId = event.data.state_param || callId;
+						if (_phoneDialingTrigger) {
+							_phoneDialingTrigger({service:SERVICE_HFP, callId:callId });
+						}
+						break;
+					case  HFP_CALL_ACTIVE:
+						// FIXME: The state_param event property should ALWAYS have the phone number for this event
+						callId = event.data.state_param || callId;
+						if (_phoneCallActiveTrigger) {
+							// specifying service and callId, callId will be populated at this moment
+							_phoneCallActiveTrigger({service:SERVICE_HFP, callId:callId });
+						}
+						break;
+					case HFP_CALL_INCOMING:
+						// FIXME: The state_param event property should ALWAYS have the phone number for this event
+						callId = event.data.state_param || callId;
+						if (_phoneIncomingTrigger && callId) {
+							_phoneIncomingTrigger({service:SERVICE_HFP, callId:callId })
+						}
+						break;
+				}
+			}
+		};
+		try{
+			_hfpStatusPPS.open(_pps.FileMode.RDONLY);
+		} catch (e) {
+			throw new Error("qnx.phone::init [phone.js] PPS object /pps/services/handsfree/status cannot be opened.")
+		}
+
+	},
+
+	/**
+	 * @param trigger {Function} The trigger function to call when the event is fired
+	 */
+	setPhoneReadyTrigger:function (trigger) {
+		_phoneReadyTrigger = trigger;
+	},
+	/**
+	 * @param trigger {Function} The trigger function to call when the event is fired
+	 */
+	setPhoneDialingTrigger:function (trigger) {
+		_phoneDialingTrigger = trigger;
+	},
+	/**
+	 * @param trigger {Function} The trigger function to call when the event is fired
+	 */
+	setPhoneIncomingTrigger:function (trigger) {
+		_phoneIncomingTrigger = trigger;
+	},
+	/**
+	 * @param trigger {Function} The trigger function to call when the event is fired
+	 */
+	setPhoneCallActiveTrigger:function (trigger) {
+		_phoneCallActiveTrigger = trigger;
+	},
+
+	/**
+	 * Dial a number
+	 * @param {String} Number to dial
+	 */
+	dial:function (number) {
+		if(number) {
+			// saving outgoing call phone number to be able to redial later
+			lastNumber = number;
+			// saving outgoing call phone number as callid
+			callId = number;
+			if (_hfpStatusPPS.data.status.state == HFP_CONNECTED_IDLE) {
+				_hfpControlPPS.write({
+					"command":"HFP_CALL",
+					"cmd_data":number
+				});
+			}
+		}
+	},
+
+	/**
+	 * Accept incoming call
+	 */
+	accept:function () {
+		if (_hfpStatusPPS.data.status.state == HFP_CALL_INCOMING) {
+			_hfpControlPPS.write({
+				"command":"HFP_ACCEPT"
+			})
+		}
+	},
+
+	/**
+	 * Hangs up current active call
+	 * */
+	hangup:function () {
+		if (_hfpStatusPPS.data.status.state != HFP_CONNECTED_IDLE) {
+			_hfpControlPPS.write({
+				"command":"HFP_HANGUP"
+			});
+		}
+	},
+
+	/**
+	 * Redials last called number
+	 * */
+	redial:function () {
+		if (lastNumber) {
+			this.dial(lastNumber);
+		}
+	},
+
+	/**
+	 * Return current state of the phone
+	 * We will translate HFP statuses to generic Phone statuses
+	 * @returns {String} current state of the phone
+	 * */
+	getState:function () {
+		var state = _hfpStatusPPS.data.status.state;
+		var result = "";
+		switch(state) {
+			case HFP_CONNECTED_IDLE: result = "PHONE_IDLE"; break;
+			case HFP_CALL_ACTIVE: result = "CALL_ACTIVE"; break;
+			case HFP_CALL_INCOMING: result = "CALL_INCOMING"; break;
+			default: result = "PHONE_NOT_READY"; break;
+		}
+		return result;
+	}
+};
\ No newline at end of file
diff --git a/plugin/com.qnx.phone/www/client.js b/plugin/com.qnx.phone/www/client.js
new file mode 100644
index 0000000..6a06447
--- /dev/null
+++ b/plugin/com.qnx.phone/www/client.js
@@ -0,0 +1,189 @@
+/*
+ * Copyright 2013  QNX Software Systems Limited
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"). You
+ * may not reproduce, modify or distribute this software except in
+ * compliance with the License. You may obtain a copy of the License
+ * at: http://www.apache.org/licenses/LICENSE-2.0.
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTIES OF ANY KIND, either express or implied.
+ * This file may contain contributions from others, either as
+ * contributors under the License or as licensors under other terms.
+ * Please review this entire file for other proprietary rights or license
+ * notices, as well as the applicable QNX License Guide at
+ * http://www.qnx.com/legal/licensing/document_archive/current_matrix.pdf
+ * for other information.
+ */
+
+/**
+ * Provide the functionality of a phone
+ *
+ * <h3>Events</h3>
+ * <dl><dt><h4>phoneready</h4></dt>
+ * <dd><p>Triggered when phone is idle (no incoming, outgoing, active calls) and ready to accept commands</p>
+ * <h5>callback parameter event</h5>
+ * <p>{Object}</p>
+ * <h5>Example</h5>
+ *<pre><code>{
+ *      service: {String}       // identifies the phone service
+ *}</code></pre></dd></dl>
+ *
+ * <h4>phonecallactive</h4>
+ * <p>Triggered when active phone call (recipient accepted the outgoing call or incoming call accepted locally)</p>
+ * <h5>callback parameter event</h5> 
+ * <p>{Object}</p>
+ * <h5>Example</h5>
+ *<pre><code>{
+ *      service: {String}		// identifies the phone service
+ *      callId: {String}		// incoming call phone number in case of Handsfree, can be BBID etc
+ *}</code></pre></dd></dl>
+ * 
+ * <h4>phoneincoming</h4>
+ * <p>Triggered when there is incoming call, phone is ringing</p>
+ * <h5>callback parameter event</h5>
+ * <p>{Object}</p>
+ * <h5>Example</h5>
+ * <pre><code>{
+ *      service: {String}	// identifies the phone service
+ *      callId: {String}	// incoming call phone number in case of Handsfree, can be BBID etc
+ *}</code></pre></dd></dl>
+ *
+ * @module qnx.phone
+ * @static
+ */
+
+
+ /*
+  * TODO Add more granularity to phone events we need to be 
+  * able handle dialing, ringing, on hold, etc as well.
+  * TODO currently funnels everything via Handfsree service by default, 
+  * make implementation more generic
+  */
+
+var _ID = "com.qnx.phone",
+	_events = ["phoneready", "phonedialing", "phonecallactive", "phoneincoming"];
+
+_events.map(function (eventName) {
+	var channel = cordova.addDocumentEventHandler(eventName),
+		success = function (data) {
+			channel.fire(data);
+		},
+		fail = function (error) {
+			console.log("Error initializing " + eventName + " listener: ", error);
+		};
+
+	channel.onHasSubscribersChange = function () {
+		if (this.numHandlers === 1) {
+			window.cordova.exec(success, fail, _ID, "startEvent", {eventName: eventName});
+		} else if (this.numHandlers === 0) {
+			window.cordova.exec(null, null, _ID, "stopEvent", {eventName: eventName});
+		}
+	};
+});
+
+
+/*
+ * Exports are the publicly accessible functions
+ */
+module.exports = {	
+	/**
+	 * Defines identifier for HFP service
+	 * */
+	SERVICE_HFP: "SERVICE_HFP",
+
+	/**
+	 * 
+	 * Dial a number
+	 * @param {String} number Number to dial
+	 * @param {String} service [optional] Identifier of the phone service; 
+	 * if no parameter specified, function call will be routed to default, currently Handsfree, service 
+	 * TODO Currently service is not in use
+	 */
+	dial: function (number, service) {
+		window.cordova.exec(null, null, _ID, 'dial', { number: number });
+	},
+	/**
+	 * Accept incoming call
+	 * @param {String} callId ID to identify a call
+	 * TODO Currently callId is not in use, because with existing implementation of Handsfree we can have only one active call
+	 * @param {String} service [optional] Identifier of the phone service; if no parameter specified, 
+	 * function call will be routed to default, currently Handsfree, service 
+	 * TODO Currently service is not in use
+	 */
+	accept: function (callId, service) {
+	    window.cordova.exec(null, null, _ID, 'accept');
+	},
+	/**
+	 * Hang up current active call
+	 * @param {String} callId ID to identify a call
+	 * TODO Currently callId is not in use, because with existing implementation of Handsfree we can have only one active call
+	 * @param {String} service [optional]Identifier of the phone service, if no parameter specified, function call will be routed to default, currently Handsfree, service 
+	 * TODO Currently service is not in use
+	 * */
+	hangup: function (callId, service) {
+	    window.cordova.exec(null, null, _ID, 'hangup');
+	},
+	/**
+	 * Redial last called number
+	 * @param {String} service [optional] Identifier of the phone service; if no parameter specified, function call will be routed to default, currently Handsfree, service 
+	 * TODO Currently service is not in use
+	 * */
+	redial: function (service) {
+	    window.cordova.exec(null, null, _ID, 'redial');
+	},
+	/**
+	 * Put a call on hold
+	 * @param {String} callId ID to identify a call
+	 * TODO Currently callId is not in use, because with existing implementation of Handsfree we can have only one active call
+	 * @param {Boolean} value True to put current call on hold, false to release current call from hold
+	 * @param {String} service [optional] Identifier of the phone service; if no parameter specified, function call will be routed to default, currently Handsfree, service 
+	 * TODO Currently service is not in use
+	 * */
+	hold: function (callId, value, service) {
+		//TODO Implement this function and add appropriate events
+	},
+	/**
+	 * Mute audio input for incoming phone call (mute mic)
+	 * @param {String} callId ID to identify a call
+	 * TODO Currently callId is not in use, because with existing implementation of Handsfree we can have only one active call
+	 * @param {Boolean} value True to mute, false to unmute
+	 * @param {String} service [optional] Identifier of the phone service; if no parameter specified, function call will be routed to default, currently Handsfree, service 
+	 * TODO Currently service is not in use
+	 * */
+	mute: function (callId, value, service) {
+		//TODO Implement this function and add appropriate events
+	},
+	/**
+	 * Return the current state of the phone
+	 * @param {String} service [optional] Identifier of the phone service; if no parameter specified, function call will be routed to default, currently Handsfree, service 
+	 * TODO Currently service is not in use
+	 * @returns {String} Current state of the phone
+	 * */
+	getState: function (service) {
+   		var value = null,
+			success = function (data, response) {
+				value = data;
+			},
+			fail = function (data, response) {
+				throw data;
+			};
+
+		try {
+			window.cordova.exec(success, fail, _ID, 'getState', null);
+		} catch (e) {
+			console.error(e);
+		}
+		return value;
+	},
+	/**
+	 * Call this method to return the list of active calls
+	 * @param {String} service Identifier of the phone service, if no parameter specified function call will be routed to default, currently Handsfree, service [optional]
+	 * TODO Currently service is not in use
+	 * @return {Object} List of active calls
+	 * */
+	getActiveCalls: function (service) {
+		//TODO Implement this function
+	}
+};
\ No newline at end of file
-- 
1.7.10.msysgit.1

