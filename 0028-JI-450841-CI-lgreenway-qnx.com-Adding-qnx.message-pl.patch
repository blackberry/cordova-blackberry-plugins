From de7366c85577c5a790256ff565e736700d078269 Mon Sep 17 00:00:00 2001
From: Marc Lapierre <marc@eternallabs.com>
Date: Thu, 5 Sep 2013 14:35:21 -0400
Subject: [PATCH 28/61] JI:450841 CI:lgreenway@qnx.com Adding qnx.message
 plugin (draft)

---
 plugin/com.qnx.message/plugin.xml                  |   37 ++
 plugin/com.qnx.message/src/blackberry10/context.js |   88 +++
 plugin/com.qnx.message/src/blackberry10/index.js   |  347 ++++++++++
 plugin/com.qnx.message/src/blackberry10/message.js |  673 ++++++++++++++++++++
 .../src/blackberry10/servicenotification.js        |   43 ++
 .../src/blackberry10/servicestate.js               |   30 +
 .../src/blackberry10/servicestatus.js              |   30 +
 plugin/com.qnx.message/www/client.js               |  453 +++++++++++++
 8 files changed, 1701 insertions(+)
 create mode 100644 plugin/com.qnx.message/plugin.xml
 create mode 100644 plugin/com.qnx.message/src/blackberry10/context.js
 create mode 100644 plugin/com.qnx.message/src/blackberry10/index.js
 create mode 100644 plugin/com.qnx.message/src/blackberry10/message.js
 create mode 100644 plugin/com.qnx.message/src/blackberry10/servicenotification.js
 create mode 100644 plugin/com.qnx.message/src/blackberry10/servicestate.js
 create mode 100644 plugin/com.qnx.message/src/blackberry10/servicestatus.js
 create mode 100644 plugin/com.qnx.message/www/client.js

diff --git a/plugin/com.qnx.message/plugin.xml b/plugin/com.qnx.message/plugin.xml
new file mode 100644
index 0000000..25907f8
--- /dev/null
+++ b/plugin/com.qnx.message/plugin.xml
@@ -0,0 +1,37 @@
+<!--
+Copyright 2013  QNX Software Systems Limited
+
+Licensed under the Apache License, Version 2.0 (the "License"). You
+may not reproduce, modify or distribute this software except in
+compliance with the License. You may obtain a copy of the License
+at: http://www.apache.org/licenses/LICENSE-2.0.
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" basis,
+WITHOUT WARRANTIES OF ANY KIND, either express or implied.
+This file may contain contributions from others, either as
+contributors under the License or as licensors under other terms.
+Please review this entire file for other proprietary rights or license
+notices, as well as the applicable QNX License Guide at
+http://www.qnx.com/legal/licensing/document_archive/current_matrix.pdf
+for other information.
+-->
+<plugin xmlns="http://www.phonegap.com/ns/plugins/1.0"
+	id="com.qnx.message"
+	version="1.0.0">
+	<js-module src="www/client.js">
+		<clobbers target="qnx.message" />
+	</js-module>
+
+	<platform name="blackberry10">
+		<source-file src="src/blackberry10/index.js" />
+		<source-file src="src/blackberry10/context.js" />
+		<source-file src="src/blackberry10/message.js" />
+		<source-file src="src/blackberry10/servicenotification.js" />
+		<source-file src="src/blackberry10/servicestate.js" />
+		<source-file src="src/blackberry10/servicestatus.js" />
+		<config-file target="www/config.xml" parent="/widget">
+			<feature name="com.qnx.message" value="com.qnx.message" />
+		</config-file>
+	</platform>
+</plugin>
diff --git a/plugin/com.qnx.message/src/blackberry10/context.js b/plugin/com.qnx.message/src/blackberry10/context.js
new file mode 100644
index 0000000..a0961c4
--- /dev/null
+++ b/plugin/com.qnx.message/src/blackberry10/context.js
@@ -0,0 +1,88 @@
+/*
+ * Copyright 2013  QNX Software Systems Limited
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"). You
+ * may not reproduce, modify or distribute this software except in
+ * compliance with the License. You may obtain a copy of the License
+ * at: http://www.apache.org/licenses/LICENSE-2.0.
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTIES OF ANY KIND, either express or implied.
+ * This file may contain contributions from others, either as
+ * contributors under the License or as licensors under other terms.
+ * Please review this entire file for other proprietary rights or license
+ * notices, as well as the applicable QNX License Guide at
+ * http://www.qnx.com/legal/licensing/document_archive/current_matrix.pdf
+ * for other information.
+ */
+
+/**
+ * The event context for message service events.
+ */
+
+var _message = require("./message");
+
+/**
+ * Exports are the publicly accessible functions
+ */
+module.exports = {
+	/**
+	 * Method called when the first listener is added for an event
+	 * @param event {String} The event name
+	 * @param trigger {Function} The trigger function to call when the event is fired
+	 */
+	addEventListener: function (event, trigger) {
+		if (event && trigger) {
+			switch (event) {
+				case "messageservicestatechange":
+					_message.setStateChangedTrigger(trigger);
+					break;
+				case "messageservicefindresult":
+					_message.setFindResultTrigger(trigger);
+					break;
+				case "messageservicefindfail":
+					_message.setFindFailTrigger(trigger);
+					break;
+				case "messageservicemessageresult":
+					_message.setMessageResultTrigger(trigger);
+					break;
+				case "messageservicemessagefail":
+					_message.setMessageFailTrigger(trigger);
+					break;
+				case "messageservicenotification":
+					_message.setNotificationTrigger(trigger);
+					break;
+			}
+		}
+	},
+
+	/**
+	 * Method called when the last listener is removed for an event
+	 * @param event {String} The event name
+	 */
+	removeEventListener: function (event) {
+		if (event) {
+			switch (event) {
+				case "messageservicestatechange":
+					_message.setStateChangedTrigger(null);
+					break;
+				case "messageservicefindresult":
+					_message.setFindResultTrigger(null);
+					break;
+				case "messageservicefindfail":
+					_message.setFindFailTrigger(null);
+					break;
+				case "messageservicemessageresult":
+					_message.setMessageResultTrigger(null);
+					break;
+				case "messageservicemessagefail":
+					_message.setMessageFailTrigger(null);
+					break;
+				case "messageservicenotification":
+					_message.setNotificationTrigger(null);
+					break;
+			}
+		}
+	}
+};
diff --git a/plugin/com.qnx.message/src/blackberry10/index.js b/plugin/com.qnx.message/src/blackberry10/index.js
new file mode 100644
index 0000000..3c5d2e5
--- /dev/null
+++ b/plugin/com.qnx.message/src/blackberry10/index.js
@@ -0,0 +1,347 @@
+/*
+ * Copyright 2013  QNX Software Systems Limited
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"). You
+ * may not reproduce, modify or distribute this software except in
+ * compliance with the License. You may obtain a copy of the License
+ * at: http://www.apache.org/licenses/LICENSE-2.0.
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTIES OF ANY KIND, either express or implied.
+ * This file may contain contributions from others, either as
+ * contributors under the License or as licensors under other terms.
+ * Please review this entire file for other proprietary rights or license
+ * notices, as well as the applicable QNX License Guide at
+ * http://www.qnx.com/legal/licensing/document_archive/current_matrix.pdf
+ * for other information.
+ */
+
+/**
+ * Allows access to device contact PIM storage.
+ */
+var _wwfix = require("../../lib/wwfix"),
+	_message = require("./message"),
+	_appEvents = require("./../../lib/events/applicationEvents"),
+	_actionMap = {
+		/**
+		 * @event
+		 * Triggered when the messages service state changes
+		 */
+		messageservicestatechange:{
+			context:require("./context"),
+			event:"messageservicestatechange",
+			triggerEvent: "messageservicestatechange",
+			trigger: function (pluginResult, data) {
+				pluginResult.callbackOk(data, true);
+			} 
+		},
+		/**
+		 * @event
+		 * Triggered when there list of messages available
+		 */
+		messageservicefindresult:{
+			context: require("./context"),
+			event: "messageservicefindresult",
+			triggerEvent: "messageservicefindresult",
+			trigger: function (pluginResult, data) {
+				pluginResult.callbackOk(data, true);
+			} 
+		},
+		/**
+		 * @event
+		 * Triggered when there request for list of messages failed
+		 */
+		messageservicefindfail:{
+			context:require("./context"),
+			event:"messageservicefindfail",
+			triggerEvent: "messageservicefindfail",
+			trigger: function (pluginResult, data) {
+				pluginResult.callbackOk(data, true);
+			} 
+		},
+		/**
+		 * @event
+		 * Triggered when there full messages available
+		 */
+		messageservicemessageresult:{
+			context:require("./context"),
+			event:"messageservicemessageresult",
+			triggerEvent: "messageservicemessageresult",
+			trigger: function (pluginResult, data) {
+				pluginResult.callbackOk(data, true);
+			} 
+		},
+		/**
+		 * @event
+		 * Triggered when request of full messages failed
+		 */
+		messageservicemessagefail:{
+			context:require("./context"),
+			event:"messageservicemessagefail",
+			triggerEvent: "messageservicemessagefail",
+			trigger: function (pluginResult, data) {
+				pluginResult.callbackOk(data, true);
+			} 
+		},
+		/**
+		 * @event
+		 * Triggered when there is a notification from service
+		 */
+		messageservicenotification:{
+			context:require("./context"),
+			event:"messageservicenotification",
+			triggerEvent: "messageservicenotification",
+			trigger: function (pluginResult, data) {
+				pluginResult.callbackOk(data, true);
+			} 
+		}
+	},
+	_listeners = {};
+
+/**
+ * Initializes the extension
+ */
+function init() {
+	try {
+		_message.init();
+	} catch (ex) {
+		console.error('Error in webworks ext: message/index.js:init():', ex);
+	}
+}
+init();
+
+/**
+ * Exports are the publicly accessible functions
+ */
+module.exports = {
+
+	/**
+	 * Turn on event dispatching for a specific event name
+	 * @param {Function} success Function to call if the operation is a success
+	 * @param {Function} fail Function to call if the operation fails
+	 * @param {Object} args The arguments supplied
+	 * @param {Object} env Environment variables
+	 */
+	startEvent: function (success, fail, args, env) {
+		var result = new PluginResult(args, env);
+		try {
+			var fixedArgs = _wwfix.parseArgs(args),
+			 	eventName = fixedArgs.eventName,
+				context = _actionMap[eventName].context,
+				systemEvent = _actionMap[eventName].event,
+				listener = _actionMap[eventName].trigger.bind(null, result);
+
+			if (!_listeners[eventName]) {
+				_listeners[eventName] = {};
+			}
+
+			if (_listeners[eventName][env.webview.id]) {
+				//TODO: Stop all listeners on plugin reset and renable this error
+				//result.error("Underlying listener for " + eventName + " already already running for webview " + env.webview.id);
+				context.removeEventListener(systemEvent, _listeners[eventName][env.webview.id]);
+			}
+
+			context.addEventListener(systemEvent, listener);
+			_listeners[eventName][env.webview.id] = listener;
+			result.noResult(true);
+ 		} catch (e) {
+			_eventResult.error("error in startEvent: " + JSON.stringify(e), false);
+		}
+   },
+
+	/**
+	 * Turn off event dispatching for a specific event name
+	 * @param {Function} success Function to call if the operation is a success
+	 * @param {Function} fail Function to call if the operation fails
+	 * @param {Object} args The arguments supplied
+	 * @param {Object} env Environment variables
+	 */
+	stopEvent: function (success, fail, args, env) {
+		var result = new PluginResult(args, env);
+		try {
+			var fixedArgs = _wwfix.parseArgs(args),
+			 	eventName = fixedArgs.eventName,
+				context = _actionMap[eventName].context,
+				systemEvent = _actionMap[eventName].event,
+				listener;
+
+		if (!_listeners || !_listeners[eventName] || !_listeners[eventName][env.webview.id]) {
+			result.error("Underlying listener for " + eventName + " never started for webview " + env.webview.id);
+		} else {
+			listener = _listeners[eventName][env.webview.id];
+			context.removeEventListener(systemEvent, listener);
+			delete _listeners[eventName][env.webview.id];
+			result.noResult(false);
+		}
+		} catch (e) {
+			_eventResult.error("error in stopEvent: " + JSON.stringify(e), false);
+		}
+	},
+
+	/**
+	 * Return a list of message accounts.
+	 * @param success {Function} Function to call if the operation is a success
+	 * @param fail {Function} Function to call if the operation fails
+	 * @param args {Object} The arguments supplied. Available arguments for this call are: N/A
+	 * @param env {Object} Environment variables
+	 */
+	getAccounts: function(success, fail, args, env) {
+		var result = new PluginResult(args, env);
+		try {
+			var fixedArgs = _wwfix.parseArgs(args);
+			var messageType = typeof(fixedArgs['messageType']) === 'string' ? fixedArgs['messageType'] : null;
+			var data = _message.getAccounts(messageType);
+			result.ok(data, false);
+		} catch (e) {
+			result.error(JSON.stringify(e), false);
+		}
+	},
+		
+	/**
+	 * Return an array of zero or more messages.
+	 * @param success {Function} Function to call if the operation is a success
+	 * @param fail {Function} Function to call if the operation fails
+	 * @param args {Object} The arguments supplied. Available arguments for this call are: N/A
+	 * @param env {Object} Environment variables
+	 */
+	find: function(success, fail, args, env) {
+		var result = new PluginResult(args, env)
+		try {
+			var fixedArgs = _wwfix.parseArgs(args);
+
+			var filter 		= typeof(fixedArgs['filter']) 		=== 'object' 	? fixedArgs['filter'] 		: null;
+			var orderBy 	= typeof(fixedArgs['orderBy']) 		=== 'string' 	? fixedArgs['orderBy'] 		: null;
+			var isAscending = typeof(fixedArgs['isAscending']) 	=== 'boolean' 	? fixedArgs['isAscending'] 	: null;
+			var limit 		= typeof(fixedArgs['limit']) 		=== 'number' 	? fixedArgs['limit'] 		: null;
+			var offset 		= typeof(fixedArgs['offset']) 		=== 'number' 	? fixedArgs['offset'] 		: null;
+
+			var data = _message.find(filter, orderBy, isAscending, limit, offset);
+			result.ok(data, false);
+		} catch (e) {
+			result.error(JSON.stringify(e), false);
+		}
+	},
+
+	/**
+	 * Gets a list of folders for the specified account.
+	 * @param success {Function} Function to call if the operation is a success
+	 * @param fail {Function} Function to call if the operation fails
+	 * @param args {Object} The arguments supplied. Available arguments for this call are: N/A
+	 * @param env {Object} Environment variables
+	 */
+	getFolders: function(success, fail, args, env) {
+		// TODO Implement
+	},
+	
+	/**
+	 * Method retrieves message from the database, check first if message exist in database and return is, if not initiated
+	 * PPS request to fetch message by provided message handle.
+	 * The message is returned asynchronously, and can be retrieved by listening to the messageservicemessageresult
+	 * event. Returns a fully populated message, including full subject, contents, recipient list, and attachments.
+	 * @param success {Function} Function to call if the operation is a success
+	 * @param fail {Function} Function to call if the operation fails
+	 * @param args {Object} The arguments supplied. Available arguments for this call are: N/A
+	 * @param env {Object} Environment variables
+	 */
+	getMessage: function(success, fail, args, env) {
+		var result = new PluginResult(args, env)
+		try {
+			var fixedArgs = _wwfix.parseArgs(args);
+			var data = _message.getMessage(fixedArgs.accountId, fixedArgs.handle);
+			result.ok(data, false);
+		} catch (e) {
+			result.error(JSON.stringify(e), false);
+		}
+	},
+
+	/**
+	 * Saves a message.
+	 * @param success {Function} Function to call if the operation is a success
+	 * @param fail {Function} Function to call if the operation fails
+	 * @param args {Object} The arguments supplied. Available arguments for this call are: N/A
+	 * @param env {Object} Environment variables
+	 */
+	save: function(success, fail, args, env) {
+		var result = new PluginResult(args, env)
+		try {
+			var fixedArgs = _wwfix.parseArgs(args);
+			var data = _message.save(fixedArgs.message);
+			result.ok(data, false);
+		} catch (e) {
+			result.error(JSON.stringify(e), false);
+		}
+	},
+
+	/**
+	 * Removes a message.
+	 * @param success {Function} Function to call if the operation is a success
+	 * @param fail {Function} Function to call if the operation fails
+	 * @param args {Object} The arguments supplied. Available arguments for this call are: N/A
+	 * @param env {Object} Environment variables
+	 */
+	remove: function(success, fail, args, env) {
+		var result = new PluginResult(args, env)
+		try {
+			var fixedArgs = _wwfix.parseArgs(args);
+			var data = _message.remove(fixedArgs.message);
+			result.ok(data, false);
+		} catch (e) {
+			result.error(JSON.stringify(e), false);
+		}
+	},
+
+	/**
+	 * move a message to another folder
+	 * @param success {Function} Function to call if the operation is a success
+	 * @param fail {Function} Function to call if the operation fails
+	 * @param args {Object} The arguments supplied. Available arguments for this call are: N/A
+	 * @param env {Object} Environment variables
+	 */
+	move: function(success, fail, args, env) {
+		var result = new PluginResult(args, env)
+		try {
+			var fixedArgs = _wwfix.parseArgs(args);
+			var data = _message.move(fixedArgs.message, args.folder);
+			result.ok(data, false);
+		} catch (e) {
+			result.error(JSON.stringify(e), false);
+		}
+	},
+
+	/**
+	 * Sends a message.
+	 * @param success {Function} Function to call if the operation is a success
+	 * @param fail {Function} Function to call if the operation fails
+	 * @param args {Object} The arguments supplied. Available arguments for this call are: N/A
+	 * @param env {Object} Environment variables
+	 */
+	send: function(success, fail, args, env) {
+		var result = new PluginResult(args, env)
+		try {
+			var fixedArgs = _wwfix.parseArgs(args);
+			var data = _message.send(fixedArgs.message);
+			result.ok(data, false);
+		} catch (e) {
+			result.error(JSON.stringify(e), false);
+		}
+	},
+
+	/**
+	 * Gets the current state of the phone book profile service.
+	 * @param success {Function} Function to call if the operation is a success
+	 * @param fail {Function} Function to call if the operation fails
+	 * @param args {Object} The arguments supplied. Available arguments for this call are: N/A
+	 * @param env {Object} Environment variables
+	 */
+	getState: function(success, fail, args, env) {
+		var result = new PluginResult(args, env)
+		try {
+			var data = _message.getState();
+			result.ok(data, false);
+		} catch (e) {
+			result.error(JSON.stringify(e), false);
+		}
+	}
+};
+
diff --git a/plugin/com.qnx.message/src/blackberry10/message.js b/plugin/com.qnx.message/src/blackberry10/message.js
new file mode 100644
index 0000000..a5197c0
--- /dev/null
+++ b/plugin/com.qnx.message/src/blackberry10/message.js
@@ -0,0 +1,673 @@
+/*
+ * Copyright 2013  QNX Software Systems Limited
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"). You
+ * may not reproduce, modify or distribute this software except in
+ * compliance with the License. You may obtain a copy of the License
+ * at: http://www.apache.org/licenses/LICENSE-2.0.
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTIES OF ANY KIND, either express or implied.
+ * This file may contain contributions from others, either as
+ * contributors under the License or as licensors under other terms.
+ * Please review this entire file for other proprietary rights or license
+ * notices, as well as the applicable QNX License Guide at
+ * http://www.qnx.com/legal/licensing/document_archive/current_matrix.pdf
+ * for other information.
+ */
+
+/**
+ * The abstraction layer for MAP functionality.
+ */
+
+var _pps = qnx.webplatform.pps,
+	_qdb = require('../../lib/qdb'),
+	_statusPPS,
+	_controlPPS,
+	_notificationPPS,
+	ServiceState = require('./servicestate'),
+	ServiceStatus = require('./servicestatus'),
+	ServiceNotification = require('./servicenotification'),
+	_stateChangedTrigger,
+	_findResultTrigger,
+	_findFailTrigger,
+	_messageResultTrigger,
+	_messageFailTrigger,
+	_notificationTrigger,
+	_statusChangeHandler,
+	_db;
+
+/**
+ * MAP status PPS object change handler. Responsible for firing
+ * the extension events.
+ * @param event {Event} The PPS change event
+ */
+function onStatusEvent(event) {
+	// State change
+	if (_stateChangedTrigger && event && event.data && event.data.state) {
+		_stateChangedTrigger(mapStateToServiceState(event.data.state));
+	}
+
+	// Status change
+	if (_statusChangeHandler && event && event.data && event.data.status) {
+		_statusChangeHandler(mapStatusToServiceStatus(event.data.status));
+	}
+}
+
+/**
+ * Event handler will be invoked during onNewData on PPS object.
+ * Handles notifications coming from Bluetooth.
+ * Notification can be about new message, deleted message etc.
+ * @param event {Object} PPS event object
+ * Ex: data:{
+ *	 status: 'NEW_MESSAGES'
+ *	 message_type: 'EMAIL'
+ *	 message_handle: '123456'
+ * }
+ * */
+function onNotificationEvent(event) {
+	var result = {};
+	if (_notificationTrigger && event && event.data
+			&& event.data.status
+			&& event.data.hasOwnProperty('account_id') && typeof(event.data.account_id) === 'number' 
+			&& event.data.message_type
+			&& event.data.message_handle) {
+		switch (event.data.status) {
+			case "NEW_MESSAGE":
+				// select new message by handle provided
+				var messages = queryMessages("WHERE handle='" + event.data.message_handle + "' AND account_id=" + event.data.account_id);
+				if (messages.length == 1) {
+					result = { message:messages[0], accountId: event.data.account_id, type: mapNoitificationTypeToServiceNotificationType(event.data.status) };
+					_notificationTrigger(result);
+				}
+				break;
+			case "MESSAGE_DELETED":
+				// Construct a message object containing just the handle and type
+				result = { 
+					message: { handle: event.data.message_handle, type: event.data.message_type },
+					type: mapNoitificationTypeToServiceNotificationType(event.data.status)
+				};
+				_notificationTrigger(result);
+				break;
+		}
+	}
+}
+
+/**
+ * Private utility to help build and execute query on database, to fetch full message
+ * @param whereCaluse {String} is like "WHERE a=1"
+ * @param orderBy {String} Field name for Order By
+ * @param isAscending {Boolean} Sorting direction
+ * @param limit {String} maximum numbers of records in result set
+ * @param offset {String} offset from the beginning of the table
+ * @returns {Object} Array representing list of Message, lacking full subject and body and all contacts (TO, CC, BCC) only one (first) TO contact present
+ * @example [
+ * {
+ *		 handle: 123456,
+ *		 message_type: 'EMAIL',
+ *		 folderId: 1,
+ *		 sender: 'test@email.com',*
+ *		 subject: 'Test email',
+ *		 bodyPlainText: 'This is the content of the test email',
+ *		 bodyHtml: '<html>...</html>',
+ *		 recipients: [{email:'me@email.com', name:'me'}],
+ *		 attachments: [{url:'blah.pdf', size:'145678'}]
+ *		 ...
+ * },{
+ *  *	 handle: 123457,
+ *		 message_type: 'EMAIL',
+ *		 folderId: 1,
+ *		 sender: 'test@email.com',*
+ *		 subject: 'Test email',
+ *		 bodyPlainText: 'This is the content of the test email',
+ *		 bodyHtml: '<html>...</html>',
+ *		 recipients: [{email:'me@email.com', name:'me'}],
+ *		 attachments: [{url:'blah.pdf', size:'145678'}]
+ *		 ...
+ * }]
+ * */
+function queryMessages(whereClause, orderBy, isAscending, limit, offset) {
+	// Just get messages
+	var sql = 'SELECT * FROM messages_view ' + whereClause +
+		(typeof(orderBy) === 'string' ? ' ORDER BY ' + orderBy + (typeof(isAscending) === 'boolean' && isAscending ? ' ASC' : ' DESC') : '') +
+		' LIMIT ' + (typeof(limit) === 'number' ? limit : -1) +
+		' OFFSET ' + (typeof(offset) === 'number' ? offset : 0);
+
+	// Get the array of results
+	var result = _qdb.resultToArray(_db.query(sql));
+	return normalizeFields(result);
+}
+
+/**
+ * Private utility to help build and execute query on database, to fetch full messages
+ * @param accountId {Number} The ID of the account in which the message exists
+ * @param handle {String} Message handle
+ * @returns {Object} Object representing single Message
+ * @example:
+ * {
+ *		handle: 123456,
+ *		message_type: 'EMAIL',
+ *		folderId: 1,
+ *		sender: 'test@email.com',*
+ *		subject: 'Test email',
+ *		bodyPlainText: 'This is the content of the test email',
+ *		bodyHtml: '<html>...</html>',
+ *		recipients: [{email:'me@email.com', name:'me'},{email:'me2@email.com', name:'me2'}],
+ *		attachments: [{url:'blah.pdf', size:'145678'}]
+ *		 ...
+ * }
+ * */
+function queryFullMessage(accountId, handle) {
+	var sql = "SELECT * FROM full_messages_view" + " WHERE handle='" + handle + "' AND account_id=" + accountId;
+
+	var message = null;
+	// Get the array of results
+	var result = _qdb.resultToArray(_db.query(sql));
+
+	if (result && result.length > 0) {
+		message = normalizeFields(result)[0];
+
+		sql = "SELECT * FROM attachments" + " WHERE message_id=" + message.messageId;
+		var attachments = _qdb.resultToArray(_db.query(sql));
+		attachments = normalizeFields(attachments);
+		message.attachments = attachments;
+
+		sql = "SELECT * FROM contacts_view" + " WHERE message_id=" + message.messageId;
+		var contacts = _qdb.resultToArray(_db.query(sql));
+		message.recipients = normalizeFields(contacts);
+	}
+
+	return message;
+}
+
+/**
+ * Converts the MAP-specific contacts service state string into a state constant
+ * defined in the qnx.message extension.
+ * @param mapState {String} The MAP state string.
+ * @returns {String} A qnx.message state constant.
+ */
+function mapStateToServiceState(mapState) {
+	var state = null;
+	switch (mapState) {
+		case 'CONNECTED':
+			state = ServiceState.STATE_CONNECTED;
+			break;
+		case 'DISCONNECTED':
+			state = ServiceState.STATE_DISCONNECTED;
+			break;
+		case 'INITIALIZING':
+			state = ServiceState.STATE_DISCONNECTED;
+			break;
+		case 'CONNECTING':
+			state = ServiceState.STATE_CONNECTING;
+			break;
+	}
+	return state;
+}
+
+/**
+ * Converts the MAP-specific service status string into a status constant
+ * defined in the qnx.message extension.
+ * @param mapStatus {String} The MAP status string.
+ * @returns {String} A qnx.message status constant.
+ */
+function mapStatusToServiceStatus(mapStatus) {
+	var status = null;
+	switch (mapStatus) {
+		case 'PROCESSING':
+			status = ServiceStatus.STATUS_PROCESSING;
+			break;
+		case 'COMPLETE':
+			status = ServiceStatus.STATUS_READY;
+			break;
+		case 'ERROR_BUSY':
+			status = ServiceStatus.STATUS_BUSY;
+			break;
+		case 'ERROR_COMMAND_NOT_KNOWN':
+		case 'ERROR_NOT_CONNECTED':
+		case 'FAILED':
+			status = ServiceStatus.STATUS_ERROR;
+			break;
+	}
+	return status;
+}
+
+/**
+ * Converts the MAP-specific message service notification type string into a notification type constant
+ * defined in the qnx.message extension.
+ * @param mapNotification {String} The MAP notification type string.
+ * @returns {String} A qnx.message status constant.
+ */
+function mapNoitificationTypeToServiceNotificationType(mapNotification) {
+	var notificationType = null;
+	switch (mapNotification) {
+		case 'NEW_MESSAGE':
+			notificationType = ServiceNotification.NOTIFICATION_NEW_MESSAGE;
+			break;
+		case 'MESSAGE_DELETED':
+			notificationType = ServiceNotification.NOTIFICATION_MESSAGE_DELETED;
+			break;
+		case 'MESSAGE_SHIFT':
+			notificationType = ServiceNotification.NOTIFICATION_MESSAGE_SHIFT;
+			break;
+	}
+	return notificationType;
+}
+
+/**
+ * Converts a FilterExpression used for the find operation into a string.
+ * Note that this is specific to PBAP, and each contacts service would have
+ * to define their own function to suit its needs.
+ * @param filterExpression {qnx.pim.contacts.FilterExpression} The FilterExpression object.
+ * @return {String} A SQL string for use on the PBAP contacts_view view.
+ */
+function filterExpressionToString(filterExpression) {
+	// FIXME: There's an opportunity to perform an SQL injection attack here
+	var str = '';
+
+	if (typeof(filterExpression) === 'object' &&
+		filterExpression.hasOwnProperty('leftField') &&
+		filterExpression.hasOwnProperty('operator') &&
+		filterExpression.hasOwnProperty('rightField')) {
+		str = '(';
+
+		// Add the left field
+		if (typeof(filterExpression.leftField) === 'object') {
+			str += filterExpressionToString(filterExpression.leftField);
+		} else {
+			str += filterExpression.leftField;
+		}
+
+		// Add the operator
+		str += ' ' + filterExpression.operator + ' ';
+
+		// Add the right field
+		if (typeof(filterExpression.rightField) === 'object') {
+			str += filterExpressionToString(filterExpression.rightField);
+		} else if (typeof(filterExpression.rightField) === 'number') {
+			str += filterExpression.rightField;
+		} else {
+			str += '\'' + filterExpression.rightField + '\'';
+		}
+
+		str += ')';
+	} else {
+		console.error('Unrecognized FilterExpression object.', filterExpression);
+	}
+
+	return str;
+}
+
+/**
+ * Function converts fields in provided object with '_' to camel case style fields
+ * @param result {Object} Object representing a message
+ * @returns {Object} Object representing single Message
+ * @example
+ * {
+ *		 handle: 123456,
+ *		 messageType: 'EMAIL',
+ *		 folderId: 1,
+ *		 sender: 'test@email.com',
+ *		 subject: 'Test email',
+ *		 bodyPlainText: 'This is the content of the test email',
+ *		 bodyHtml: '<html>...</html>',
+ *		 recipients: [{email:'me@email.com', name:'me'},{email:'me2@email.com', name:'me2'}],
+ *		 attachments: [{url:'blah.pdf', size:'145678'}]
+ *		 ...
+ * }
+ * */
+function normalizeFields(result) {
+	if (result.length > 0) {
+		// Must return objects which client can convert into Message instances.
+
+		// Typically this 'translation' process would be unique to each contacts service. In the
+		// case of MAP, we already know that this particular database view contains the right fields,
+		// but we need to convert the property names to camel cased rather than underscore-delimited.
+
+		// Build an array of property names that need to be renamed. We should only have
+		// to do this once, since all of the property names will be the same for each
+		// record.
+		var propsToRename = [];
+		for (var prop in result[0]) {
+			if (prop.indexOf('_') >= 0) {
+				propsToRename.push(prop);
+			}
+		}
+
+		// Now we can iterate through each of the records in the result and rename the properties
+		for (var i = 0; i < result.length; i++) {
+			for (var j = 0; j < propsToRename.length; j++) {
+				// Add the renamed property to the record
+				result[i][propsToRename[j].replace(/_([a-zA-Z])/g,
+					function (match, letter) {
+						return letter.toUpperCase();
+					}).replace('_', '')] = result[i][propsToRename[j]];
+
+				// Remove the old underscore property from the record
+				delete result[i][propsToRename[j]];
+			}
+
+			// work specifically on sender* or recipient* fields
+			// TODO Uncomment if needed, commented for now
+			/*
+			 var temp = result[i];
+			 if(temp.senderEmail && temp.senderNumber && temp.senderLastName && temp.senderFirstName) {
+			 var sender = {email:temp.senderEmail, number:temp.senderNumber, lastName: temp.senderLastName,firstName:temp.senderFirstName}
+			 temp.sender = sender;
+			 delete temp.senderEmail; delete temp.senderNumber; delete temp.senderLastName; delete temp.senderFirstName;
+			 }
+			 if(temp.recipientEmail && temp.recipientNumber && temp.recipientLastName && temp.recipientFirstName) {
+			 var recipient = {email:temp.recipientEmail, number:temp.recipientNumber, lastName: temp.recipientLastName,firstName:temp.recipientFirstName}
+			 temp.recipient = recipient;
+			 delete temp.recipientEmail; delete temp.recipientNumber; delete temp.recipientLastName; delete temp.recipientFirstName;
+			 }
+			 */
+		}
+	}
+	return result;
+}
+
+/**
+ * Exports are the publicly accessible functions
+ */
+module.exports = {
+	/**
+	 * Initializes the extension.
+	 */
+	init:function () {
+		try {
+			//_statusPPS
+			_statusPPS = _pps.createObject("/pps/services/bluetooth/messages/status", _pps.PPSMode.DELTA);
+			_statusPPS.onNewData = onStatusEvent;
+			_statusPPS.open(_pps.FileMode.RDONLY);
+		} catch (ex) {
+			var err = 'qnx.message::init [message.js] Error opening /pps/services/bluetooth/messages/status';
+			console.error(err);
+			throw new Error(err);
+		}
+
+		try {
+			//writing pps commands
+			_controlPPS = _pps.createObject("/pps/services/bluetooth/messages/control", _pps.PPSMode.DELTA);
+			_controlPPS.open(_pps.FileMode.WRONLY);
+		} catch (ex) {
+			var err = 'qnx.message::init [message.js] Error opening /pps/services/bluetooth/messages/control';
+			console.error(err);
+			throw new Error(err);
+		}
+
+		try {
+			//receiving notifications
+			_notificationPPS = _pps.createObject("/pps/services/bluetooth/messages/notification", _pps.PPSMode.DELTA);
+			_notificationPPS.onNewData = onNotificationEvent;
+			_notificationPPS.open(_pps.FileMode.RDONLY);
+		} catch (ex) {
+			var err = 'qnx.message::init [message.js] Error opening /pps/services/bluetooth/messages/notification';
+			console.error(err);
+			throw new Error(err);
+		}
+
+		// Create database object
+		_db = _qdb.createObject();
+		if (!_db || !_db.open('/dev/qdb/messages')) {
+			var err = 'qnx.message::init [message.js] Error opening db; path=/dev/qdb/messages';
+			console.error(err);
+			throw new Error(err);
+		}
+	},
+
+	/**
+	 * Sets the trigger function to call when an event is fired
+	 * @param trigger {Function} The trigger function to call when an event is fired
+	 */
+	setStateChangedTrigger:function (trigger) {
+		_stateChangedTrigger = trigger;
+	},
+	
+	/**
+	 * Sets the trigger function to call when an event is fired
+	 * @param trigger {Function} The trigger function to call when an event is fired
+	 */
+	setFindResultTrigger:function (trigger) {
+		_findResultTrigger = trigger;
+	},
+	
+	/**
+	 * Sets the trigger function to call when an event is fired
+	 * @param trigger {Function} The trigger function to call when an event is fired
+	 */
+	setFindFailTrigger:function (trigger) {
+		_findFailTrigger = trigger;
+	},
+	
+	/**
+	 * Sets the trigger function to call when an event is fired
+	 * @param trigger {Function} The trigger function to call when an event is fired
+	 */
+	setMessageResultTrigger:function (trigger) {
+		_messageResultTrigger = trigger;
+	},
+	
+	/**
+	 * Sets the trigger function to call when an event is fired
+	 * @param trigger {Function} The trigger function to call when an event is fired
+	 */
+	setMessageFailTrigger:function (trigger) {
+		_messageFailTrigger = trigger;
+	},
+	
+	/**
+	 * Sets the trigger function to call when an event is fired
+	 * @param trigger {Function} The trigger function to call when an event is fired
+	 */
+	setNotificationTrigger:function (trigger) {
+		_notificationTrigger = trigger;
+	},
+
+	/**
+	 * Returns a list of message accounts.
+	 * @param messageType {String} (optional) Filter returned accounts by supported message type.
+	 * @return {Array} The list of message accounts.
+	 * @example
+	 * [
+	 * 	{
+	 * 		id: 0,
+	 * 		name: 'Desktop_1',
+	 * 		messageTypes: ['EMAIL']
+	 * 	},
+	 * 	{
+	 * 		id: 1,
+	 * 		name: 'SMSMMS_0',
+	 * 		messageTypes: ['SMS_GSM', 'MMS']
+	 * 	}
+	 * ]
+	 */
+	getAccounts: function(messageType) {
+		// Build the where clause, if needed
+		var whereClause = '';
+		if(messageType && typeof(messageType) === 'string') {
+			whereClause = 'WHERE accounts.account_id IN (SELECT accounts_message_types_rel.account_id ' +
+							'FROM accounts_message_types_rel LEFT JOIN message_types ON accounts_message_types_rel.message_type_id = message_types.message_type_id ' +
+							'WHERE message_types.type = \'' + messageType + '\') ';
+		}
+		
+		// Build the SQL statement
+		var sql = 'SELECT ' +
+					'accounts.account_id AS id, ' +
+					'accounts.name, ' +
+					'GROUP_CONCAT(message_types.type) AS messageTypes ' +
+					'FROM accounts ' +
+					'LEFT JOIN accounts_message_types_rel ON accounts.account_id = accounts_message_types_rel.account_id ' +
+					'LEFT JOIN message_types ON accounts_message_types_rel.message_type_id = message_types.message_type_id ' +
+					whereClause +
+					'GROUP BY id, name';
+
+		// Get the results
+		var results = _qdb.resultToArray(_db.query(sql));
+		
+		// Split the message types into an array
+		for(var i = 0; i < results.length; i++) {
+			if(typeof(results[i].messageTypes) === 'string') {
+				results[i].messageTypes = results[i].messageTypes.split(','); 
+			} else {
+				results[i].messageTypes = [];
+			}
+		}
+
+		// Return the results
+		return results;
+	},
+
+	/**
+	 * Returns an array of zero or more messages.
+	 * @param filter {qnxcar.phonebook.filterExpression} (optional) The
+	 * {@link qnxcar.phonebook.filterExpression filter expression} to apply against
+	 * the phone book database.
+	 * @param orderBy {String} (optional) The field name to order by. The default order is descending,
+	 * however this can be overridden by specifying the isAscending parameter as 'true'. Defaults to
+	 * 'last_name'.
+	 * @param isAscending {Boolean} (optional) If an orderBy parameter is supplied, changes the order
+	 * direction to ascending if true, descending if false. Defaults to false.
+	 * @param limit {Number} (optional) The maximum number of Contacts to return. Defaults to -1 (no limit).
+	 * @param offset {Number} (optional) Specifies the record offset. Defaults to 0 (no offset).
+	 */
+	find:function (filterExpression, orderBy, isAscending, limit, offset) {
+		/* TODO check amount of messages in the table, if less the limit, ask PPS to get more
+		 if more then limit - just proceed reading database and emitting event with data
+		 * */
+		var whereClause = typeof(filterExpression) === 'object' && filterExpression ? ' WHERE ' + filterExpressionToString(filterExpression) : ''
+
+		return queryMessages(whereClause, orderBy, isAscending, limit, offset);
+	},
+
+	/**
+	 * Saves a message to the device MAP storage.
+	 * @param message {qnx.message.Message} Message to save
+	 * @return {Number} The existing or new unique identifier for the contact.
+	 */
+	save:function (message) {
+		var err = 'qnx.messages::save [message.js] is not supported';
+		console.error(err);
+		throw Error(err);
+	},
+
+	/**
+	 * Removes a message from the device MAP storage.
+	 * @param message {qnx.message.Message} The message to remove.
+	 */
+	remove:function (message) {
+		var err = 'qnx.messages::remove [message.js] is not supported';
+		console.error(err);
+		throw Error(err);
+	},
+
+	/**
+	 * Moves this message to different folder
+	 * @param message {qnx.message.Message} The message to move.
+	 * @param message {String} Destination folder
+	 */
+	move:function (message, folder) {
+		var err = 'qnx.messages::move [message.js] is not supported';
+		console.error(err);
+		throw Error(err);
+	},
+
+	/**
+	 * Sends provided message.
+	 * @param message {qnx.message.Message} The message to remove.
+	 */
+	send:function (message) {
+		var err = 'qnx.messages::send [message.js] is not supported';
+		console.error(err);
+		throw Error(err);
+	},
+
+	/**
+	 * Method retrieves message from the database, check first if message exist in database and return is, if not initiated
+	 * PPS request to fetch message by provided message handle.
+	 * The message is returned asynchronously, and can be retrieved by listening to the messageservicemessageresult
+	 * event. Returns a fully populated message, including full subject, contents, recipient list, and attachments.
+	 * @param accountId {Number} The ID of the account for which the message exists
+	 * @param handle {String} Unique identifier of the message of certain type
+	 *
+	 * TODO: This function assumes we have single client doing single operation at the same time
+	 * */
+	getMessage:function (accountId, handle) {
+		// first check DB if full message already exists
+		var message = queryFullMessage(accountId, handle);
+		// message available - just fire up
+		if (message) {
+			// fire client event
+			if(_messageResultTrigger) {
+				_messageResultTrigger(message);
+			}
+		} else {
+			if (_statusPPS.data.status.state != ServiceStatus.STATUS_PROCESSING) {
+				// redefine trigger
+				_statusChangeHandler = function (event) {
+					switch (event) {
+						case ServiceStatus.STATUS_READY:
+							var message = queryFullMessage(accountId, handle);
+
+							if(message && _messageResultTrigger) {
+								_messageResultTrigger(message);
+							} else if (!message && _messageFailTrigger) {
+								_messageFailTrigger('Message does not exist in database.');
+							}
+							
+							_statusChangeHandler = null;
+							break;
+						case ServiceStatus.STATUS_BUSY:
+						case ServiceStatus.STATUS_ERROR:
+							if(_messageFailTrigger) {
+								// fire client event
+								_messageFailTrigger(event === ServiceStatus.STATUS_BUSY ? 'Service busy.' : 'MAP error.');
+							}
+							_statusChangeHandler = null;
+							break;
+					}
+				};
+				
+				// send PPS command to fetch Message
+				_controlPPS.write(
+					{
+						command:"GET_MESSAGE",
+						account_id:accountId,
+						message_handle:handle,
+						message_folder: ''
+					}
+				);
+			} else {
+				_messageFailTrigger("Service busy.");
+			}
+		}
+	},
+
+	/**
+	 * Returns current state of the MAP
+	 * @return {String} Value which will indicate current state of the service, <code>STATE_CONNECTED</code>, <code>STATE_DISCONNECTED</code>, <code>STATE_INITIALIZING</code>
+	 */
+	getState:function () {
+		var state = null;
+		if (_statusPPS.data && _statusPPS.data.status && _statusPPS.data.status.state) {
+			state = mapStateToServiceState(_statusPPS.data.status.state);
+		} else {
+			console.warn('/pps/services/bluetooth/messages/status state attribute does not exist.');
+		}
+		return state;
+	},
+
+	/**
+	 * Forces the contacts in the MAP storage to refresh.
+	 */
+	refresh:function () {
+		try {
+			_controlPPS.write({'[n]command':this.COMMAND_REFRESH});
+		} catch (ex) {
+			var err = 'qnx.messages::refresh [message.js] Failed to write refresh command to /pps/services/bluetooth/messages/control.';
+			console.error(err);
+			throw new Error(err);
+		}
+	}
+};
\ No newline at end of file
diff --git a/plugin/com.qnx.message/src/blackberry10/servicenotification.js b/plugin/com.qnx.message/src/blackberry10/servicenotification.js
new file mode 100644
index 0000000..88fdb85
--- /dev/null
+++ b/plugin/com.qnx.message/src/blackberry10/servicenotification.js
@@ -0,0 +1,43 @@
+/*
+ * Copyright 2013  QNX Software Systems Limited
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"). You
+ * may not reproduce, modify or distribute this software except in
+ * compliance with the License. You may obtain a copy of the License
+ * at: http://www.apache.org/licenses/LICENSE-2.0.
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTIES OF ANY KIND, either express or implied.
+ * This file may contain contributions from others, either as
+ * contributors under the License or as licensors under other terms.
+ * Please review this entire file for other proprietary rights or license
+ * notices, as well as the applicable QNX License Guide at
+ * http://www.qnx.com/legal/licensing/document_archive/current_matrix.pdf
+ * for other information.
+ */
+
+/**
+ * The message service notification type constants.
+ * Notification type constants must be consistent with those defined in the qnx.message client.js.
+ */
+module.exports = {
+	/** Notification type for new message */
+	NOTIFICATION_NEW_MESSAGE:'NOTIFICATION_NEW_MESSAGE',
+	/** Notification type for delivery of sent message successful */
+	NOTIFICATION_DELIVERY_SUCCESS:'NOTIFICATION_DELIVERY_SUCCESS',
+	/** Notification type for sending of message successful */
+	NOTIFICATION_SENDING_SUCCESS:'NOTIFICATION_SENDING_SUCCESS',
+	/** Notification type for delivery of sent message failed */
+	NOTIFICATION_DELIVERY_FAILURE:'NOTIFICATION_DELIVERY_FAILURE',
+	/** Notification type for sending of message failed */
+	NOTIFICATION_SENDING_FAILURE:'NOTIFICATION_SENDING_FAILURE',
+	/** Notification type when phone memory is full */
+	NOTIFICATION_MEMORY_FULL:'NOTIFICATION_MEMORY_FULL',
+	/** Notification type when phone memory is available */
+	NOTIFICATION_MEMORY_AVAILABLE:'NOTIFICATION_MEMORY_AVAILABLE',
+	/** Notification type when message is deleted*/
+	NOTIFICATION_MESSAGE_DELETED:'NOTIFICATION_MESSAGE_DELETED',
+	/** Notification type when message moved */
+	NOTIFICATION_MESSAGE_SHIFT:'NOTIFICATION_MESSAGE_SHIFT',
+};
\ No newline at end of file
diff --git a/plugin/com.qnx.message/src/blackberry10/servicestate.js b/plugin/com.qnx.message/src/blackberry10/servicestate.js
new file mode 100644
index 0000000..09576f6
--- /dev/null
+++ b/plugin/com.qnx.message/src/blackberry10/servicestate.js
@@ -0,0 +1,30 @@
+/*
+ * Copyright 2013  QNX Software Systems Limited
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"). You
+ * may not reproduce, modify or distribute this software except in
+ * compliance with the License. You may obtain a copy of the License
+ * at: http://www.apache.org/licenses/LICENSE-2.0.
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTIES OF ANY KIND, either express or implied.
+ * This file may contain contributions from others, either as
+ * contributors under the License or as licensors under other terms.
+ * Please review this entire file for other proprietary rights or license
+ * notices, as well as the applicable QNX License Guide at
+ * http://www.qnx.com/legal/licensing/document_archive/current_matrix.pdf
+ * for other information.
+ */
+
+
+/**
+ * The message service state constants.
+ * State constants must be consistent with those defined in the qnx.message client.js.
+ */
+module.exports = {
+	STATE_CONNECTED:	'STATE_CONNECTED',
+	STATE_CONNECTING:	'STATE_CONNECTING',
+	STATE_DISCONNECTED:	'STATE_DISCONNECTED',
+	STATE_INITIALIZING:	'STATE_INITIALIZING'
+};
\ No newline at end of file
diff --git a/plugin/com.qnx.message/src/blackberry10/servicestatus.js b/plugin/com.qnx.message/src/blackberry10/servicestatus.js
new file mode 100644
index 0000000..dd2b0f9
--- /dev/null
+++ b/plugin/com.qnx.message/src/blackberry10/servicestatus.js
@@ -0,0 +1,30 @@
+/*
+ * Copyright 2013  QNX Software Systems Limited
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"). You
+ * may not reproduce, modify or distribute this software except in
+ * compliance with the License. You may obtain a copy of the License
+ * at: http://www.apache.org/licenses/LICENSE-2.0.
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTIES OF ANY KIND, either express or implied.
+ * This file may contain contributions from others, either as
+ * contributors under the License or as licensors under other terms.
+ * Please review this entire file for other proprietary rights or license
+ * notices, as well as the applicable QNX License Guide at
+ * http://www.qnx.com/legal/licensing/document_archive/current_matrix.pdf
+ * for other information.
+ */
+
+
+/**
+ * The message service status constants.
+ * Status constants must be consistent with those defined in the qnx.message client.js.
+ */
+module.exports = {
+	STATUS_PROCESSING:	'STATUS_PROCESSING',
+	STATUS_READY:		'STATUS_READY',
+	STATUS_BUSY:		'STATUS_BUSY',
+	STATUS_ERROR:		'STATUS_ERROR'
+};
\ No newline at end of file
diff --git a/plugin/com.qnx.message/www/client.js b/plugin/com.qnx.message/www/client.js
new file mode 100644
index 0000000..4f9cb3d
--- /dev/null
+++ b/plugin/com.qnx.message/www/client.js
@@ -0,0 +1,453 @@
+/*
+ * Copyright 2013  QNX Software Systems Limited
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"). You
+ * may not reproduce, modify or distribute this software except in
+ * compliance with the License. You may obtain a copy of the License
+ * at: http://www.apache.org/licenses/LICENSE-2.0.
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTIES OF ANY KIND, either express or implied.
+ * This file may contain contributions from others, either as
+ * contributors under the License or as licensors under other terms.
+ * Please review this entire file for other proprietary rights or license
+ * notices, as well as the applicable QNX License Guide at
+ * http://www.qnx.com/legal/licensing/document_archive/current_matrix.pdf
+ * for other information.
+ */
+
+
+/**
+ * Allow access to device messages (Email, SMS, MMS)
+ *
+ * <h3>Events</h3>
+ *     
+ * <dl><dt><h4>messageservicestatechange</h4></dt>
+ * <dd><p>Fired when a message service state has changed.</p>
+ * <h5>Event data</h5>
+ * <p>{String}</p>
+ * <h5>Example</h5>
+ * <pre><code>{
+ *      'CONNECTED'
+ * }</code></pre></dd></dl>
+ *
+ * <dl><dt><h4>messageservicefindresult</h4></dt>
+ * <dd><p>Fired when a <code>qnx.message.find</code> operation has returned data.</p>
+ * <h5>Event data</h5>
+ * <p>{Array} Array of <code>qnx.message.Message</code> objects.</p>
+ * <h5>Example</h5>
+ * <pre><code>[
+ *{
+ *      handle: 123456,
+ *      type: 'EMAIL',
+ *      folderId: 1,
+ *      sender: 'test@email.com',*
+ *      subject: 'Test email',
+ *      bodyPlainText: 'This is the content of the test email',
+ *      bodyHtml: '&lt;html&gt;...&lt;/html&gt;',
+ *      recipients: [{email:'me@email.com', name:'me'}],
+ *      attachments: [{url:'blah.pdf', size:'145678'}]
+ *      ...
+ *},{
+ *      handle: 123457,
+ *      type: 'EMAIL',
+ *      folderId: 1,
+ *      sender: 'test@email.com',*
+ *      subject: 'Test email',
+ *      bodyPlainText: 'This is the content of the test email',
+ *      bodyHtml: '&lt;html&gt;...&lt;/html&gt;',
+ *      recipients: [{email:'me@email.com', name:'me'}],
+ *      attachments: [{url:'blah.pdf', size:'145678'}]
+ *      ...
+ *}
+ *]</code></pre></dd></dl>
+ *
+ * <dl><dt><h4>messageservicefindresult</h4></dt>
+ * <dd><p>Fired when a <code>qnx.message.find</code> operation has failed.</p>
+ * <h5>Event data</h5>
+ * <p>{String} The error message.</p>
+ *
+ * <h4>messageservicemessageresult</h4>
+ * <p>Fired when a <code>qnx.message.getMessage</code> operation has returned data.</p>
+ * <h5>Event data</h5>
+ * <p>{qnx.message.Message} The <code>qnx.message.Message</code> object.</p>
+ * <h5>Example</h5>
+ * <pre><code>{
+ *      handle: 123456,
+ *      type: 'EMAIL',
+ *      folderId: 1,
+ *      sender: 'test@email.com',*
+ *      subject: 'Test email',
+ *      bodyPlainText: 'This is the content of the test email',
+ *      bodyHtml: '&lt;html&gt;...&lt;/html&gt;',
+ *      recipients: [{email:'me@email.com', name:'me'},{email:'me2@email.com', name:'me2'}],
+ *      attachments: [{url:'blah.pdf', size:'145678'}]
+ *      ...
+ *}</code></pre></dd></dl>
+ *
+ * <dl><dt><h4>messageservicemessagefail</h4></dt>
+ * <dd><p>Fired when a <code>qnx.message.getMessage</code> operation has failed.</p>
+ * <h5>Event data</h5>
+ * <p>{String} The error message.</p></dd></dl>
+ *
+ * <dl><dt><h4>messageservicenotification</h4></dt>
+ * <dd><p>Fired when a message service notification event has occured.</p>
+ * <h5>Event data</h5>
+ * <p>{Object}</p>
+ * <h5>Example</h5>
+ *<pre><code>{
+ *      type:	'NOTIFICATION_NEW_MESSAGE',
+ *      message:
+ *      {
+ *              handle: 123456,
+ *              type: 'EMAIL',
+ *              folderId: 1,
+ *              sender: 'test@email.com',
+ *              subject: 'Test email',
+ *              bodyPlainText: 'This is the content of the test email',
+ *              bodyHtml: '&lt;html&gt;...&lt;/html&gt;',
+ *              ...
+ *      }
+ *}</code></pre></dd></dl>
+ * 
+ * @module qnx.message
+ * @static
+ * @deprecated
+ */
+
+
+var _ID = "com.qnx.message",
+	_events = ["messageservicestatechange", "messageservicefindresult", "messageservicefindfail", 
+	"messageservicemessageresult", "messageservicemessagefail", "messageservicenotification"];
+
+
+_events.map(function (eventName) {
+	var channel = cordova.addDocumentEventHandler(eventName),
+		success = function (data) {
+			channel.fire(data);
+		},
+		fail = function (error) {
+			console.log("Error initializing " + eventName + " listener: ", error);
+		};
+
+	channel.onHasSubscribersChange = function () {
+		if (this.numHandlers === 1) {
+			window.cordova.exec(success, fail, _ID, "startEvent", {eventName: eventName});
+		} else if (this.numHandlers === 0) {
+			window.cordova.exec(null, null, _ID, "stopEvent", {eventName: eventName});
+		}
+	};
+});
+
+
+/**
+ * Message object constructor.
+ * @param {Object} properties The properties argument can be used to initialize the Messages's properties.
+ */
+function Message(properties) {
+	this.accountId = null;
+	this.accountName = null;
+	this.handle = null;
+	this.type = null;
+	this.folderId = null;
+	this.folderName = null;
+	this.folderPath = null;
+	this.senderEmail = null;
+	this.senderNumber = null;
+	this.senderFirstName = null;
+	this.senderLastName = null;
+	this.replyToEmail = null;
+	this.replyToNumber = null;
+	this.replyToFirstName = null;
+	this.replyToLastName = null;
+	this.recipients = []; // list of recipients, array of contact object
+	this.subject = null;
+	this.bodyPlainText = null;
+	this.bodyHtml = null;
+	this.datetime = null;
+	this.read = false;
+	this.sent = false;
+	this.protected = false;
+	this.priority = false;
+	this.attachments = [];	// { filename: 'att.zip', size: 1024 }
+
+	// Initialize properties
+	for (var prop in properties) {
+		if (this.hasOwnProperty(prop)) {
+			this[prop] = properties[prop];
+		}
+	};
+
+	/**
+	 * Save this message to the device MAP storage
+	 */
+	this.save = function () {
+   		var args = {
+   				contact: this
+   			},
+			success = function (data, response) {
+				this.uid = data;
+			},
+			fail = function (data, response) {
+				throw data;
+			};
+		try {
+			window.cordova.exec(success, fail, _ID, 'save', args);
+		} catch (e) {
+			console.error(e);
+		}
+	};
+
+
+	/**
+	 * Remove this message from the device MAP storage
+	 */
+	this.remove = function () {
+		window.cordova.exec(null, null, _ID, 'remove', { contact:this });
+	};
+
+	/**
+	 * Move this message to different folder
+	 * @param {Number} folder The folder ID to which the message will be moved.
+	 */
+	this.move = function (folder) {
+		window.cordova.exec(null, null, _ID, 'move', { contact:this, folder:folder });
+	};
+
+	/**
+	 * Send this message
+	 */
+	this.send = function () {
+		window.cordova.exec(null, null, _ID, 'send', { contact:this });
+	};
+};
+
+function FilterExpression(leftField, operator, rightField) {
+	// Filter on:
+	// - Message types (SMS, Email, etc)
+	// - Sender email
+	// - Subject (partial matching)
+	// - Date range?
+	this.leftField = leftField;
+	this.operator = operator;
+	this.rightField = rightField;
+};
+
+/*
+ * Exports are the publicly accessible functions
+ */
+module.exports = {
+	/* Service states */
+	/** Service Connected and ready to accept commands */
+	STATE_CONNECTED:'STATE_CONNECTED',
+	/** Service Disconnected*/
+	STATE_DISCONNECTED:'STATE_DISCONNECTED',
+	/** Service in process of connecting*/
+	STATE_CONNECTING:'STATE_CONNECTING',
+	/** Service Initializing*/
+	STATE_INITIALIZING:'STATE_INITIALIZING',
+
+	/* Message types */
+	/** Defines message of EMAIL type */
+	MESSAGE_TYPE_EMAIL:'EMAIL',
+	/** Defines message of SMS_GSM type */
+	MESSAGE_TYPE_SMS_GSM:'SMS_GSM',
+	/** Defines message of SMS_CDMA type */
+	MESSAGE_TYPE_SMS_CDMA:'SMS_CDMA',
+	/** Defines message of MMS type */
+	MESSAGE_TYPE_MMS:'MMS',
+
+	/* Message folders */
+	/** root INBOX folder*/
+	FOLDER_INBOX:'inbox/',
+	/** root DRAFTS folder*/
+	FOLDER_DRAFTS:'drafts/',
+	/** root OUTBOX folder*/
+	FOLDER_OUTBOX:'outbox/',
+	/** root SENT folder*/
+	FOLDER_SENT:'sent/',
+
+	/* Notification types */
+	/** Notification type for new messages */
+	NOTIFICATION_NEW_MESSAGE:'NOTIFICATION_NEW_MESSAGE',
+	/** Notification type for delivery of sent message successful */
+	NOTIFICATION_DELIVERY_SUCCESS:'NOTIFICATION_DELIVERY_SUCCESS',
+	/** Notification type for sending of message successful */
+	NOTIFICATION_SENDING_SUCCESS:'NOTIFICATION_SENDING_SUCCESS',
+	/** Notification type for delivery of sent message failed */
+	NOTIFICATION_DELIVERY_FAILURE:'NOTIFICATION_DELIVERY_FAILURE',
+	/** Notification type for sending of message failed */
+	NOTIFICATION_SENDING_FAILURE:'NOTIFICATION_SENDING_FAILURE',
+	/** Notification type when phone memory is full */
+	NOTIFICATION_MEMORY_FULL:'NOTIFICATION_MEMORY_FULL',
+	/** Notification type when phone memory is available */
+	NOTIFICATION_MEMORY_AVAILABLE:'NOTIFICATION_MEMORY_AVAILABLE',
+	/** Notification type when message is deleted*/
+	NOTIFICATION_MESSAGE_DELETED:'NOTIFICATION_MESSAGE_DELETED',
+	/** Notification type when message moved */
+	NOTIFICATION_MESSAGE_SHIFT:'NOTIFICATION_MESSAGE_SHIFT',
+
+	/* Filter constants */
+	/** Defines constant to identify Message Type field for filtering */
+	FIELD_MESSAGE_TYPE:'type',
+	/** Defines constant to identify Folder Path field for filtering */
+	FIELD_FOLDER_PATH:'folder_path',
+	/** Defines constant to identify Message Handle field for filtering */
+	FIELD_HANDLE:'handle',
+	/** Defines constant to identify Sender's Email field for filtering */
+	FIELD_SENDER_EMAIL:'sender_email',
+	/** Defines constant to identify Sender's Number field for filtering */
+	FIELD_SENDER_NUMBER:'sender_number',
+
+	/**
+	 * The <code>qnx.messages.FilterExpression</code> constructor function. <code>FilterExpression</code> objects
+	 * can be used to filter the results of the <code>qnx.messages.find()</code> function.
+	 * @return {qnx.messages.FilterExpression} The <code>FilterExpression</code> constructor function.
+	 */
+	FilterExpression:FilterExpression,
+
+	/**
+	 * The <code>message.Message</code> constructor function.
+	 */
+	Message:Message,
+
+	/**
+	 * Return a list of message accounts
+	 * @param messageType {String} [optional] Filter returned accounts by supported message type.
+	 * @return {Array} The list of message accounts.
+	 * @example
+	 * [
+	 *      {
+	 *           id: 0,
+	 *           name: 'Desktop_1',
+	 *           messageTypes: ['EMAIL']
+	 *      },
+	 *      {
+	 *           id: 1,
+	 *           name: 'SMSMMS_0',
+	 *           messageTypes: ['SMS_GSM', 'MMS']
+	 *      }
+	 * ]
+	 */
+	getAccounts: function(messageType) {		
+   		var value = null,
+   			args = {},
+			success = function (data, response) {
+				value = data;
+			},
+			fail = function (data, response) {
+				throw data;
+			};
+
+		if (typeof(messageType) === 'string') {
+			args['messageType'] = messageType;
+		}
+
+		try {
+			window.cordova.exec(success, fail, _ID, 'getAccounts', args);
+		} catch (e) {
+			console.error(e);
+		}
+
+		return value;
+	},
+	
+	/**
+	 * Return an array of zero or more messages
+	 * @param {qnxcar.phonebook.filterExpression} filter [optional] The
+	 * {@link qnxcar.phonebook.filterExpression filter expression} to apply against
+	 * the phone book database.
+	 * @param {String} orderBy [optional] The field name to order by. The default order is descending,
+	 * however this can be overridden by specifying the <code>isAscending</code> parameter as 'true'. Defaults to
+	 * 'last_name'.
+	 * @param {Boolean} isAscending [optional] If an <code>orderBy</code> parameter is supplied, changes the order
+	 * direction to ascending if true, descending if false. Defaults to false.
+	 * @param {Number} limit [optional] The maximum number of Contacts to return. Defaults to -1 (no limit).
+	 * @param {Number} offset [optional] Specifies the record offset. Defaults to 0 (no offset).
+	 */
+	find:function (filter, orderBy, isAscending, limit, offset) {
+   		var value = null,
+   			args = {},
+			success = function (data, response) {
+				var messages = [];
+
+				// Build Contact instances for each result
+				for (var result in data) {
+					messages.push(new Message(data[result]));
+				}
+
+				value = messages;
+			},
+			fail = function (data, response) {
+				throw data;
+			};
+
+		if (filter instanceof FilterExpression) {
+			args['filter'] = filter;
+		}
+		if (typeof(orderBy) === 'string') {
+			args['orderBy'] = orderBy;
+		}
+		if (typeof(isAscending) === 'boolean') {
+			args['isAscending'] = isAscending;
+		}
+		if (typeof(limit) === 'number') {
+			args['limit'] = limit;
+		}
+		if (typeof(offset) === 'number') {
+			args['offset'] = offset;
+		}
+
+		try {
+			window.cordova.exec(success, fail, _ID, 'find', args);
+		} catch (e) {
+			console.error(e);
+		}
+		
+		return value;
+	},
+
+	/**
+	 * Get a list of folders by type.
+	 * @param {Number} accountId The message account ID.
+	 * @param {Number} parentFolderId [optional] The parent folder ID. If not specified, the entire folder tree is returned.
+	 */
+	getFolders:function (accountId, parentFolderId) {
+		// TODO Implement
+	},
+
+	/**
+	 * Retrieve message from the database; check first to see if message exists in database and then return it, if not initiated
+	 * PPS request to fetch message by provided message handle.
+	 * The message is returned asynchronously, and can be retrieved by listening to the <code>messageservicemessageresult</code>
+	 * event. Returns a fully populated message, including full subject, contents, recipient list, and attachments.
+	 * @param {Number} accountId The ID of the account for which the message exists
+	 * @param {String} handle Unique identifier of the message of certain type
+	 * */
+	getMessage:function (accountId, handle) {
+		window.cordova.exec(null, null, _ID, 'getMessage', { accountId: accountId, handle:handle });
+	},
+
+	/**
+	 * Return current state of the MAP
+	 * @return {String} Value which will indicate current state of the service, <code>STATE_CONNECTED</code>, <code>STATE_DISCONNECTED</code>, <code>STATE_INITIALIZING</code>
+	 */
+	getState:function () {
+   		var value = null,
+			success = function (data, response) {
+				value = data;
+			},
+			fail = function (data, response) {
+				throw data;
+			};
+			
+		try {
+			window.cordova.exec(success, fail, _ID, 'getState', null);
+		} catch (e) {
+			console.error(e);
+		}
+
+		return value;
+	}
+};
-- 
1.7.10.msysgit.1

