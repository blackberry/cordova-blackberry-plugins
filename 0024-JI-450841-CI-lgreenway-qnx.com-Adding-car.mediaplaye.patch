From ed9a5675a215617412e848cd22b742ca273d214f Mon Sep 17 00:00:00 2001
From: Marc Lapierre <marc@eternallabs.com>
Date: Fri, 30 Aug 2013 11:07:43 -0400
Subject: [PATCH 24/61] JI:450841 CI:lgreenway@qnx.com Adding car.mediaplayer
 extension and renaming car.radio extension to
 com.qnx.car.radio

---
 plugin/com.qnx.car.mediaplayer/plugin.xml          |   43 +
 .../src/blackberry10/context.js                    |   76 +
 .../src/blackberry10/index.js                      |  711 +++++++++
 .../src/blackberry10/mediaplayer.js                |  624 ++++++++
 plugin/com.qnx.car.mediaplayer/www/Event.js        |   34 +
 .../com.qnx.car.mediaplayer/www/MediaNodeType.js   |   40 +
 .../www/MediaSourceEvent.js                        |   37 +
 .../com.qnx.car.mediaplayer/www/MediaSourceType.js |   43 +
 plugin/com.qnx.car.mediaplayer/www/PlayerStatus.js |   42 +
 plugin/com.qnx.car.mediaplayer/www/RepeatMode.js   |   37 +
 plugin/com.qnx.car.mediaplayer/www/ShuffleMode.js  |   35 +
 .../www/TrackSessionEvent.js                       |   37 +
 plugin/com.qnx.car.mediaplayer/www/client.js       | 1631 ++++++++++++++++++++
 plugin/com.qnx.car.radio/plugin.xml                |   34 +
 .../com.qnx.car.radio/src/blackberry10/context.js  |   64 +
 plugin/com.qnx.car.radio/src/blackberry10/index.js |  264 ++++
 plugin/com.qnx.car.radio/src/blackberry10/radio.js |  322 ++++
 plugin/com.qnx.car.radio/www/client.js             |  637 ++++++++
 plugin/com.qnx.radio/plugin.xml                    |   34 -
 plugin/com.qnx.radio/src/blackberry10/context.js   |   64 -
 plugin/com.qnx.radio/src/blackberry10/index.js     |  264 ----
 plugin/com.qnx.radio/src/blackberry10/radio.js     |  322 ----
 plugin/com.qnx.radio/www/client.js                 |  637 --------
 plugin/com.qnx.settings/src/blackberry10/index.js  |   12 -
 24 files changed, 4711 insertions(+), 1333 deletions(-)
 create mode 100644 plugin/com.qnx.car.mediaplayer/plugin.xml
 create mode 100644 plugin/com.qnx.car.mediaplayer/src/blackberry10/context.js
 create mode 100644 plugin/com.qnx.car.mediaplayer/src/blackberry10/index.js
 create mode 100644 plugin/com.qnx.car.mediaplayer/src/blackberry10/mediaplayer.js
 create mode 100644 plugin/com.qnx.car.mediaplayer/www/Event.js
 create mode 100644 plugin/com.qnx.car.mediaplayer/www/MediaNodeType.js
 create mode 100644 plugin/com.qnx.car.mediaplayer/www/MediaSourceEvent.js
 create mode 100644 plugin/com.qnx.car.mediaplayer/www/MediaSourceType.js
 create mode 100644 plugin/com.qnx.car.mediaplayer/www/PlayerStatus.js
 create mode 100644 plugin/com.qnx.car.mediaplayer/www/RepeatMode.js
 create mode 100644 plugin/com.qnx.car.mediaplayer/www/ShuffleMode.js
 create mode 100644 plugin/com.qnx.car.mediaplayer/www/TrackSessionEvent.js
 create mode 100644 plugin/com.qnx.car.mediaplayer/www/client.js
 create mode 100644 plugin/com.qnx.car.radio/plugin.xml
 create mode 100644 plugin/com.qnx.car.radio/src/blackberry10/context.js
 create mode 100644 plugin/com.qnx.car.radio/src/blackberry10/index.js
 create mode 100644 plugin/com.qnx.car.radio/src/blackberry10/radio.js
 create mode 100644 plugin/com.qnx.car.radio/www/client.js
 delete mode 100644 plugin/com.qnx.radio/plugin.xml
 delete mode 100644 plugin/com.qnx.radio/src/blackberry10/context.js
 delete mode 100644 plugin/com.qnx.radio/src/blackberry10/index.js
 delete mode 100644 plugin/com.qnx.radio/src/blackberry10/radio.js
 delete mode 100644 plugin/com.qnx.radio/www/client.js

diff --git a/plugin/com.qnx.car.mediaplayer/plugin.xml b/plugin/com.qnx.car.mediaplayer/plugin.xml
new file mode 100644
index 0000000..451df93
--- /dev/null
+++ b/plugin/com.qnx.car.mediaplayer/plugin.xml
@@ -0,0 +1,43 @@
+<!--
+Copyright 2013  QNX Software Systems Limited
+
+Licensed under the Apache License, Version 2.0 (the "License"). You
+may not reproduce, modify or distribute this software except in
+compliance with the License. You may obtain a copy of the License
+at: http://www.apache.org/licenses/LICENSE-2.0.
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" basis,
+WITHOUT WARRANTIES OF ANY KIND, either express or implied.
+This file may contain contributions from others, either as
+contributors under the License or as licensors under other terms.
+Please review this entire file for other proprietary rights or license
+notices, as well as the applicable QNX License Guide at
+http://www.qnx.com/legal/licensing/document_archive/current_matrix.pdf
+for other information.
+-->
+<plugin xmlns="http://www.phonegap.com/ns/plugins/1.0"
+	id="com.qnx.car.mediaplayer"
+	version="1.0.0">
+	<js-module src="www/client.js">
+		<clobbers target="car.mediaplayer" />
+	</js-module>
+    <js-module src="www/Event.js" />
+    <js-module src="www/MediaNodeType.js" />
+    <js-module src="www/PlayerStatus.js" />
+    <js-module src="www/MediaSourceEvent.js" />
+    <js-module src="www/MediaSourceType.js" />
+    <js-module src="www/TrackSessionEvent.js" />
+    <js-module src="www/RepeatMode.js" />
+    <js-module src="www/ShuffleMode.js" />
+
+	<platform name="blackberry10">
+		<source-file src="src/blackberry10/index.js" />
+		<source-file src="src/blackberry10/context.js" />
+		<source-file src="src/blackberry10/mediaplayer.js" />
+   		<source-file src="www/Event.js" />
+		<config-file target="www/config.xml" parent="/widget">
+			<feature name="com.qnx.car.mediaplayer" value="com.qnx.car.mediaplayer" />
+		</config-file>
+	</platform>
+</plugin>
diff --git a/plugin/com.qnx.car.mediaplayer/src/blackberry10/context.js b/plugin/com.qnx.car.mediaplayer/src/blackberry10/context.js
new file mode 100644
index 0000000..ad93430
--- /dev/null
+++ b/plugin/com.qnx.car.mediaplayer/src/blackberry10/context.js
@@ -0,0 +1,76 @@
+/*
+ * Copyright 2013  QNX Software Systems Limited
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"). You
+ * may not reproduce, modify or distribute this software except in
+ * compliance with the License. You may obtain a copy of the License
+ * at: http://www.apache.org/licenses/LICENSE-2.0.
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTIES OF ANY KIND, either express or implied.
+ * This file may contain contributions from others, either as
+ * contributors under the License or as licensors under other terms.
+ * Please review this entire file for other proprietary rights or license
+ * notices, as well as the applicable QNX License Guide at
+ * http://www.qnx.com/legal/licensing/document_archive/current_matrix.pdf
+ * for other information.
+ */
+
+/**
+ * The event context for car.mediaplayer.
+ */
+
+var _mediaplayer = require("./mediaplayer"),
+	Event = require('./Event');
+
+/**
+ * Sets or removes the specified event trigger.
+ * @param event {String} The event name
+ * @param trigger {Function} The trigger function to call when the event is fired. Null if removing the trigger.
+ */
+function setListener(event, trigger) {
+	switch (event) {
+		case Event.MEDIA_SOURCE_CHANGE:
+			_mediaplayer.setMediaSourceChangeTrigger(trigger);
+			break;
+		case Event.TRACK_SESSION_CHANGE:
+			_mediaplayer.setTrackSessionChangeTrigger(trigger);
+			break;
+		case Event.PLAYER_STATE_CHANGE:
+			_mediaplayer.setPlayerStateChangeTrigger(trigger);
+			break;
+		case Event.TRACK_CHANGE:
+			_mediaplayer.setTrackChangeTrigger(trigger);
+			break;
+		case Event.TRACK_POSITION_CHANGE:
+			_mediaplayer.setTrackPositionChangeTrigger(trigger);
+			break;
+	}
+}
+
+/**
+ * Exports are the publicly accessible functions
+ */
+module.exports = {
+	/**
+	 * Method called when the first listener is added for an event
+	 * @param event {String} The event name
+	 * @param trigger {Function} The trigger function to call when the event is fired
+	 */
+	addEventListener: function (event, trigger) {
+		if (event && trigger) {
+			setListener(event, trigger);
+		}
+	},
+
+	/**
+	 * Method called when the last listener is removed for an event
+	 * @param event {String} The event name
+	 */
+	removeEventListener: function (event) {
+		if (event) {
+			setListener(event, null);
+		}
+	}
+};
diff --git a/plugin/com.qnx.car.mediaplayer/src/blackberry10/index.js b/plugin/com.qnx.car.mediaplayer/src/blackberry10/index.js
new file mode 100644
index 0000000..29254f2
--- /dev/null
+++ b/plugin/com.qnx.car.mediaplayer/src/blackberry10/index.js
@@ -0,0 +1,711 @@
+/*
+ * Copyright 2013  QNX Software Systems Limited
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"). You
+ * may not reproduce, modify or distribute this software except in
+ * compliance with the License. You may obtain a copy of the License
+ * at: http://www.apache.org/licenses/LICENSE-2.0.
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTIES OF ANY KIND, either express or implied.
+ * This file may contain contributions from others, either as
+ * contributors under the License or as licensors under other terms.
+ * Please review this entire file for other proprietary rights or license
+ * notices, as well as the applicable QNX License Guide at
+ * http://www.qnx.com/legal/licensing/document_archive/current_matrix.pdf
+ * for other information.
+ */
+
+/**
+ * car.mediaplayer index.js.
+ * Responsible for defining the blackberry.event action map, initializing the mediaplayer.js implementation,
+ * and routing synchronous and asynchronous calls to the mediaplayer.js implementation.
+ */
+
+var _wwfix = require("../../lib/wwfix"),
+	_mediaplayer = require("./mediaplayer"),
+	_context = require("./context"),
+	_eventResults = {};
+
+/**
+ * Utility function which validates the existence and proper typing of an arguments object, as well as to define default values
+ * on for omitted optional arguments.
+ * @param {Object} args The arguments object.
+ * @param {Object} config The argument configuration object.
+ * @returns {Boolean} True if the arguments pass validation against the configuration, False if not.
+ * @private
+ */
+function validateArguments(args, config) {
+	var valid = true;
+
+	// Validate function arguments
+	if(typeof args !== 'object' || typeof config !== 'object') {
+		console.error('car.mediaplayer/index.js::validateArguments - Invalid arguments.');
+		throw new TypeError('Invalid arguments.');
+	}
+	
+	// Iterate through each item in the configuration object
+	for(var name in config) {
+		var type = config[name].type,
+			nullable = config[name].nullable,
+			optional = config[name].optional,
+			defaultValue = config[name].defaultValue;
+		
+		// Set the default value if the argument is optional and undefined
+		if(args[name] === undefined && optional && defaultValue !== undefined) {
+			args[name] = defaultValue;
+		}
+		
+		// Validate the argument
+		if((args[name] === undefined && !optional)
+			|| (typeof args[name] !== type && (!nullable || nullable && args[name] !== null))) {
+			console.warn('car.mediaplayer/index.js::validateArguments - ' +
+					'Invalid value ' + args[name] +
+					' for argument ' + name + '.' +
+					' Configuration: ' + JSON.stringify(config[name]));
+			valid = false;
+			break;
+		}
+	}
+	
+	return valid;
+}
+
+/**
+ * Initializes the extension
+ */
+function init() {
+	try {
+		_mediaplayer.init();
+	} catch (ex) {
+		console.error('Error in webworks ext: mediaplayer/index.js::init():', ex);
+	}
+}
+
+// Initialize immediately
+init();
+
+/**
+ * Exports are the publicly accessible functions
+ */
+module.exports = {
+
+	/**
+	 * Turn on event dispatching for a specific event name
+	 * @param {Function} success Function to call if the operation is a success
+	 * @param {Function} fail Function to call if the operation fails
+	 * @param {Object} args The arguments supplied
+	 * @param {Object} env Environment variables
+	 */
+	startEvent: function (success, fail, args, env) {
+		var result = new PluginResult(args, env)
+		var fixedArgs = _wwfix.parseArgs(args);
+		try {
+			if (fixedArgs && fixedArgs.eventName) {
+				_eventResults[fixedArgs.eventName] = result;
+				_context.addEventListener(fixedArgs.eventName, function (data) {
+					result.callbackOk(data, true);
+				});
+				result.noResult(true);
+			} else {
+				throw "Invalid eventName";
+			}
+		} catch (e) {
+			result.error("error in startEvent: " + JSON.stringify(e), false);
+		}
+   },
+
+	/**
+	 * Turn off event dispatching for a specific event name
+	 * @param {Function} success Function to call if the operation is a success
+	 * @param {Function} fail Function to call if the operation fails
+	 * @param {Object} args The arguments supplied
+	 * @param {Object} env Environment variables
+	 */
+	stopEvent: function (success, fail, args, env) {
+		var result = new PluginResult(args, env);
+		var fixedArgs = _wwfix.parseArgs(args);
+		try {
+			if (fixedArgs && fixedArgs.eventName) {
+				//disable the event trigger
+				_context.removeEventListener(fixedArgs.eventName);
+				result.ok(undefined, false);
+
+				//cleanup
+				_eventResults[fixedArgs.eventName].noResult(false);
+				delete _eventResults[fixedArgs.eventName];
+			} else {
+				throw "Invalid eventName";
+			}
+		} catch (e) {
+			result.error("error in stopEvent: " + JSON.stringify(e), false);
+		}
+	},
+
+	/**
+	 * Opens the specified player name.
+	 * @param success {Function} Function to call if the operation is a success
+	 * @param fail {Function} Function to call if the operation fails
+	 * @param args {Object} The arguments supplied. Available arguments for this call are:
+	 *	{
+	 *		playerName: {String}
+	 *	}
+	 * @param env {Object} Environment variables
+	 */
+	open: function(success, fail, args, env) {
+		var result = new PluginResult(args, env)
+		var fixedArgs = _wwfix.parseArgs(args);
+		try {
+			_mediaplayer.open(fixedArgs.playerName)
+			result.ok(undefined, false);
+		} catch (e) {
+			result.error(JSON.stringify(e), false);
+		}
+	},
+	
+	/**
+	 * Closes the specified player name.
+	 * @param success {Function} Function to call if the operation is a success
+	 * @param fail {Function} Function to call if the operation fails
+	 * @param args {Object} The arguments supplied. Available arguments for this call are:
+	 *	{
+	 *		playerName: {String}
+	 *	}
+	 * @param env {Object} Environment variables
+	 */
+	close: function(success, fail, args, env) {
+		var result = new PluginResult(args, env)
+		var fixedArgs = _wwfix.parseArgs(args);
+		try {
+			_mediaplayer.close(fixedArgs.playerName)
+			result.ok(undefined, false);
+		} catch (e) {
+			result.error(JSON.stringify(e), false);
+		}
+	},
+	
+	/**
+	 * Returns the list of available media sources connected to the device.
+	 * @param success {Function} Function to call if the operation is a success
+	 * @param fail {Function} Function to call if the operation fails
+	 * @param args {Object} The arguments supplied.
+	 * @param env {Object} Environment variables
+	 */
+	getMediaSources: function(success, fail, args, env) {
+		var result = new PluginResult(args, env)
+		var fixedArgs = _wwfix.parseArgs(args);
+		try {
+			_mediaplayer.getMediaSources(function(data) {
+				result.callbackOk(data, false);
+			}, function(data) {
+				result.callbackError(data, false);
+			});
+			result.noResult(true);
+		} catch (e) {
+			result.error(JSON.stringify(e), false);
+		}
+	},
+	
+	/**
+	 * Browse a media source for media.
+	 * @param success {Function} Function to call if the operation is a success
+	 * @param fail {Function} Function to call if the operation fails
+	 * @param args {Object} The arguments supplied. Available arguments for this call are:
+	 *	{
+	 *		mediaSourceId: {Number},
+	 *		mediaNodeId: {String},
+	 *		limit: {Number},
+	 *		offset: {Number}
+	 *	}
+	 * @param env {Object} Environment variables
+	 */
+	browse: function(success, fail, args, env) {
+		var result = new PluginResult(args, env)
+		var fixedArgs = _wwfix.parseArgs(args);
+		try {
+			_mediaplayer.browse(function(data) {
+				result.callbackOk(data, false);
+			}, function(data) {
+				result.callbackError(data, false);
+			},
+			fixedArgs.mediaSourceId,
+			fixedArgs.mediaNodeId,
+			fixedArgs.limit,
+			fixedArgs.offset);
+
+			result.noResult(true);
+		} catch (e) {
+			result.error(JSON.stringify(e), false);
+		}
+	},
+	
+	/**
+	 * Search for media items in a specific media source.
+	 * @param success {Function} Function to call if the operation is a success
+	 * @param fail {Function} Function to call if the operation fails
+	 * @param args {Object} The arguments supplied. Available arguments for this call are:
+	 *	{
+	 *		mediaSourceId: {Number},
+	 *		mediaNodeId: {String},
+	 *		searchTerm: {String},
+	 *		limit: {Number},
+	 *		offset: {Number}
+	 *	}
+	 * @param env {Object} Environment variables
+	 */
+	search: function(success, fail, args, env) {
+		var result = new PluginResult(args, env)
+		var fixedArgs = _wwfix.parseArgs(args);
+		try {
+			_mediaplayer.search(function(data) {
+				result.callbackOk(data, false);
+			}, function(data) {
+				result.callbackError(data, false);
+			},
+			fixedArgs.mediaSourceId,
+			fixedArgs.mediaNodeId,
+			fixedArgs.searchTerm,
+			fixedArgs.limit,
+			fixedArgs.offset);
+
+			result.noResult(true);
+		} catch (e) {
+			result.error(JSON.stringify(e), false);
+		}
+	},
+	
+	/**
+	 * Creates a new track session.
+	 * @param success {Function} Function to call if the operation is a success
+	 * @param fail {Function} Function to call if the operation fails
+	 * @param args {Object} The arguments supplied
+	 * @param env {Object} Environment variables
+	 */
+	createTrackSession: function(success, fail, args, env) {
+		var result = new PluginResult(args, env)
+		var fixedArgs = _wwfix.parseArgs(args);
+		try {
+			if(!validateArguments(fixedArgs, {
+				mediaSourceId: { type: 'number' },
+				mediaNodeId: { type: 'string', nullable: true, optional: true, defaultValue: null },
+				index: { type: 'number', optional: true, defaultValue: 0 },
+				limit: { type: 'number', optional: true, defaultValue: -1 },
+				offset: { type: 'number', optional: true, defaultValue: 0 }
+			})) {
+				fail(-1, 'Invalid arguments.');
+			} else {
+				_mediaplayer.createTrackSession(function(data) {
+					result.callbackOk(data, false);
+				}, function(data) {
+					result.callbackError(data, false);
+				},
+				fixedArgs.mediaSourceId,
+				fixedArgs.mediaNodeId,
+				fixedArgs.index,
+				fixedArgs.limit,
+				fixedArgs.offset);
+			}
+			result.noResult(true);
+		} catch (e) {
+			result.error(JSON.stringify(e), false);
+		}
+	},
+	
+	/**
+	 * Destroys an existing track session.
+	 * @param success {Function} Function to call if the operation is a success
+	 * @param fail {Function} Function to call if the operation fails
+	 * @param args {Object} The arguments supplied. Available arguments for this call are:
+	 *	{
+	 *		trackSessionId: {Number}
+	 *	}
+	 * @param env {Object} Environment variables
+	 */
+	destroyTrackSession: function(success, fail, args, env) {
+		var result = new PluginResult(args, env)
+		var fixedArgs = _wwfix.parseArgs(args);
+		try {
+			_mediaplayer.destroyTrackSession(fixedArgs.trackSessionId);
+			result.ok(undefined, false);
+		} catch (e) {
+			result.error(JSON.stringify(e), false);
+		}
+	},
+	
+	/**
+	 * Retrieves the current track session information.
+	 * @param success {Function} Function to call if the operation is a success
+	 * @param fail {Function} Function to call if the operation fails
+	 * @param args {Object} The arguments supplied.
+	 * @param env {Object} Environment variables
+	 */
+	getTrackSessionInfo: function(success, fail, args, env) {
+		var result = new PluginResult(args, env)
+		var fixedArgs = _wwfix.parseArgs(args);
+		try {
+			_mediaplayer.getTrackSessionInfo(function(data) {
+				result.callbackOk(data, false);
+			}, function(data) {
+				result.callbackError(data, false);
+			});
+			result.noResult(true);
+		} catch (e) {
+			result.error(JSON.stringify(e), false);
+		}
+	},
+	
+	/**
+	 * Retrieves media from the current track session.
+	 * @param success {Function} Function to call if the operation is a success
+	 * @param fail {Function} Function to call if the operation fails
+	 * @param args {Object} The arguments supplied. Available arguments for this call are:
+	 *	{
+	 *		limit: {Number},
+	 *		offset: {Number}
+	 *	}
+	 * @param env {Object} Environment variables
+	 */
+	getTrackSessionItems: function(success, fail, args, env) {
+		var result = new PluginResult(args, env)
+		var fixedArgs = _wwfix.parseArgs(args);
+		try {
+			_mediaplayer.getTrackSessionItems(function(data) {
+				result.callbackOk(data, false);
+			}, function(data) {
+				result.callbackError(data, false);
+			},
+			fixedArgs.limit,
+			fixedArgs.offset);
+	
+			result.noResult(true);
+		} catch (e) {
+			result.error(JSON.stringify(e), false);
+		}
+	},
+	
+	/**
+	 * Retrieves the currently playing track information.
+	 * @param success {Function} Function to call if the operation is a success
+	 * @param fail {Function} Function to call if the operation fails
+	 * @param args {Object} The arguments supplied.
+	 * @param env {Object} Environment variables
+	 */
+	getCurrentTrack: function(success, fail, args, env) {
+		var result = new PluginResult(args, env)
+		var fixedArgs = _wwfix.parseArgs(args);
+		try {
+			_mediaplayer.getCurrentTrack(function(data) {
+				result.callbackOk(data, false);
+			}, function(data) {
+				result.callbackError(data, false);
+			});
+	
+			result.noResult(true);
+		} catch (e) {
+			result.error(JSON.stringify(e), false);
+		}
+	},
+
+	/**
+	 * Retrieve the current playback position, in milliseconds, of the current track.
+	 * @param success {Function} Function to call if the operation is a success
+	 * @param fail {Function} Function to call if the operation fails
+	 * @param args {Object} The arguments supplied.
+	 * @param env {Object} Environment variables
+	 */
+	getCurrentTrackPosition: function(success, fail, args, env) {
+		var result = new PluginResult(args, env)
+		var fixedArgs = _wwfix.parseArgs(args);
+		try {
+			_mediaplayer.getCurrentTrackPosition(function(data) {
+				result.callbackOk(data, false);
+			}, function(data) {
+				result.callbackError(data, false);
+			});
+	
+			result.noResult(true);
+		} catch (e) {
+			result.error(JSON.stringify(e), false);
+		}
+	},
+	
+	/**
+	 * Retrieves metadata for specified media.
+	 * @param success {Function} Function to call if the operation is a success
+	 * @param fail {Function} Function to call if the operation fails
+	 * @param args {Object} The arguments supplied. Available arguments for this call are:
+	 *	{
+	 *		mediaSourceId: {Number},
+	 *		mediaNodeId: {String}
+	 *	}
+	 * @param env {Object} Environment variables
+	 */
+	getMetadata: function(success, fail, args, env) {
+		var result = new PluginResult(args, env)
+		var fixedArgs = _wwfix.parseArgs(args);
+		try {
+			_mediaplayer.getMetadata(function(data) {
+				result.callbackOk(data, false);
+			}, function(data) {
+				result.callbackError(data, false);
+			},
+			fixedArgs.mediaSourceId,
+			fixedArgs.mediaNodeId);
+	
+			result.noResult(true);
+		} catch (e) {
+			result.error(JSON.stringify(e), false);
+		}
+	},
+
+	/**
+	 * Retrieves extended metadata properties for the specified media.
+	 * @param success {Function} Function to call if the operation is a success
+	 * @param fail {Function} Function to call if the operation fails
+	 * @param args {Object} The arguments supplied. Available arguments for this call are:
+	 *	{
+	 *		mediaSourceId: {Number},
+	 *		mediaNodeId: {String},
+	 *		properties: {String[]}
+	 *	}
+	 * @param env {Object} Environment variables
+	 */
+	getExtendedMetadata: function(success, fail, args, env) {
+		var result = new PluginResult(args, env)
+		var fixedArgs = _wwfix.parseArgs(args);
+		try {
+			_mediaplayer.getExtendedMetadata(function(data) {
+				result.callbackOk(data, false);
+			}, function(data) {
+				result.callbackError(data, false);
+			},
+			fixedArgs.mediaSourceId,
+			fixedArgs.mediaNodeId,
+			fixedArgs.properties);
+	
+			result.noResult(true);
+		} catch (e) {
+			result.error(JSON.stringify(e), false);
+		}
+	},
+	
+	/**
+	 * Returns the state of the media player.
+	 * @param success {Function} Function to call if the operation is a success
+	 * @param fail {Function} Function to call if the operation fails
+	 * @param args {Object} The arguments supplied.
+	 * @param env {Object} Environment variables
+	 */
+	getPlayerState: function(success, fail, args, env) {
+		var result = new PluginResult(args, env)
+		var fixedArgs = _wwfix.parseArgs(args);
+		try {
+			_mediaplayer.getPlayerState(function(data) {
+				result.callbackOk(data, false);
+			}, function(data) {
+				result.callbackError(data, false);
+			});
+	
+			result.noResult(true);
+		} catch (e) {
+			result.error(JSON.stringify(e), false);
+		}
+	},
+	
+	/**
+	 * Play or resume playback.
+	 * @param success {Function} Function to call if the operation is a success
+	 * @param fail {Function} Function to call if the operation fails
+	 * @param args {Object} The arguments supplied.
+	 * @param env {Object} Environment variables
+	 */
+	play: function(success, fail, args, env) {
+		var result = new PluginResult(args, env)
+		var fixedArgs = _wwfix.parseArgs(args);
+		try {
+			_mediaplayer.play();
+			result.ok(undefined, false);
+		} catch (e) {
+			result.error(JSON.stringify(e), false);
+		}
+	},
+	
+	/**
+	 * Pause playback.
+	 * @param success {Function} Function to call if the operation is a success
+	 * @param fail {Function} Function to call if the operation fails
+	 * @param args {Object} The arguments supplied. Available arguments for this call are: N/A
+	 * @param env {Object} Environment variables
+	 */
+	pause: function(success, fail, args, env) {
+		var result = new PluginResult(args, env)
+		var fixedArgs = _wwfix.parseArgs(args);
+		try {
+			_mediaplayer.pause();
+			result.ok(undefined, false);
+		} catch (e) {
+			result.error(JSON.stringify(e), false);
+		}
+	},
+	
+	/**
+	 * Stop playback.
+	 * @param success {Function} Function to call if the operation is a success
+	 * @param fail {Function} Function to call if the operation fails
+	 * @param args {Object} The arguments supplied. Available arguments for this call are: N/A
+	 * @param env {Object} Environment variables
+	 */
+	stop: function(success, fail, args, env) {
+		var result = new PluginResult(args, env)
+		var fixedArgs = _wwfix.parseArgs(args);
+		try {
+			_mediaplayer.resume();
+			result.ok(undefined, false);
+		} catch (e) {
+			result.error(JSON.stringify(e), false);
+		}
+	},
+	
+	/**
+	 * Skip to the next track in the active track session.
+	 * @param success {Function} Function to call if the operation is a success
+	 * @param fail {Function} Function to call if the operation fails
+	 * @param args {Object} The arguments supplied. Available arguments for this call are: N/A
+	 * @param env {Object} Environment variables
+	 */
+	next: function(success, fail, args, env) {
+		var result = new PluginResult(args, env)
+		var fixedArgs = _wwfix.parseArgs(args);
+		try {
+			_mediaplayer.next();
+			result.ok(undefined, false);
+		} catch (e) {
+			result.error(JSON.stringify(e), false);
+		}
+	},
+	
+	/**
+	 * Skip to the previous track in the active track session.
+	 * @param success {Function} Function to call if the operation is a success
+	 * @param fail {Function} Function to call if the operation fails
+	 * @param args {Object} The arguments supplied. Available arguments for this call are: N/A
+	 * @param env {Object} Environment variables
+	 */
+	previous: function(success, fail, args, env) {
+		var result = new PluginResult(args, env)
+		var fixedArgs = _wwfix.parseArgs(args);
+		try {
+			_mediaplayer.previous();
+			result.ok(undefined, false);
+		} catch (e) {
+			result.error(JSON.stringify(e), false);
+		}
+	},
+	
+	/**
+	 * Jumps to the specified index in the current track session.
+	 * @param success {Function} Function to call if the operation is a success
+	 * @param fail {Function} Function to call if the operation fails
+	 * @param args {Object} The arguments supplied. Available arguments for this call are:
+	 *	{
+	 *		index: {Number}
+	 *	}
+	 * @param env {Object} Environment variables
+	 */
+	jump: function(success, fail, args, env) {
+		var result = new PluginResult(args, env)
+		var fixedArgs = _wwfix.parseArgs(args);
+		try {
+			_mediaplayer.jump(fixedArgs.index);
+			result.ok(undefined, false);
+		} catch (e) {
+			result.error(JSON.stringify(e), false);
+		}
+	},
+	
+	/**
+	 * Seek to a specific position in the current track.
+	 * @param success {Function} Function to call if the operation is a success
+	 * @param fail {Function} Function to call if the operation fails
+	 * @param args {Object} The arguments supplied. Available arguments for this call are:
+	 *	{
+	 *		position: {Number}
+	 *	}
+	 * @param env {Object} Environment variables
+	 */
+	seek: function(success, fail, args, env) {
+		var result = new PluginResult(args, env)
+		var fixedArgs = _wwfix.parseArgs(args);
+		try {
+			_mediaplayer.seek(fixedArgs.position);
+			result.ok(undefined, false);
+		} catch (e) {
+			result.error(JSON.stringify(e), false);
+		}
+	},
+	
+	/**
+	 * Set the playback rate of the media player.
+	 * @param success {Function} Function to call if the operation is a success
+	 * @param fail {Function} Function to call if the operation fails
+	 * @param args {Object} The arguments supplied. Available arguments for this call are:
+	 *	{
+	 *		playbackRate: {Number}
+	 *	}
+	 * @param env {Object} Environment variables
+	 */
+	setPlaybackRate: function(success, fail, args, env) {
+		var result = new PluginResult(args, env)
+		var fixedArgs = _wwfix.parseArgs(args);
+		try {
+			_mediaplayer.setPlaybackRate(fixedArgs.playbackRate);
+			result.ok(undefined, false);
+		} catch (e) {
+			result.error(JSON.stringify(e), false);
+		}
+	},
+	
+	/**
+	 * Set the shuffle mode for the active track session.
+	 * @param success {Function} Function to call if the operation is a success
+	 * @param fail {Function} Function to call if the operation fails
+	 * @param args {Object} The arguments supplied. Available arguments for this call are:
+	 *	{
+	 *		shuffleMode: {MediaPlayer.ShuffleMode}
+	 *	}
+	 * @param env {Object} Environment variables
+	 */
+	shuffle: function(success, fail, args, env) {
+		var result = new PluginResult(args, env)
+		var fixedArgs = _wwfix.parseArgs(args);
+		try {
+			_mediaplayer.shuffle(fixedArgs.shuffleMode);
+			result.ok(undefined, false);
+		} catch (e) {
+			result.error(JSON.stringify(e), false);
+		}
+	},
+	
+	/**
+	 * Set the repeat mode for the active track session.
+	 * @param success {Function} Function to call if the operation is a success
+	 * @param fail {Function} Function to call if the operation fails
+	 * @param args {Object} The arguments supplied. Available arguments for this call are:
+	 *	{
+	 *		repeatMode: {MediaPlayer.RepeatMode}
+	 *	}
+	 * @param env {Object} Environment variables
+	 */
+	repeat: function(success, fail, args, env) {
+		var result = new PluginResult(args, env)
+		var fixedArgs = _wwfix.parseArgs(args);
+		try {
+			_mediaplayer.repeat(fixedArgs.repeatMode);
+			result.ok(undefined, false);
+		} catch (e) {
+			result.error(JSON.stringify(e), false);
+		}
+	},
+};
+
diff --git a/plugin/com.qnx.car.mediaplayer/src/blackberry10/mediaplayer.js b/plugin/com.qnx.car.mediaplayer/src/blackberry10/mediaplayer.js
new file mode 100644
index 0000000..4cd228c
--- /dev/null
+++ b/plugin/com.qnx.car.mediaplayer/src/blackberry10/mediaplayer.js
@@ -0,0 +1,624 @@
+/*
+ * Copyright 2013  QNX Software Systems Limited
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"). You
+ * may not reproduce, modify or distribute this software except in
+ * compliance with the License. You may obtain a copy of the License
+ * at: http://www.apache.org/licenses/LICENSE-2.0.
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTIES OF ANY KIND, either express or implied.
+ * This file may contain contributions from others, either as
+ * contributors under the License or as licensors under other terms.
+ * Please review this entire file for other proprietary rights or license
+ * notices, as well as the applicable QNX License Guide at
+ * http://www.qnx.com/legal/licensing/document_archive/current_matrix.pdf
+ * for other information.
+ */
+
+/**
+ * car.mediaplayer mediaplayer.js.
+ * Responsible for interfacing with the jPlayer JNEXT plugin.
+ */
+
+var _jPlayer = require('../../lib/jPlayer'),
+	_jPlayerObj = null,
+	_callbackCounter = 0,
+	_callbackFunctions = {},
+	_mediaSourceChangeTrigger = null,
+	_trackSessionChangeTrigger = null,
+	_playerStateChangeTrigger = null,
+	_trackChangeTrigger = null,
+	_trackPositionChangeTrigger = null;
+
+// Constants
+var ROOT_MEDIA_NODE_ID = '/';
+
+// mm_player state variables
+/**
+ * Flag indicating that cached state has been initialized. Prevents unnecessary initialization calls if
+ * multiple open operations for the same player are performed.
+ */
+var _stateCacheInitialized = false;
+
+/**
+ * Stores the current track session ID. This assumes that a maximum of one player is open at any given time.
+ */
+var _currentTrackSessionId = null;
+
+/**
+ * Registers success and fail callback functions, returning a unique callback identifier.
+ * @param {Function} success The success callback function.
+ * @param {Function} fail The failure callback function.
+ * @returns {String} The unique callback ID.
+ */
+function registerCallbackFunctions(success, fail) {
+	_callbackCounter++;
+	_callbackFunctions[_callbackCounter] = {
+		success: success,
+		fail: fail
+	};
+	return String(_callbackCounter);
+}
+
+/**
+ * Triggers a response event with the respnse ID given in the event data.
+ * @param {Object} event The response event object.
+ */
+var emitResponseEvent = function(event) {
+	console.log('car.mediaplayer/mediaplayer.js::emitResponseEvent', event);
+	// We need at least an event payload with an id property so we can fire our response event
+	if(event && event.id) {
+		if(_callbackFunctions[event.id]) {
+			try {
+				if(event.data !== undefined && event.data !== null) {
+					console.log('car.mediaplayer/mediaplayer.js::emitResponseEvent - Calling success callback for request with ID ' + event.id);
+					_callbackFunctions[event.id].success(event.data);
+				} else if(event.error) {
+					console.log('car.mediaplayer/mediaplayer.js::emitResponseEvent - Calling fail callback for request with ID ' + event.id, _callbackFunctions[event.id].fail);
+					_callbackFunctions[event.id].fail(
+						typeof event.error.code === 'number' ? event.error.code : -1,
+						typeof event.error.msg === 'string' ? event.error.msg : 'Unknown error');
+				} else {
+					console.log('car.mediaplayer/mediaplayer.js::emitResponseEvent - Calling fail callback for request with ID ' + event.id, _callbackFunctions[event.id].fail);
+					_callbackFunctions[event.id].fail(-1, 'No event data returned for asynchronous response with ID ' + event.id);
+				}
+			} catch(ex) {
+				console.log('car.mediaplayer/mediaplayer.js::emitResponseEvent - Calling fail callback for request with ID ' + event.id, _callbackFunctions[event.id].fail);
+				_callbackFunctions[event.id].fail(-1, ex.message);
+			} finally {
+				delete _callbackFunctions[event.id];
+			}
+		} else {
+			console.error('car.mediaplayer/mediaplayer.js::emitResponseEvent - Callback not registered for event with ID ' + event.id);
+		}
+	} else {
+		console.error('car.mediaplayer/mediaplayer.js::emitResponseEvent - Insufficient event information to invoke callback');
+	}
+};
+
+/**
+ * Translates the media source as supplied from jPlayer into the data structure
+ * expected to clients of the extension/plugin.
+ * @param {Object} mediaSource The jPlayer media source data structure.
+ * @returns {Object} The translated media source data structure.
+ * @private
+ */
+var translateMediaSource = function(mediaSource) {
+	if(mediaSource && typeof mediaSource === 'object') {
+		// Status
+		if(mediaSource.hasOwnProperty('status')) {
+			// Translate the media source status property into a ready flag. As long as at least the first
+			// pass has been completed, consider the media source ready.
+			mediaSource.ready = mediaSource.status !== _jPlayerObj.MediaSourceStatus.MS_STATUS_NOT_READY;
+			
+			// Remove the status property since we don't want it exposed
+			delete mediaSource.status;
+		}
+	}
+	
+	return mediaSource;
+};
+
+/**
+ * jPlayer onMediaSourceChange callback handler. Translates the media source data structures before calling the
+ * media source change trigger.
+ * @param {Object} event onMediaSourceChange jPlayer event data object.
+ * @private
+ */
+var onMediaSourceChange = function(event) {
+	console.log('car.mediaplayer/mediaplayer.js::onMediaSourceChange', event);
+
+	if(event && event.mediaSource) {
+		event.mediaSource = translateMediaSource(event.mediaSource);
+	}
+	
+	_mediaSourceChangeTrigger && _mediaSourceChangeTrigger(event);
+};
+
+/**
+ * jPlayer onTrackSessionChange callback handler. Updates the current track session ID state cache and then calls the
+ * track session change trigger, if it exists.
+ * @param {Object} event onTrackSessionChange jPlayer event data object.
+ * @private
+ */
+var onTrackSessionChange = function(event) {
+	console.log('car.mediaplayer/mediaplayer.js::onTrackSessionChange', event);
+	// jPlayer implementation currently only has one track session being active at a time, so 
+	// we can store track session change created event data as the current track session ID.
+	// Holding on to the current track session ID allows us to automatically use this data to perform
+	// jump and getTrackSessionItems calls on the current track session automatically.
+	if(typeof event === 'object'
+			&& event.hasOwnProperty('type')
+			&& event.hasOwnProperty('trackSessionId')) {
+		if(event.type === _jPlayerObj.TrackSessionEvent.CREATED) {
+			_currentTrackSessionId = event.trackSessionId;
+		} else if(event.type === _jPlayerObj.TrackSessionEvent.DESTROYED && event.trackSessionId === _currentTrackSessionId) {
+			_currentTrackSessionId = null;
+		}
+	}	
+	
+	// Call the track position change trigger if it exists
+	_trackSessionChangeTrigger && _trackSessionChangeTrigger(event);
+};
+
+/**
+ * emitMediaSourcesResponse interceptor handler. Translates the jPlayer media source data structure before
+ * emitting the response event.
+ * @param event {Object} The emitMediaSourcesResponse object. 
+ * @private
+ */
+var emitMediaSourcesResponse = function(event) {
+	console.log('car.mediaplayer/mediaplayer.js::emitMediaSourcesResponse', event);
+	
+	// Modify each media source in the result
+	if(event && event.data && typeof event.data.length === 'number') {
+		for(var i = 0; i < event.data.length; i++) {
+			event.data[i] = translateMediaSource(event.data[i]);
+		}
+	}
+	
+	emitResponseEvent(event);
+};
+
+/**
+ * Current track session information initialization success handler. Updates the local currentTrackSessionId state.
+ * @param event {Object} The emitCurrentTrackSessionInfoResponse object. 
+ * @private
+ */
+var initializeCurrentTrackSessionInfo = function(event) {
+	console.log('car.mediaplayer/mediaplayer.js::initializeCurrentTrackSessionInfo', event);
+	// Update the current track session ID
+	_currentTrackSessionId = event.data ? event.data.trackSessionId : null;
+};
+
+/**
+ * Exports are the publicly accessible functions
+ */
+module.exports = {
+	/**
+	 * Initializes the extension,
+	 * open and initialise required PPS object and event handlers
+	 */
+	init:function () {
+		try {
+			_jPlayerObj = _jPlayer.createObject();
+		} catch(ex) {
+			console.error('car.mediaplayer.mediaplayer.js::init - Could not create jPlayer object.');
+		}
+			
+		if(_jPlayerObj) {
+			// Attach result callback handlers
+			_jPlayerObj.onMediaSourcesResult			= emitMediaSourcesResponse;
+			_jPlayerObj.onBrowseResult					= emitResponseEvent;
+			_jPlayerObj.onCurrentTrackInfoResult		= emitResponseEvent;
+			_jPlayerObj.onCurrentTrackPositionResult	= emitResponseEvent;
+			_jPlayerObj.onMetadataResult				= emitResponseEvent;
+			_jPlayerObj.onExtendedMetadataResult		= emitResponseEvent;
+			_jPlayerObj.onCreateTrackSessionResult		= emitResponseEvent;
+			_jPlayerObj.onCurrentTrackSessionInfoResult	= emitResponseEvent;
+			_jPlayerObj.onTrackSessionItemsResult		= emitResponseEvent;
+			_jPlayerObj.onSearchResult					= emitResponseEvent;
+			_jPlayerObj.onPlayerStateResult				= emitResponseEvent;
+			
+			// Attach async callback handlers
+			_jPlayerObj.onMediaSourceChange = onMediaSourceChange;
+			_jPlayerObj.onTrackSessionChange = onTrackSessionChange;
+			_jPlayerObj.onPlayerStateChange = function(event) { _playerStateChangeTrigger && _playerStateChangeTrigger(event); };
+			_jPlayerObj.onTrackChange = function(event) { _trackChangeTrigger && _trackChangeTrigger(event); };
+			_jPlayerObj.onTrackPositionChange = function(event) { _trackPositionChangeTrigger && _trackPositionChangeTrigger(event); };
+		}
+	},
+	
+	// Debug
+	invokeDummyEvent: function(name, data) {
+		console.log('car.mediaplayer/mediaplayer.js::invokeDummyEvent', data);
+		if(_jPlayerObj) {
+			_jPlayerObj.invokeDummyEvent(name, data);
+		}
+	},
+	
+	/**
+	 * Sets the media source change event trigger.
+	 * @param {Function} trigger The event trigger function.
+	 */
+	setMediaSourceChangeTrigger: function(trigger) {
+		console.log('car.mediaplayer/mediaplayer.js::setMediaSourceChangeTrigger', trigger);
+		_mediaSourceChangeTrigger = trigger;
+	},
+	
+	/**
+	 * Sets the track session change event trigger.
+	 * @param {Function} trigger The event trigger function.
+	 */
+	setTrackSessionChangeTrigger: function(trigger) {
+		console.log('car.mediaplayer/mediaplayer.js::setTrackSessionChangeTrigger', trigger);
+		_trackSessionChangeTrigger = trigger;
+	},
+
+	/**
+	 * Sets the player state change event trigger.
+	 * @param {Function} trigger The event trigger function.
+	 */
+	setPlayerStateChangeTrigger: function(trigger) {
+		console.log('car.mediaplayer/mediaplayer.js::setPlayerStateChangeTrigger', trigger);
+		_playerStateChangeTrigger = trigger;
+	},
+
+	/**
+	 * Sets the track change event trigger.
+	 * @param {Function} trigger The event trigger function.
+	 */
+	setTrackChangeTrigger: function(trigger) {
+		console.log('car.mediaplayer/mediaplayer.js::setTrackChangeTrigger', trigger);
+		_trackChangeTrigger = trigger;
+	},
+
+	/**
+	 * Sets the track position change event trigger.
+	 * @param {Function} trigger The event trigger function.
+	 */
+	setTrackPositionChangeTrigger: function(trigger) {
+		console.log('car.mediaplayer/mediaplayer.js::setTrackPositionChangeTrigger', trigger);
+		_trackPositionChangeTrigger = trigger;
+	},
+	
+	/**
+	 * Opens the specified player name.
+	 * @param {String} playerName The player name to open. If the player does not exist it will automatically be created.
+	 * @returns {Boolean} True if the player was opened successfully, False if not.
+	 */
+	open: function(playerName) {
+		console.log('car.mediaplayer/mediaplayer.js::open', arguments);
+		var success = false;
+		if(_jPlayerObj) {
+			success = _jPlayerObj.open(playerName); 
+		
+			// Initialize the state cache
+			if(success && _stateCacheInitialized === false) {
+				_stateCacheInitialized = true;
+				this.getTrackSessionInfo(initializeCurrentTrackSessionInfo, function() {});
+			}
+		}
+		return success;
+	},
+	
+	/**
+	 * Closes the specified player name.
+	 * @param {String} playerName The player name to close.
+	 * @returns {Boolean} True if the player was closed successfully, False if not.
+	 */
+	close: function(playerName) {
+		console.log('car.mediaplayer/mediaplayer.js::close', arguments);
+		var success = false;
+		if(_jPlayerObj) {
+			success = _jPlayerObj.close(playerName);
+
+			// Clear the state cache
+			if(success) {
+				_stateCacheInitialized = false;
+				_currentTrackSessionId = null;
+			}
+		}
+		return success;
+	},
+	
+	/**
+	 * Returns the list of available media sources connected to the device.
+	 * @param {Function} success Function to call if the operation is a success.
+	 * @param {Function} fail Function to call if the operation fails.
+	 * @returns {Boolean} True if the operation was successful, False if not.
+	 */
+	getMediaSources: function(success, fail) {
+		console.log('car.mediaplayer/mediaplayer.js::getMediaSources', arguments);
+		return _jPlayerObj ? _jPlayerObj.getMediaSources(registerCallbackFunctions(success, fail)) : false;
+	},
+
+	/**
+	 * Browse a media source for media.
+	 * @param {Function} success Function to call if the operation is a success.
+	 * @param {Function} fail Function to call if the operation fails.
+	 * @param {Number} mediaSourceId The ID of the media source.
+	 * @param {String} [mediaNodeId="/"] The ID of the media node to browse. If omitted or null, the root node will
+	 * be retrieved.
+	 * @param {Number} [limit=-1] The maximum number of records to retrieve. If omitted or negative,
+	 * all records will be retrieved.
+	 * @param {Number} [offset=0] The offset at which to start retrieving records. If omitted or negative,
+	 * offset will be 0.
+	 * @returns {Boolean} True if the operation was successful, False if not.
+	 */
+	browse: function(success, fail, mediaSourceId, mediaNodeId, limit, offset) {
+		console.log('car.mediaplayer/mediaplayer.js::browse', arguments);
+		return _jPlayerObj ? _jPlayerObj.browse(
+				registerCallbackFunctions(success, fail),
+				mediaSourceId,
+				typeof mediaNodeId === 'string' && mediaNodeId.trim() !== '' ? mediaNodeId : ROOT_MEDIA_NODE_ID,
+				typeof limit === 'number' ? limit : -1,
+				typeof offset === 'number' ? offset: 0
+			) : false;
+	},
+	
+	/**
+	 * Search for media items in a specific media source.
+	 * @param {Function} success Function to call if the operation is a success.
+	 * @param {Function} fail Function to call if the operation fails.
+	 * @param {Number} mediaSourceId The ID of the media source.
+	 * @param {String} [mediaNodeId=null] The ID of the media node from which to search.
+	 * @param {String} searchTerm The term to search for.
+	 * @param {Number} [limit=-1] The maximum number of records to retrieve. If omitted or negative,
+	 * all records will be retrieved.
+	 * @param {Number} [offset=0] The offset at which to start retrieving records. If omitted or negative,
+	 * offset will be 0.
+	 * @returns {Boolean} True if the operation was successful, False if not.
+	 */
+	search: function(success, fail, mediaSourceId, mediaNodeId, searchTerm, limit, offset) {
+		console.log('car.mediaplayer/mediaplayer.js::search', arguments);
+		return _jPlayerObj ? _jPlayerObj.search(
+				registerCallbackFunctions(success, fail),
+				mediaSourceId,
+				typeof mediaNodeId === 'string' && mediaNodeId.trim() !== '' ? mediaNodeId : ROOT_MEDIA_NODE_ID,
+				searchTerm,
+				typeof limit === 'number' ? limit : -1,
+				typeof offset === 'number' ? offset: 0
+			) : false;
+	},
+	
+	/**
+	 * Creates a track session based on the given MediaNode ID.
+	 * @param {Function} success Function to call if the operation is a success.
+	 * @param {Function} fail Function to call if the operation fails.
+	 * @param {Number} mediaSourceId The media source ID. 
+	 * @param {?String} mediaNodeId The media node ID on which to base the track session.
+	 * @param {Number} index The index of the item within the track session to set as current after creation.
+	 * @param {Number} limit The maximum number of media nodes to add to the track session. A limit of -1 indicates no limit.
+	 * @param {Number} offset The offset within the specified media node at which to start building the track session.
+	 * @returns {Boolean} True if the operation was successful, False if not.
+	 */
+	createTrackSession: function(success, fail, mediaSourceId, mediaNodeId, index, limit, offset) {
+		console.log('car.mediaplayer/mediaplayer.js::createTrackSession', arguments);
+		return _jPlayerObj ? _jPlayerObj.createTrackSession(
+				registerCallbackFunctions(success, fail),
+				mediaSourceId,
+				mediaNodeId === null ? ROOT_MEDIA_NODE_ID : mediaNodeId,
+				index,
+				limit,
+				offset
+			) : false;
+	},
+
+	/**
+	 * Destroys an existing track session.
+	 * @param {Number} trackSessionId The track session ID.
+	 * @param {Function} success The success callback handler.
+	 * @param {Function} [error] The error callback handler.
+	 */
+	destroyTrackSession: function(trackSessionId) {
+		console.log('car.mediaplayer/mediaplayer.js::destroyTrackSession', arguments);
+		return _jPlayerObj ? _jPlayerObj.destroyTrackSession(trackSessionId) : false;
+	},
+	
+	/**
+	 * Retrieves information about the current track session.
+	 * @param {Function} success Function to call if the operation is a success.
+	 * @param {Function} fail Function to call if the operation fails.
+	 * @returns {Boolean} True if the operation was successful, False if not.
+	 */
+	getTrackSessionInfo: function(success, fail) {
+		console.log('car.mediaplayer/mediaplayer.js::getTrackSessionInfo', arguments);
+		// jPlayer API method is intentionally different here. car.mediaplayer abstracts the concept of multiple
+		// track sessions, so 'current tracksession' is superfluous.
+		return _jPlayerObj ? _jPlayerObj.getCurrentTrackSessionInfo(registerCallbackFunctions(success, fail)) : false;
+	},
+	
+	/**
+	 * Retrieves media from the current track session.
+	 * @param {Function} success Function to call if the operation is a success.
+	 * @param {Function} fail Function to call if the operation fails.
+	 * @param {Number} [limit-1] The maximum number of records to retrieve. If omitted or negative,
+	 * all records will be retrieved.
+	 * @param {Number} [offset=0] The offset at which to start retrieving records. If omitted or negative,
+	 * offset will be 0.
+	 * @returns {Boolean} True if the operation was successful, False if not.
+	 */
+	getTrackSessionItems: function(success, fail, limit, offset) {
+		console.log('car.mediaplayer/mediaplayer.js::getTrackSessionItems', arguments);
+		// Automatically add the current track session ID as an argument so that we're always operating off
+		// of the current track session.
+		return _jPlayerObj ? _jPlayerObj.getTrackSessionItems(
+				registerCallbackFunctions(success, fail),
+				_currentTrackSessionId,
+				typeof limit === 'number' ? limit : -1,
+				typeof offset === 'number' ? offset: 0
+			) : false;
+	},
+	
+	/**
+	 * Retrieves the currently playing track information.
+	 * @param {Function} success Function to call if the operation is a success.
+	 * @param {Function} fail Function to call if the operation fails.
+	 * @returns {Boolean} True if the operation was successful, False if not.
+	 */
+	getCurrentTrack: function(success, fail) {
+		console.log('car.mediaplayer/mediaplayer.js::getCurrentTrack', arguments);
+		return _jPlayerObj ? _jPlayerObj.getCurrentTrackInfo(registerCallbackFunctions(success, fail)) : false;
+	},
+	
+	/**
+	 * Retrieve the current playback position, in milliseconds, of the current track.
+	 * @param {Function} success Function to call if the operation is a success.
+	 * @param {Function} fail Function to call if the operation fails.
+	 * @returns {Boolean} True if the operation was successful, False if not.
+	 */
+	getCurrentTrackPosition: function(success, fail) {
+		console.log('car.mediaplayer/mediaplayer.js::getCurrentTrackPosition', arguments);
+		return _jPlayerObj ? _jPlayerObj.getCurrentTrackPosition(registerCallbackFunctions(success, fail)) : false;
+	},
+	
+	/**
+	 * Retrieves metadata for the specified media.
+	 * @param {Function} success Function to call if the operation is a success.
+	 * @param {Function} fail Function to call if the operation fails.
+	 * @param {Number} mediaSourceId The MediaNode's media source ID.
+	 * @param {String} mediaNodeId The MediaNode ID.
+	 * @returns {Boolean} True if the operation was successful, False if not.
+	 */
+	getMetadata: function(success, fail, mediaSourceId, mediaNodeId) {
+		console.log('car.mediaplayer/mediaplayer.js::getMetadata', arguments);
+		return _jPlayerObj ? _jPlayerObj.getMetadata(registerCallbackFunctions(success, fail), mediaSourceId, mediaNodeId) : false;
+	},
+	
+	/**
+	 * Retrieves extended metadata properties for the specified media.
+	 * @param {Function} success Function to call if the operation is a success.
+	 * @param {Function} fail Function to call if the operation fails.
+	 * @param {Number} mediaSourceId The MediaNode's media source ID.
+	 * @param {String} mediaNodeId The MediaNode ID.
+	 * @param {String[]} properties An array of extended metadata property names to retrieve.
+	 * @returns {Boolean} True if the operation was successful, False if not.
+	 */
+	getExtendedMetadata: function(success, fail, mediaSourceId, mediaNodeId, properties) {
+		console.log('car.mediaplayer/mediaplayer.js::getExtendedMetadata', arguments);
+		return _jPlayerObj ? _jPlayerObj.getExtendedMetadata(
+				registerCallbackFunctions(success, fail),
+				mediaSourceId,
+				mediaNodeId,
+				properties
+			) : false;
+	},
+	
+	/**
+	 * Returns the state of the media player.
+	 * @param {Function} success Function to call if the operation is a success.
+	 * @param {Function} fail Function to call if the operation fails.
+	 * @returns {Boolean} True if the operation was successful, False if not.
+	 */
+	getPlayerState: function(success, fail) {
+		console.log('car.mediaplayer/mediaplayer.js::getPlayerState', arguments);
+		return _jPlayerObj ? _jPlayerObj.getPlayerState(registerCallbackFunctions(success, fail)) : false;
+	},
+	
+	/**
+	 * Start or resume playback of the current track session.
+	 * @returns {Boolean} True if the operation was successful, False if not.
+	 */
+	play: function() {
+		console.log('car.mediaplayer/mediaplayer.js::play');
+		return _jPlayerObj ? _jPlayerObj.play() : false;
+	},
+	
+	/**
+	 * Pause playback.
+	 * @returns {Boolean} True if the operation was successful, False if not.
+	 */
+	pause: function() {
+		console.log('car.mediaplayer/mediaplayer.js::pause');
+		return _jPlayerObj ? _jPlayerObj.pause() : false;
+	},
+	
+	/**
+	 * Stops playback.
+	 * @returns {Boolean} True if the operation was successful, False if not.
+	 */
+	stop: function() {
+		console.log('car.mediaplayer/mediaplayer.js::stop');
+		return _jPlayerObj ? _jPlayerObj.stop() : false;
+	},
+	
+	/**
+	 * Resume playback.
+	 * @returns {Boolean} True if the operation was successful, False if not.
+	 */
+	resume: function() {
+		console.log('car.mediaplayer/mediaplayer.js::resume');
+		return _jPlayerObj ? _jPlayerObj.resume() : false;
+	},
+	
+	/**
+	 * Skip to the next track in the active track session.
+	 * @returns {Boolean} True if the operation was successful, False if not.
+	 */
+	next: function() {
+		console.log('car.mediaplayer/mediaplayer.js::next');
+		return _jPlayerObj ? _jPlayerObj.next() : false;
+	},
+	
+	/**
+	 * Skip to the previous track in the active track session.
+	 * @returns {Boolean} True if the operation was successful, False if not.
+	 */
+	previous: function() {
+		console.log('car.mediaplayer/mediaplayer.js::previous');
+		return _jPlayerObj ? _jPlayerObj.previous() : false;
+	},
+	
+	/**	
+	 * Jumps to the specified track index in the current track session.
+	 * @param {Number} index The track index within the current track session.
+	 * @returns {Boolean} True if the call was successful, False if not.
+	 */
+	jump: function(index) {
+		console.log('car.mediaplayer/mediaplayer.js::jump', arguments);
+		return _jPlayerObj ? _jPlayerObj.jump(index) : false;
+	},
+	
+	/**
+	 * Seek to a specific position in the current track.
+	 * @param {Number} position The track position, in ms.
+	 * @returns {Boolean} True if the operation was successful, False if not.
+	 */
+	seek: function(position) {
+		console.log('car.mediaplayer/mediaplayer.js::seek', arguments);
+		return _jPlayerObj ? _jPlayerObj.seek(position) : false;
+	},
+	
+	/**
+	 * Set the playback rate of the media player.
+	 * @param {Number} playbackRate A value of 1.0 is regular play speed. Negative numbers result in reverse playback.
+	 * @returns {Boolean} True if the operation was successful, False if not.
+	 */
+	setPlaybackRate: function(playbackRate) {
+		console.log('car.mediaplayer/mediaplayer.js::setPlaybackRate', arguments);
+		return _jPlayerObj ? _jPlayerObj.setPlaybackRate(playbackRate) : false;
+	},
+	
+	/**
+	 * Set the shuffle mode for the active track session.
+	 * @param {MediaPlayer.ShuffleMode} shuffleMode The shuffle mode as per the MediaPlayer.ShuffleMode enumeration. 
+	 * @returns {Boolean} True if the operation was successful, False if not.
+	 */
+	shuffle: function(shuffleMode) {
+		console.log('car.mediaplayer/mediaplayer.js::shuffle', arguments);
+		return _jPlayerObj ? _jPlayerObj.shuffle(shuffleMode) : false;
+	},
+	
+	/**
+	 * Set the repeat mode for the active track session.
+	 * @param {MediaPlayer.RepeatMode} repeatMode The repeat mode as per the MediaPlayer.RepeatMode enumeration.
+	 * @returns {Boolean} True if the operation was successful, False if not.
+	 */
+	repeat: function(repeatMode) {
+		console.log('car.mediaplayer/mediaplayer.js::repeat', arguments);
+		return _jPlayerObj ? _jPlayerObj.repeat(repeatMode) : false;
+	}
+};
diff --git a/plugin/com.qnx.car.mediaplayer/www/Event.js b/plugin/com.qnx.car.mediaplayer/www/Event.js
new file mode 100644
index 0000000..44d4b7a
--- /dev/null
+++ b/plugin/com.qnx.car.mediaplayer/www/Event.js
@@ -0,0 +1,34 @@
+/*
+ * Copyright 2013  QNX Software Systems Limited
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"). You
+ * may not reproduce, modify or distribute this software except in
+ * compliance with the License. You may obtain a copy of the License
+ * at: http://www.apache.org/licenses/LICENSE-2.0.
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTIES OF ANY KIND, either express or implied.
+ * This file may contain contributions from others, either as
+ * contributors under the License or as licensors under other terms.
+ * Please review this entire file for other proprietary rights or license
+ * notices, as well as the applicable QNX License Guide at
+ * http://www.qnx.com/legal/licensing/document_archive/current_matrix.pdf
+ * for other information.
+ */
+
+/**
+ * @private
+ * Event enumeration.
+ */
+module.exports = {};
+
+Object.defineProperties(module.exports,
+{
+	'MEDIA_SOURCE_CHANGE':		{ value: 'car.mediaplayer.mediasourcechange',	enumerable: true, writable: false },
+	'TRACK_SESSION_CHANGE':		{ value: 'car.mediaplayer.tracksessionchange',	enumerable: true, writable: false },
+	'PLAYER_STATE_CHANGE':		{ value: 'car.mediaplayer.playerstatechange',	enumerable: true, writable: false },
+	'TRACK_CHANGE':				{ value: 'car.mediaplayer.trackchange',			enumerable: true, writable: false },
+	'TRACK_POSITION_CHANGE':	{ value: 'car.mediaplayer.trackpositionchange',	enumerable: true, writable: false },
+	'ERROR':					{ value: 'car.mediaplayer.error',				enumerable: true, writable: false }
+});
\ No newline at end of file
diff --git a/plugin/com.qnx.car.mediaplayer/www/MediaNodeType.js b/plugin/com.qnx.car.mediaplayer/www/MediaNodeType.js
new file mode 100644
index 0000000..899753b
--- /dev/null
+++ b/plugin/com.qnx.car.mediaplayer/www/MediaNodeType.js
@@ -0,0 +1,40 @@
+/*
+ * Copyright 2013  QNX Software Systems Limited
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"). You
+ * may not reproduce, modify or distribute this software except in
+ * compliance with the License. You may obtain a copy of the License
+ * at: http://www.apache.org/licenses/LICENSE-2.0.
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTIES OF ANY KIND, either express or implied.
+ * This file may contain contributions from others, either as
+ * contributors under the License or as licensors under other terms.
+ * Please review this entire file for other proprietary rights or license
+ * notices, as well as the applicable QNX License Guide at
+ * http://www.qnx.com/legal/licensing/document_archive/current_matrix.pdf
+ * for other information.
+ */
+
+module.exports = {};
+/**
+ * @memberOf module:car.mediaplayer
+ * @name MediaNodeType
+ *
+ * @description  Media node type enumeration
+ *
+ *  @property UNKNOWN The media type is unknown.
+ *  @property FOLDER The media type is folder.
+ *  @property AUDIO The media type is audio.
+ *  @property VIDEO The media type is video. 
+ *  @property PHOTO The media type is photo. 
+ */  
+Object.defineProperties(module.exports,
+{
+	'UNKNOWN':		{ value: 0, enumerable: true, writable: false },
+	'FOLDER':		{ value: 1, enumerable: true, writable: false },
+	'AUDIO':		{ value: 2, enumerable: true, writable: false },
+	'VIDEO':		{ value: 3, enumerable: true, writable: false },
+	'PHOTO':		{ value: 5, enumerable: true, writable: false }
+});
\ No newline at end of file
diff --git a/plugin/com.qnx.car.mediaplayer/www/MediaSourceEvent.js b/plugin/com.qnx.car.mediaplayer/www/MediaSourceEvent.js
new file mode 100644
index 0000000..a19ba0e
--- /dev/null
+++ b/plugin/com.qnx.car.mediaplayer/www/MediaSourceEvent.js
@@ -0,0 +1,37 @@
+/*
+ * Copyright 2013  QNX Software Systems Limited
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"). You
+ * may not reproduce, modify or distribute this software except in
+ * compliance with the License. You may obtain a copy of the License
+ * at: http://www.apache.org/licenses/LICENSE-2.0.
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTIES OF ANY KIND, either express or implied.
+ * This file may contain contributions from others, either as
+ * contributors under the License or as licensors under other terms.
+ * Please review this entire file for other proprietary rights or license
+ * notices, as well as the applicable QNX License Guide at
+ * http://www.qnx.com/legal/licensing/document_archive/current_matrix.pdf
+ * for other information.
+ */
+
+module.exports = {};
+
+/**
+ * @memberOf module:car.mediaplayer
+ * @name MediaSourceEvent
+ *
+ * @description  Media source event enumeration
+ *
+ * @property ADDED The media source is added.
+ * @property REMOVED The media source is removed.
+ * @property UPDATED The media source is updated.
+ */ 
+Object.defineProperties(module.exports,
+{
+	'ADDED':	{ value: 0,	enumerable: true, writable: false },
+	'REMOVED':	{ value: 1,	enumerable: true, writable: false },
+	'UPDATED':	{ value: 2,	enumerable: true, writable: false }
+});
\ No newline at end of file
diff --git a/plugin/com.qnx.car.mediaplayer/www/MediaSourceType.js b/plugin/com.qnx.car.mediaplayer/www/MediaSourceType.js
new file mode 100644
index 0000000..3422474
--- /dev/null
+++ b/plugin/com.qnx.car.mediaplayer/www/MediaSourceType.js
@@ -0,0 +1,43 @@
+/*
+ * Copyright 2013  QNX Software Systems Limited
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"). You
+ * may not reproduce, modify or distribute this software except in
+ * compliance with the License. You may obtain a copy of the License
+ * at: http://www.apache.org/licenses/LICENSE-2.0.
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTIES OF ANY KIND, either express or implied.
+ * This file may contain contributions from others, either as
+ * contributors under the License or as licensors under other terms.
+ * Please review this entire file for other proprietary rights or license
+ * notices, as well as the applicable QNX License Guide at
+ * http://www.qnx.com/legal/licensing/document_archive/current_matrix.pdf
+ * for other information.
+ */
+
+module.exports = {};
+
+/**
+ * @memberOf module:car.mediaplayer
+ * @name MediaSourceType
+ *
+ * @description  Media source type enumeration
+ *
+ * @property HDD The media source is HDD.
+ * @property USB The media source is USB.
+ * @property IPOD The media source is iPod.
+ * @property DLNA The media source is DLNA.
+ * @property BLUETOOTH The media source is Bluetooth.
+ * @property MTP The media source is MTP. 
+ */ 
+Object.defineProperties(module.exports,
+{
+	'HDD':			{ value: 0x00000001, enumerable: true, writable: false },
+	'USB':			{ value: 0x00000002, enumerable: true, writable: false },
+	'IPOD':			{ value: 0x00000010, enumerable: true, writable: false },
+	'DLNA':			{ value: 0x00000100, enumerable: true, writable: false },
+	'BLUETOOTH':	{ value: 0x00001000, enumerable: true, writable: false },
+	'MTP':			{ value: 0x00010000, enumerable: true, writable: false }
+});
\ No newline at end of file
diff --git a/plugin/com.qnx.car.mediaplayer/www/PlayerStatus.js b/plugin/com.qnx.car.mediaplayer/www/PlayerStatus.js
new file mode 100644
index 0000000..5f29a8c
--- /dev/null
+++ b/plugin/com.qnx.car.mediaplayer/www/PlayerStatus.js
@@ -0,0 +1,42 @@
+/*
+ * Copyright 2013  QNX Software Systems Limited
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"). You
+ * may not reproduce, modify or distribute this software except in
+ * compliance with the License. You may obtain a copy of the License
+ * at: http://www.apache.org/licenses/LICENSE-2.0.
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTIES OF ANY KIND, either express or implied.
+ * This file may contain contributions from others, either as
+ * contributors under the License or as licensors under other terms.
+ * Please review this entire file for other proprietary rights or license
+ * notices, as well as the applicable QNX License Guide at
+ * http://www.qnx.com/legal/licensing/document_archive/current_matrix.pdf
+ * for other information.
+ */
+
+
+module.exports = {};
+
+/**
+ * @memberOf module:car.mediaplayer
+ * @name PlayerStatus
+ *
+ * @description  Media player status enumeration
+ *
+ * @property DESTROYED The media player instance was destroyed.
+ * @property IDLE The media player is idle.
+ * @property PLAYING The media player is playing.
+ * @property PAUSED The media player is paused.
+ * @property STOPPED The media player is stopped.
+ */ 
+Object.defineProperties(module.exports,
+{
+	'DESTROYED':{ value: 0,	enumerable: true, writable: false },
+	'IDLE':		{ value: 1,	enumerable: true, writable: false },
+	'PLAYING':	{ value: 2,	enumerable: true, writable: false },
+	'PAUSED':	{ value: 3,	enumerable: true, writable: false },
+	'STOPPED':	{ value: 4,	enumerable: true, writable: false }
+});
\ No newline at end of file
diff --git a/plugin/com.qnx.car.mediaplayer/www/RepeatMode.js b/plugin/com.qnx.car.mediaplayer/www/RepeatMode.js
new file mode 100644
index 0000000..843791e
--- /dev/null
+++ b/plugin/com.qnx.car.mediaplayer/www/RepeatMode.js
@@ -0,0 +1,37 @@
+/*
+ * Copyright 2013  QNX Software Systems Limited
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"). You
+ * may not reproduce, modify or distribute this software except in
+ * compliance with the License. You may obtain a copy of the License
+ * at: http://www.apache.org/licenses/LICENSE-2.0.
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTIES OF ANY KIND, either express or implied.
+ * This file may contain contributions from others, either as
+ * contributors under the License or as licensors under other terms.
+ * Please review this entire file for other proprietary rights or license
+ * notices, as well as the applicable QNX License Guide at
+ * http://www.qnx.com/legal/licensing/document_archive/current_matrix.pdf
+ * for other information.
+ */
+
+module.exports = {};
+
+/**
+ * @memberOf module:car.mediaplayer
+ * @name RepeatMode
+ *
+ * @description  Repeat mode enumeration.
+ *
+ * @property REPEAT_OFF Repeat mode is off.
+ * @property REPEAT_ALL Repeat all tracks.
+ * @property REPEAT_ONE Repeat one track.
+ */
+Object.defineProperties(module.exports,
+{
+	'REPEAT_OFF':		{ value: 0,	enumerable: true, writable: false },
+	'REPEAT_ALL':		{ value: 1,	enumerable: true, writable: false },
+	'REPEAT_ONE':		{ value: 2,	enumerable: true, writable: false }
+});
\ No newline at end of file
diff --git a/plugin/com.qnx.car.mediaplayer/www/ShuffleMode.js b/plugin/com.qnx.car.mediaplayer/www/ShuffleMode.js
new file mode 100644
index 0000000..8a1f0f5
--- /dev/null
+++ b/plugin/com.qnx.car.mediaplayer/www/ShuffleMode.js
@@ -0,0 +1,35 @@
+/*
+ * Copyright 2013  QNX Software Systems Limited
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"). You
+ * may not reproduce, modify or distribute this software except in
+ * compliance with the License. You may obtain a copy of the License
+ * at: http://www.apache.org/licenses/LICENSE-2.0.
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTIES OF ANY KIND, either express or implied.
+ * This file may contain contributions from others, either as
+ * contributors under the License or as licensors under other terms.
+ * Please review this entire file for other proprietary rights or license
+ * notices, as well as the applicable QNX License Guide at
+ * http://www.qnx.com/legal/licensing/document_archive/current_matrix.pdf
+ * for other information.
+ */
+
+module.exports = {};
+
+/**
+ * @memberOf module:car.mediaplayer
+ * @name ShuffleMode
+ *
+ * @description  Shuffle mode enumeration
+ *
+ * @property SHUFFLE_OFF Shuffle mode is off.
+ * @property SHUFFLE_ON Shuffle mode is on.
+ */
+Object.defineProperties(module.exports,
+{
+	'SHUFFLE_OFF':		{ value: 0,	enumerable: true, writable: false },
+	'SHUFFLE_ON':		{ value: 1,	enumerable: true, writable: false }
+});
\ No newline at end of file
diff --git a/plugin/com.qnx.car.mediaplayer/www/TrackSessionEvent.js b/plugin/com.qnx.car.mediaplayer/www/TrackSessionEvent.js
new file mode 100644
index 0000000..745c65c
--- /dev/null
+++ b/plugin/com.qnx.car.mediaplayer/www/TrackSessionEvent.js
@@ -0,0 +1,37 @@
+/*
+ * Copyright 2013  QNX Software Systems Limited
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"). You
+ * may not reproduce, modify or distribute this software except in
+ * compliance with the License. You may obtain a copy of the License
+ * at: http://www.apache.org/licenses/LICENSE-2.0.
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTIES OF ANY KIND, either express or implied.
+ * This file may contain contributions from others, either as
+ * contributors under the License or as licensors under other terms.
+ * Please review this entire file for other proprietary rights or license
+ * notices, as well as the applicable QNX License Guide at
+ * http://www.qnx.com/legal/licensing/document_archive/current_matrix.pdf
+ * for other information.
+ */
+
+module.exports = {};
+/**
+ * @static
+ * @memberOf module:car.mediaplayer
+ * @name TrackSessionEvent
+ *
+ * @description  Tracksession event enumeration
+ *
+ * @property CREATED The tracksession is created.
+ * @property DESTROYED The tracksession is destroyed.
+ * @property APPENDED The tracksession is appended. 
+ */  
+Object.defineProperties(module.exports,
+{
+	'CREATED':		{ value: 0, enumerable: true, writable: false },
+	'DESTROYED':	{ value: 1, enumerable: true, writable: false },
+	'APPENDED':		{ value: 2, enumerable: true, writable: false }
+});
\ No newline at end of file
diff --git a/plugin/com.qnx.car.mediaplayer/www/client.js b/plugin/com.qnx.car.mediaplayer/www/client.js
new file mode 100644
index 0000000..7fc4410
--- /dev/null
+++ b/plugin/com.qnx.car.mediaplayer/www/client.js
@@ -0,0 +1,1631 @@
+/*
+ * Copyright 2013  QNX Software Systems Limited
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"). You
+ * may not reproduce, modify or distribute this software except in
+ * compliance with the License. You may obtain a copy of the License
+ * at: http://www.apache.org/licenses/LICENSE-2.0.
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTIES OF ANY KIND, either express or implied.
+ * This file may contain contributions from others, either as
+ * contributors under the License or as licensors under other terms.
+ * Please review this entire file for other proprietary rights or license
+ * notices, as well as the applicable QNX License Guide at
+ * http://www.qnx.com/legal/licensing/document_archive/current_matrix.pdf
+ * for other information.
+ */
+
+/**
+ * @module car.mediaplayer
+ * @description Provides media playback, browse, and search
+ */
+
+var _ID = "com.qnx.car.mediaplayer",
+	Event = require('./Event'),
+	MediaNodeType = require('./MediaNodeType'),
+	PlayerStatus = require('./PlayerStatus'),
+	MediaSourceEvent = require('./MediaSourceEvent'),
+	MediaSourceType = require('./MediaSourceType'),
+	TrackSessionEvent = require('./TrackSessionEvent'),
+	RepeatMode = require('./RepeatMode'),
+	ShuffleMode = require('./ShuffleMode'),
+	_utils = cordova.require('cordova/utils'),
+	_watchesMediaSource = {},
+	_watchesTrackSession = {},
+	_watchesPlayerState = {},
+	_watchesTrackPosition = {},
+	_watchesTrack = {};
+
+/**
+ * Handles media source events
+ * @param data {Array} The updated data provided by the event 
+ * @private
+ */
+function onMediaSourceChange(data) {
+	var keys = Object.keys(_watchesMediaSource);
+	for (var i=0; i<keys.length; i++) {
+		setTimeout(_watchesMediaSource[keys[i]](data), 0);
+	}
+}
+
+/**
+ * Handles track session events
+ * @param data {Array} The updated data provided by the event 
+ * @private
+ */
+function onTrachSessionChange(data) {
+	var keys = Object.keys(_watchesTrackSession);
+	for (var i=0; i<keys.length; i++) {
+		setTimeout(_watchesTrackSession[keys[i]](data), 0);
+	}
+}
+
+/**
+ * Handles player state events
+ * @param data {Array} The updated data provided by the event 
+ * @private
+ */
+function onPlayerStateChange(data) {
+	var keys = Object.keys(_watchesPlayerState);
+	for (var i=0; i<keys.length; i++) {
+		setTimeout(_watchesPlayerState[keys[i]](data), 0);
+	}
+}
+
+/**
+ * Handles track position events
+ * @param data {Array} The updated data provided by the event 
+ * @private
+ */
+function onTrackPositionChange(data) {
+	var keys = Object.keys(_watchesTrackPosition);
+	for (var i=0; i<keys.length; i++) {
+		setTimeout(_watchesTrackPosition[keys[i]](data), 0);
+	}
+}
+
+/**
+ * Handles track events
+ * @param data {Array} The updated data provided by the event 
+ * @private
+ */
+function onTrackChange(data) {
+	var keys = Object.keys(_watchesTrack);
+	for (var i=0; i<keys.length; i++) {
+		setTimeout(_watchesTrack[keys[i]](data), 0);
+	}
+}
+
+
+/**
+ * @description <p>The <b>car.mediaplayer</b> MediaPlayer instance constructor
+ * <p>Open the specified player and return an instance of the MediaPlayer object,
+ * which is used to perform actions on the media player and to receive update events
+ * through watchers.
+ * @name MediaPlayer
+ * @param {String} playerName The name of the player to open. If the player does not exist, it is automatically created.
+ * @returns {MediaPlayer} The <b>car.mediaplayer.MediaPlayer</b> instance.
+ * @memberOf module:car.mediaplayer
+ * @constructor
+ * @example
+ *
+ * // Instantiate a media player object, specifying the player name
+ * var mediaPlayer = new car.mediaplayer.MediaPlayer('playerName');
+ *
+ *
+ *
+ * @example REST
+ *
+ * Request:
+ * http://&lt;car-ip&gt;/car.mediaplayer/open?playerName=playerName
+ *
+ * Success Response:
+ * {
+ *		"code": 1,
+ *		"data": true
+ * }
+ *
+ * Error Response:
+ * {
+ *		code: -1,
+ *		msg: "An error has occurred"
+ * }
+ */
+var MediaPlayer = function(playerName) {
+	/**
+	 * Reference to this object instance.
+	 * @private
+	 */
+	var self = this;
+	
+	/**
+	 * Opens the specified player name.
+	 * @param {String} name The player name to open. If the player does not exist it will automatically be created.
+	 * @returns {Boolean} True if the player was opened successfully, False if not.
+	 * @private
+	 */
+	var open = function(playerName) {
+		console.log('car.mediaplayer/client.js::open', playerName);
+		var value = null,
+   			args = {
+   				playerName: playerName
+   			},
+			success = function (data, response) {
+				value = true;
+			},
+			fail = function (data, response) {
+				value = false;
+			};
+
+		try {
+			window.cordova.exec(success, fail, _ID, 'open', args);
+		} catch (e) {
+			console.error(e);
+		}
+		return value;
+	};
+	
+	/**
+	 * Closes the specified player name.
+	 * @param {String} name The player name to close.
+	 * @returns {Boolean} True if the player was closed successfully, False if not.
+	 * @private
+	 */
+	var close = function(playerName) {
+		console.log('car.mediaplayer/client.js::close', playerName);
+		var value = null,
+   			args = {
+   				playerName: playerName
+   			},
+			success = function (data, response) {
+				value = true;
+			},
+			fail = function (data, response) {
+				value = false;
+			};
+		try {
+			window.cordova.exec(success, fail, _ID, 'close', args);
+		} catch (e) {
+			console.error(e);
+		}
+		return value;
+	};
+
+	/**
+	 * Return the list of available media sources connected to the device
+	 *
+	 * @param {Function} success The function to call on success.
+	 * @param {Function} [error] The function to call on error.
+	 * @memberOf module:car.mediaplayer.MediaPlayer
+	 * @method getMediaSources	 
+	 * @example
+	 * // Define your callback function(s)
+	 * function successCallback(mediaSources) {
+	 * 	// Iterate through all of the media sources
+	 * 	for (var i=0; i&lt;mediaSources.length; i++) {
+	 * 		console.log("media source id = " + mediaSources[i].id + "\n" +
+	 * 					"media source uid = " + mediaSources[i].uid + "\n" +
+	 * 					"media source name = " + mediaSources[i].name + "\n" +
+	 * 					"media source type = " + mediaSources[i].type + "\n" +
+	 * 					"media source ready = " + mediaSources[i].ready);
+	 * 		console.group("media source capabilities");
+	 * 		console.log("play = " + mediaSources[i].capabilities.play + "\n" +
+	 * 					"pause = " + mediaSources[i].capabilities.pause + "\n" +
+	 * 					"stop = " + mediaSources[i].capabilities.stop + "\n" +
+	 * 					"next = " + mediaSources[i].capabilities.next + "\n" +
+	 * 					"previous = " + mediaSources[i].capabilities.previous + "\n" +
+	 * 					"seek = " + mediaSources[i].capabilities.seek + "\n" +
+	 * 					"shuffle = " + mediaSources[i].capabilities.shuffle + "\n" +
+	 * 					"repeatOne = " + mediaSources[i].capabilities.repeatOne + "\n" +
+	 * 					"repeatAll = " + mediaSources[i].capabilities.repeatAll + "\n" +
+	 * 					"metadata = " + mediaSources[i].capabilities.metadata + "\n" +
+	 * 					"search = " + mediaSources[i].capabilities.search + "\n" +
+	 * 					"playbackRate = " + mediaSources[i].capabilities.playbackRate);
+	 * 		console.groupEnd();
+	 * 	}
+	 * }
+	 * 
+	 * function errorCallback(error) {
+	 *		console.log(error.code, error.msg);
+	 * }
+	 *
+	 * //call the method
+	 * car.mediaplayer.getMediaSources(successCallback, errorCallback);
+	 *
+	 *
+	 *
+	 * @example REST
+	 *
+	 * Request:
+	 * http://&lt;car-ip&gt;/car.mediaplayer/getMediaSources
+	 *
+	 * Success Response:
+	 * {
+	 *		code: 1,
+	 *		data: [
+	 *			{
+	 *				id: 0,
+	 *				uid: "dbmme",
+	 *				name: "Juke Box",
+	 *				type: 1,
+	 *				capabilities: {
+	 *					play: true,
+	 *					pause: true,
+	 *					stop: true,
+	 *					next: true,
+	 *					previous: true,
+	 *					seek: true,
+	 *					shuffle: true,
+	 *					repeatOne: true,
+	 *					repeatAll: true,
+	 *					metadata: true,
+	 *					search: true,
+	 *					playbackRate: true
+	 *				}
+	 *			}, {
+	 *				id: 1,
+	 *				uid: "0",
+	 *				name: "Bluetooth Phone",
+	 *				type: 4096,
+	 *				capabilities: {
+	 *					play: true,
+	 *					pause: true,
+	 *					stop: true,
+	 *					next: false,
+	 *					previous: false,
+	 *					seek: false,
+	 *					shuffle: false,
+	 *					repeatOne: false,
+	 *					repeatAll: false,
+	 *					metadata: true,
+	 *					search: false,
+	 *					playbackRate: false
+	 *				}
+	 *			}
+	 *		]
+	 * }
+	 *
+	 * Error Response:
+	 * {
+	 *		code: -1,
+	 *		msg: "An error has occurred"
+	 * }
+	 */
+	self.getMediaSources = function(success, error) {
+		console.log('car.mediaplayer/client.js::getMediaSources');
+		window.cordova.exec(success, error, _ID, 'getMediaSources', null, false);
+	};
+	
+	/**
+	 * Browse a media source for media
+	 * @param {Number} mediaSourceId The ID of the media source to be retrieved.
+	 * @param {Function} success The function to call on success.
+	 * @param {Function} [error] The function to call on error.
+	 * @param {String} [mediaNodeId=null] The ID of the media node to browse. If omitted or null, the root node
+	 * is retrieved.
+	 * @param {Number} [limit=-1] The maximum number of records to retrieve. If omitted or negative,
+	 * all records are retrieved.
+	 * @param {Number} [offset=0] The offset at which to start retrieving records. If omitted or negative,
+	 * the offset is 0.
+	 * @memberOf module:car.mediaplayer.MediaPlayer
+	 * @method browse
+	 * @example
+	 *
+	 * // Define your callback function(s)
+	 * function successCallback(mediaNodes) {
+	 * 	// Iterate through all of the node results
+	 * 	for (var i=0; i&lt;mediaNodes.length; i++) {
+	 * 		console.log("media node id = " + mediaNodes[i].id + "\n" +
+	 * 					"media node name = " + mediaNodes[i].name + "\n" +
+	 * 					"media node url = " + mediaNodes[i].url + "\n" +
+	 * 					"media node type = " + mediaNodes[i].type + "\n" +
+	 * 					"media node count = " + mediaNodes[i].count + "\n");
+	 * 	}
+	 * }
+	 * 
+	 * function errorCallback(error) {
+	 * 	console.log(error.code, error.msg);
+	 * }
+	 * 
+	 * // Instantiate a media player object, specifying the player name
+	 * var mediaPlayer = new car.mediaplayer.MediaPlayer('playerName');
+	 * 
+	 * // Browse the media source from its root
+	 * mediaPlayer.browse(0, successCallback, errorCallback, null, 10, 0);
+	 *
+	 *
+	 *
+	 * @example REST
+	 *
+	 * Request:
+	 * http://&lt;car-ip&gt;/car.mediaplayer/browse?mediaSourceId=0&limit=10&offset=0
+	 *
+	 * Success Response:
+	 * {
+	 *		code: 1,
+	 *		data: [
+	 *		{
+	 *			"id": "/artists-2",
+	 *			"name": "Artists",
+	 *			"url": null,
+	 *			"type": 1,
+	 *			"count": -1
+	 *		},
+	 *		{
+	 *			"id": "/albums-5",
+	 *			"name": "Albums",
+	 *			"url": null,
+	 *			"type": 1,
+	 *			"count": -1
+	 *		},
+	 *		{
+	 *			"id": "/genres-8",
+	 *			"name": "Genres",
+	 *			"url": null,
+	 *			"type": 1,
+	 *			"count": -1
+	 *		},
+	 *		{
+	 *			"id": "/songs-7",
+	 *			"name": "Songs",
+	 *			"url": null,
+	 *			"type": 1,
+	 *			"count": -1
+	 *		},
+	 *		{
+	 *			"id": "/videos-10",
+	 *			"name": "Videos",
+	 *			"url": null,
+	 *			"type": 1,
+	 *			"count": -1
+	 *		}
+	 *	]
+	 * }
+	 *
+	 * Error Response:
+	 * {
+	 *		code: -1,
+	 *		msg: "An error has occurred"
+	 * }
+	 */
+	self.browse = function(mediaSourceId, success, error, mediaNodeId, limit, offset) {
+		console.log('car.mediaplayer/client.js::browse', mediaSourceId, mediaNodeId, limit, offset);
+		var args = {
+				mediaSourceId: mediaSourceId,
+				mediaNodeId: typeof mediaNodeId === 'string' && mediaNodeId.trim() !== '' ? mediaNodeId : null,
+				limit: typeof limit === 'number' ? limit : -1,
+				offset: typeof offset === 'number' ? offset : 0
+		};
+		window.cordova.exec(success, error, _ID, 'browse', args, false);
+	};
+	
+	/**
+	 * Search for media in a specific media source
+	 * @param {Number} mediaSourceId The ID of the media source.
+	 * @param {String} searchTerm The term to search for.
+	 * @param {Function} success The function to call on success.
+	 * @param {Function} [error] The function to call on error.
+	 * @param {String} [mediaNodeId=null] The ID of the media node from which to search. If omitted or
+	 * null, the search starts from the root node.
+	 * @param {Number} [limit=-1] The maximum number of records to retrieve. If omitted or negative,
+	 * all records are retrieved.
+	 * @param {Number} [offset=0] The offset at which to start retrieving records. If omitted or negative,
+	 * the offset is 0.
+	 * @memberOf module:car.mediaplayer.MediaPlayer
+	 * @method search 
+	 * @example
+	 *
+	 * // Define your callback function(s)
+	 * function successCallback(mediaNodes) {
+	 * 	// Iterate through all of the node results
+	 * 	for (var i=0; i&lt;mediaNodes.length; i++) {
+	 * 		console.log("media node id = " + mediaNodes[i].id + "\n" +
+	 * 					"media node name = " + mediaNodes[i].name + "\n" +
+	 * 					"media node url = " + mediaNodes[i].url + "\n" +
+	 * 					"media node type = " + mediaNodes[i].type + "\n" +
+	 * 					"media node count = " + mediaNodes[i].count + "\n");
+	 * 	}
+	 * }
+	 * 
+	 * function errorCallback(error) {
+	 * 	console.log(error.code, error.msg);
+	 * }
+	 * 
+	 * // Instantiate a media player object, specifying the player name
+	 * var mediaPlayer = new car.mediaplayer.MediaPlayer('playerName');
+	 * 
+	 * // Search the media source from its root
+	 * mediaPlayer.search(0, 'ong', successCallback, errorCallback, null, 10, 0);
+	 *
+	 *
+	 *
+	 * @example REST
+	 *
+	 * Request:
+	 * http://&lt;car-ip&gt;/car.mediaplayer/search?mediaSourceId=0&searchTerm=ong&limit=10&offset=0
+	 *
+	 * Success Response:
+	 * {
+	 * 	"code": 1,
+	 * 	"data": [
+	 * 		{
+	 * 			"id": "/artists/11-3",
+	 * 			"name": "AllisonGray",
+	 * 			"url": null,
+	 * 			"type": 1,
+	 * 			"count": 1
+	 * 		},
+	 * 		{
+	 * 			"id": "/songs/15",
+	 * 			"name": "Sarasong",
+	 * 			"url": "file:///accounts/1000/shared/music/Sarasong.mp3",
+	 * 			"type": 2,
+	 * 			"count": -1
+	 * 		}
+	 * 	]
+	 * }
+	 *
+	 * Error Response:
+	 * {
+	 *		code: -1,
+	 *		msg: "An error has occurred"
+	 * }
+	 */
+	self.search = function(mediaSourceId, searchTerm, success, error, mediaNodeId, limit, offset) {
+		console.log('car.mediaplayer/client.js::search', arguments);
+		var args = {
+				mediaSourceId: mediaSourceId,
+				searchTerm: searchTerm,
+				mediaNodeId: typeof mediaNodeId === 'string' && mediaNodeId.trim() !== '' ? mediaNodeId : null,
+				limit: typeof limit === 'number' ? limit : -1,
+				offset: typeof offset === 'number' ? offset : 0
+		};
+		window.cordova.exec(success, error, _ID, 'search', args, false);
+	};
+	
+	/**
+	 * Create a new tracksession
+	 * @param {Number} mediaSourceId The ID of the media source.
+	 * @param {Function} success The function to call on success.
+	 * @param {Function} [error] The function to call on error.
+	 * @param {?String} [mediaNodeId=null] The media node ID on which to base the tracksession.
+	 * @param {Number} [index=0] The index of the item within the tracksession to set as current after creating
+	 * the tracksession.
+	 * @param {Number} [limit=-1] The maximum number of media nodes to add to the tracksession. A limit of -1
+	 * indicates no limit.
+	 * @param {Number} [offset=0] The offset within the specified media node at which to start building the track
+	 * session.
+	 * @memberOf module:car.mediaplayer.MediaPlayer
+	 * @method createTrackSession	 
+	 * @example
+	 *
+	 * // Define your callback function(s)
+	 * function successCallback(result) {
+	 * 	console.log("tracksession id = " + result.trackSessionId + "\n");
+	 * 	
+	 * 	// Play the new tracksession
+	 * 	mediaPlayer.play();
+	 * }
+	 * 
+	 * function errorCallback(error) {
+	 * 	console.log(error.code, error.msg);
+	 * }
+	 * 
+	 * // Instantiate a media player object, specifying the player name
+	 * var mediaPlayer = new car.mediaplayer.MediaPlayer('playerName');
+	 * 
+	 * // Create a tracksession from a folder node ID, setting the third track as first to play
+	 * mediaPlayer.createTrackSession(0, successCallback, errorCallback, '/songs-7', 2);
+	 *
+	 *
+	 *
+	 * @example REST
+	 *
+	 * Request:
+	 * http://&lt;car-ip&gt;/car.mediaplayer/createTrackSession?mediaSourceId=0&mediaNodeId=/songs-7&index=2
+	 *
+	 * Success Response:
+	 * {
+	 * 	"code": 1,
+	 * 	"data": {
+	 * 		"trackSessionId": 10
+	 * 	}
+	 * }
+	 *
+	 * Error Response:
+	 * {
+	 *		code: -1,
+	 *		msg: "An error has occurred"
+	 * }
+	 */
+	self.createTrackSession = function(mediaSourceId, success, error, mediaNodeId, index, limit, offset) {
+		console.log('car.mediaplayer/client.js::createTrackSession', arguments);
+		var args = {
+				mediaSourceId: mediaSourceId,
+				mediaNodeId: mediaNodeId,
+				index: index,
+				limit: limit,
+				offset: offset
+		};
+		window.cordova.exec(success, error, _ID, 'createTrackSession', args, false);
+	};
+	
+	/**
+	 * Destroy an existing tracksession
+	 * @param {Number} trackSessionId The ID of the tracksession to destroy.
+	 * @memberOf module:car.mediaplayer.MediaPlayer
+	 * @method destroyTrackSession	 
+	 * @example
+	 *
+	 * // Instantiate a media player object, specifying the player name
+	 * var mediaPlayer = new car.mediaplayer.MediaPlayer('playerName');
+	 * 
+	 * // Destroy the tracksession by its ID
+	 * mediaPlayer.destroyTrackSession(10);
+	 *
+	 *
+	 *
+	 * @example REST
+	 *
+	 * Request:
+	 * http://&lt;car-ip&gt;/car.mediaplayer/destroyTrackSession?trackSessionId=10
+	 *
+	 * Success Response:
+	 * {
+	 * 	"code": 1
+	 * }
+	 *
+	 * Error Response:
+	 * {
+	 *		code: -1,
+	 *		msg: "An error has occurred"
+	 * }
+	 */
+	self.destroyTrackSession = function(trackSessionId) {
+		console.log('car.mediaplayer/client.js::destroyTrackSession', trackSessionId);
+		var args = { trackSessionId: trackSessionId };
+		window.cordova.exec(null, null, _ID, 'destroyTrackSession', args);
+	};
+	
+	/**
+	 * Retrieve the current tracksession information
+	 * @param {Function} success The function to call on success.
+	 * @param {Function} [error] The function to call on error.
+	 * @memberOf module:car.mediaplayer.MediaPlayer
+	 * @method getTrackSessionInfo
+	 * @example
+	 *
+	 * // Define your callback function(s)
+	 * function successCallback(result) {
+	 * 	console.log("tracksession id = " + result.trackSessionId + "\n" +
+	 * 				"tracksession length = " + result.length);
+	 * }
+	 * 
+	 * function errorCallback(error) {
+	 * 	console.log(error.code, error.msg);
+	 * }
+	 * 
+	 * // Instantiate a media player object, specifying the player name
+	 * var mediaPlayer = new car.mediaplayer.MediaPlayer('playerName');
+	 * 
+	 * // Get the current tracksession info
+	 * mediaPlayer.getTrackSessionInfo(successCallback, errorCallback);
+	 *
+	 *
+	 *
+	 * @example REST
+	 *
+	 * Request:
+	 * http://&lt;car-ip&gt;/car.mediaplayer/getTrackSessionInfo
+	 *
+	 * Success Response:
+	 * {
+	 * 	"code": 1,
+	 * 	"data": {
+	 * 		"trackSessionId": 10,
+	 * 		"length": 17
+	 * 	}
+	 * }
+	 *
+	 * Error Response:
+	 * {
+	 *		code: -1,
+	 *		msg: "An error has occurred"
+	 * }
+	 */
+	self.getTrackSessionInfo = function(success, error) {
+		console.log('car.mediaplayer/client.js::getTrackSessionInfo');
+		window.cordova.exec(success, error, _ID, 'getTrackSessionInfo', null, false);
+	};
+	
+	/**
+	 * Retrieve media from the current tracksession
+	 * @param {Function} success The function to call on success.
+	 * @param {Function} [error] The function to call on error.
+	 * @param {Number} [limit=-1] The maximum number of records to retrieve. If omitted or negative,
+	 * all records are retrieved.
+	 * @param {Number} [offset=0] The offset at which to start retrieving records. If omitted or negative,
+	 * the offset is 0.
+	 * @memberOf module:car.mediaplayer.MediaPlayer
+	 * @method getTrackSessionItems	 
+	 * @example
+	 *
+	 * function successCallback(mediaNodes) {
+	 * 	// iterate through all of the node results
+	 * 	for (var i=0; i&lt;mediaNodes.length; i++) {
+	 * 		console.log("media node id = " + mediaNodes[i].id + "\n" +
+	 * 					"media node name = " + mediaNodes[i].name + "\n" +
+	 * 					"media node url = " + mediaNodes[i].url + "\n" +
+	 * 					"media node type = " + mediaNodes[i].type + "\n" +
+	 * 					"media node count = " + mediaNodes[i].count + "\n");
+	 * 	}
+	 * }
+	 * 
+	 * function errorCallback(error) {
+	 * 	console.log(error.code, error.msg);
+	 * }
+	 * 
+	 * // Instantiate a media player object, specifying the player name
+	 * var mediaPlayer = new car.mediaplayer.MediaPlayer('playerName');
+	 * 
+	 * // Get the third through fifth tracksession items
+	 * mediaPlayer.getTrackSessionItems(successCallback, errorCallback, 3, 2);
+	 *
+	 *
+	 *
+	 * @example REST
+	 *
+	 * Request:
+	 * http://&lt;car-ip&gt;/car.mediaplayer/getTrackSessionItems?limit=3&offset=2
+	 *
+	 * Success Response:
+	 * {
+	 * 	"code": 1,
+	 * 	"data": [
+	 * 		{
+	 * 			"id": "/songs/3",
+	 * 			"name": "Funktional Love ft. Ruchama",
+	 * 			"url": "file:///accounts/1000/shared/music/Funktional Love ft. Ruchama.mp3",
+	 * 			"type": 2,
+	 * 			"count": -1
+	 * 		},
+	 * 		{
+	 * 			"id": "/songs/4",
+	 * 			"name": "Hero",
+	 * 			"url": "file:///accounts/1000/shared/music/Hero.mp3",
+	 * 			"type": 2,
+	 * 			"count": -1
+	 * 		},
+	 * 		{
+	 * 			"id": "/songs/6",
+	 * 			"name": "In Her Smile",
+	 * 			"url": "file:///accounts/1000/shared/music/In Her Smile.mp3",
+	 * 			"type": 2,
+	 * 			"count": -1
+	 * 		}
+	 * 	]
+	 * }
+	 *
+	 * Error Response:
+	 * {
+	 *		code: -1,
+	 *		msg: "An error has occurred"
+	 * }
+	 */
+	self.getTrackSessionItems = function(success, error, limit, offset) {
+		console.log('car.mediaplayer/client.js::getTrackSessionItems', limit, offset);
+		var args = {
+				limit: typeof limit === 'number' ? limit : -1,
+				offset: typeof offset === 'number' ? offset : 0
+		};
+		window.cordova.exec(success, error, _ID, 'getTrackSessionItems', args, false);
+	};
+
+	/**
+	 * Retrieve information for the currently playing track 
+	 * @param {Function} success The function to call on success.
+	 * @param {Function} [error] The function to call on error.
+	 * @memberOf module:car.mediaplayer.MediaPlayer	 
+	 * @method getCurrentTrack
+	 * @example
+	 *
+	 * function successCallback(trackInfo) {
+	 * 	console.log("track info media source ID = " + trackInfo.mediaSourceId + "\n" +
+	 * 				"track info tracksession index = " + trackInfo.index);
+	 * 
+	 * 	console.group("track info media node");
+	 * 	console.log("id = " + trackInfo.mediaNode.id + "\n" +
+	 * 				"name = " + trackInfo.mediaNode.name + "\n" +
+	 * 				"url = " + trackInfo.mediaNode.url + "\n" +
+	 * 				"type = " + trackInfo.mediaNode.type + "\n" +
+	 * 				"count = " + trackInfo.mediaNode.count + "\n");
+	 * 	console.groupEnd();
+	 * 
+	 * 	console.group("track info metadata");
+	 * 	console.log("title = " + trackInfo.metadata.title + "\n" +
+	 * 				"duration = " + trackInfo.metadata.duration + "\n" +
+	 * 				"artwork = " + trackInfo.metadata.artwork + "\n" +
+	 * 				"artist = " + trackInfo.metadata.artist + "\n" +
+	 * 				"album = " + trackInfo.metadata.album + "\n" +
+	 * 				"genre = " + trackInfo.metadata.genre + "\n" +
+	 * 				"disc = " + trackInfo.metadata.disc + "\n" +
+	 * 				"track = " + trackInfo.metadata.track + "\n" +
+	 * 				"width = " + trackInfo.metadata.width + "\n" +
+	 * 				"height = " + trackInfo.metadata.height);
+	 * 	console.groupEnd();
+	 * }
+	 * 
+	 * function errorCallback(error) {
+	 * 	console.log(error.code, error.msg);
+	 * }
+	 * 
+	 * // Instantiate a media player object, specifying the player name
+	 * var mediaPlayer = new car.mediaplayer.MediaPlayer('playerName');
+	 * 
+	 * // Get the current track information
+	 * mediaPlayer.getCurrentTrack(successCallback, errorCallback);
+	 *
+	 *
+	 *
+	 * @example REST
+	 *
+	 * Request:
+	 * http://&lt;car-ip&gt;/car.mediaplayer/getCurrentTrack
+	 *
+	 * Success Response:
+	 * {
+	 * 	"code": 1,
+	 * 	"data": {
+	 * 		"index": 0,
+	 * 		"mediaSourceId": 0,
+	 * 		"mediaNode": {
+	 * 			"id": "/songs/1",
+	 * 			"name": "Bo Bo's Groove",
+	 * 			"url": "file:///accounts/1000/shared/music/Bo Bo's Groove.mp3",
+	 * 			"type": 2,
+	 * 			"count": -1
+	 * 		},
+	 * 		"metadata": {
+	 * 			"title": "Bo Bo's Groove",
+	 * 			"duration": 318411,
+	 * 			"artwork": "file:///apps/mediasources/imagecache//mme/2/original",
+	 * 			"artist": "tomprincipato",
+	 * 			"album": "Raising The Roof!",
+	 * 			"genre": "rock",
+	 * 			"disc": 0,
+	 * 			"track": 0,
+	 * 			"width": -1,
+	 * 			"height": -1
+	 * 		}
+	 * 	}
+	 * }
+	 *
+	 * Error Response:
+	 * {
+	 *		code: -1,
+	 *		msg: "An error has occurred"
+	 * }
+	 */
+	self.getCurrentTrack = function(success, error) {
+		console.log('car.mediaplayer/client.js::getCurrentTrack');
+		window.cordova.exec(success, error, _ID, 'getCurrentTrack', null, false);
+	};
+	
+	/**
+	 * Retrieve the current playback position, in milliseconds, of the current track.
+	 * @param {Function} success The function to call on success.
+	 * @param {Function} [error] The function to call on error.
+	 * @memberOf module:car.mediaplayer.Mediaplayer	 
+	 * @method getCurrentTrackPosition
+	 * @example
+	 *
+	 * function successCallback(result) {
+	 * 	console.log("current track position = " + result.position);
+	 * }
+	 * 
+	 * function errorCallback(error) {
+	 * 	console.log(error.code, error.msg);
+	 * }
+	 * 
+	 * // Instantiate a media player object, specifying the player name
+	 * var mediaPlayer = new car.mediaplayer.MediaPlayer('playerName');
+	 * 
+	 * // Get the current track playback position
+	 * mediaPlayer.getCurrentTrackPosition(successCallback, errorCallback);
+	 *
+	 *
+	 *
+	 * @example REST
+	 *
+	 * Request:
+	 * http://&lt;car-ip&gt;/car.mediaplayer/getCurrentTrackPosition
+	 *
+	 * Success Response:
+	 * {
+	 * 	"code": 1,
+	 * 	"data": {
+	 * 		"position": 12345
+	 * 	}
+	 * }
+	 *
+	 * Error Response:
+	 * {
+	 *		code: -1,
+	 *		msg: "An error has occurred"
+	 * }
+	 */
+	self.getCurrentTrackPosition = function(success, error) {
+		console.log('car.mediaplayer/client.js::getCurrentTrackPosition');
+		window.cordova.exec(success, error, _ID, 'getCurrentTrackPosition', null, false);
+	};
+
+	/**
+	 * Retrieve metadata for the specified media
+	 * @param {Number} mediaSourceId The ID of the node's media source.
+	 * @param {String} mediaNodeId The ID of the media node to retrieve metadata for.
+	 * @param {Function} success The function to call on success.
+	 * @param {Function} [error] The function to call on error.
+	 * @memberOf module:car.mediaplayer.MediaPlayer	 
+	 * @method getMetadata
+	 * @example
+	 *
+	 * function successCallback(metadata) {
+	 * 	console.log("metadata title = " + metadata.title + "\n" +
+	 * 				"metadata duration = " + metadata.duration + "\n" +
+	 * 				"metadata artwork = " + metadata.artwork + "\n" +
+	 * 				"metadata artist = " + metadata.artist + "\n" +
+	 * 				"metadata album = " + metadata.album + "\n" +
+	 * 				"metadata genre = " + metadata.genre + "\n" +
+	 * 				"metadata disc = " + metadata.disc + "\n" +
+	 * 				"metadata track = " + metadata.track + "\n" +
+	 * 				"metadata width = " + metadata.width + "\n" +
+	 * 				"metadata height = " + metadata.height);
+	 * }
+	 * 
+	 * function errorCallback(error) {
+	 * 	console.log(error.code, error.msg);
+	 * }
+	 * 
+	 * // Instantiate a media player object, specifying the player name
+	 * var mediaPlayer = new car.mediaplayer.MediaPlayer('playerName');
+	 * 
+	 * // Get metadata for the specified node
+	 * mediaPlayer.getMetadata(0, '/songs/1', successCallback, errorCallback);
+	 *
+	 *
+	 *
+	 * @example REST
+	 *
+	 * Request:
+	 * http://&lt;car-ip&gt;/car.mediaplayer/getMetadata?mediaSourceId=0&mediaNodeId=/songs/1
+	 *
+	 * Success Response:
+	 * {
+	 * 	"code": 1,
+	 * 	"data": {
+	 * 		"title": "Bo Bo's Groove",
+	 * 		"duration": 318411,
+	 * 		"artwork": "file:///apps/mediasources/imagecache//mme/2/original",
+	 * 		"artist": "tomprincipato",
+	 * 		"album": "Raising The Roof!",
+	 * 		"genre": "rock",
+	 * 		"disc": 0,
+	 * 		"track": 0,
+	 * 		"width": -1,
+	 * 		"height": -1
+	 * 	}
+	 * }
+	 *
+	 * Error Response:
+	 * {
+	 *		code: -1,
+	 *		msg: "An error has occurred"
+	 * }
+	 */
+	self.getMetadata = function(mediaSourceId, mediaNodeId, success, error) {
+		console.log('car.mediaplayer/client.js::getMetadata', mediaSourceId, mediaNodeId);
+		var args = {
+			mediaSourceId: mediaSourceId,
+			mediaNodeId: mediaNodeId
+		};
+		window.cordova.exec(success, error, _ID, 'getMetadata', args, false);
+	};
+	
+	/**
+	 * Retrieve extended metadata properties for the specified media.
+	 * @param {Number} mediaSourceId The ID of the node's media source.
+	 * @param {String} mediaNodeId The ID of the media node to retrieve metadata for.
+	 * @param {String[]} properties An array of extended metadata property names to retrieve.
+	 * @param {Function} success The function to call on success.
+	 * @param {Function} [error] The function to call on error.
+	 * @memberOf module:car.mediaplayer.MediaPlayer	 
+	 * @method getExtendedMetadata
+	 * @example
+	 *
+	 * function successCallback(metadata) {
+	 * 	console.log("metadata composer = " + metadata.composer + "\n" +
+	 * 				"metadata bpm = " + metadata.bpm);
+	 * }
+	 * 
+	 * function errorCallback(error) {
+	 * 	console.log(error.code, error.msg);
+	 * }
+	 * 
+	 * // Instantiate a media player object, specifying the player name
+	 * var mediaPlayer = new car.mediaplayer.MediaPlayer('playerName');
+	 * 
+	 * // Get metadata for the specified node
+	 * mediaPlayer.getExtendedMetadata(0, '/songs/1', ['composer, 'bpm'], successCallback, errorCallback);
+	 *
+	 *
+	 *
+	 * @example REST
+	 *
+	 * Request:
+	 * http://&lt;car-ip&gt;/car.mediaplayer/getMetadata?mediaSourceId=0&mediaNodeId=/songs/1&properties=composer,bpm
+	 *
+	 * Success Response:
+	 * {
+	 * 	"code": 1,
+	 * 	"data": {
+	 * 		"composer": "Gregory Bonino",
+	 * 		"bpm": 90
+	 * 	}
+	 * }
+	 *
+	 * Error Response:
+	 * {
+	 *		code: -1,
+	 *		msg: "An error has occurred"
+	 * }
+	 */
+	self.getExtendedMetadata = function(mediaSourceId, mediaNodeId, properties, success, error) {
+		console.log('car.mediaplayer/client.js::getExtendedMetadata', mediaSourceId, mediaNodeId, properties);
+		var args = {
+			mediaSourceId: mediaSourceId,
+			mediaNodeId: mediaNodeId,
+			properties: properties
+		};
+		window.cordova.exec(success, error, _ID, 'getExtendedMetadata', args, false);
+	};
+
+	/**
+	 * Return the state of the media player
+	 * @param {Function} success The function to call on success.
+	 * @param {Function} [error] The function to call on error.
+	 * @memberOf module:car.mediaplayer.MediaPlayer	 
+	 * @method getPlayerState
+	 * @example
+	 *
+	 * function successCallback(playerState) {
+	 * 	console.log("player state shuffle mode = " + playerState.shuffleMode + "\n" +
+	 * 				"player state repeat mode = " + playerState.repeatMode + "\n" +
+	 * 				"player state player status = " + playerState.playerStatus + "\n" +
+	 * 				"player state playback rate = " + playerState.playbackRate);
+	 * }
+	 * 
+	 * function errorCallback(error) {
+	 * 	console.log(error.code, error.msg);
+	 * }
+	 * 
+	 * // Instantiate a media player object, specifying the player name
+	 * var mediaPlayer = new car.mediaplayer.MediaPlayer('playerName');
+	 * 
+	 * // Get the current player state
+	 * mediaPlayer.getPlayerState(successCallback, errorCallback);
+	 *
+	 *
+	 *
+	 * @example REST
+	 *
+	 * Request:
+	 * http://&lt;car-ip&gt;/car.mediaplayer/getPlayerState
+	 *
+	 * Success Response:
+	 * {
+	 * 	"code": 1,
+	 * 	"data": {
+	 * 		"shuffleMode": 0,
+	 * 		"repeatMode": 0,
+	 * 		"playerStatus": 2,
+	 * 		"playbackRate": 1
+	 * 	}
+	 * }
+	 *
+	 * Error Response:
+	 * {
+	 *		code: -1,
+	 *		msg: "An error has occurred"
+	 * }
+	 */
+	self.getPlayerState = function(success, error) {
+		console.log('car.mediaplayer/client.js::getPlayerState');
+		window.cordova.exec(success, error, _ID, 'getPlayerState', null, false);
+	};
+	
+	/**
+	 * Start or resume playback of the current tracksession
+	 * @memberOf module:car.mediaplayer.MediaPlayer
+	 * @method play	 
+	 * @example
+	 *
+	 * // Instantiate a media player object, specifying the player name
+	 * var mediaPlayer = new car.mediaplayer.MediaPlayer('playerName');
+	 * 
+	 * // Play
+	 * mediaPlayer.play();
+	 *
+	 *
+	 *
+	 * @example REST
+	 *
+	 * Request:
+	 * http://&lt;car-ip&gt;/car.mediaplayer/play
+	 *
+	 * Success Response:
+	 * {
+	 * 	"code": 1
+	 * }
+	 *
+	 * Error Response:
+	 * {
+	 *		code: -1,
+	 *		msg: "An error has occurred"
+	 * }
+	 */
+	self.play = function() {
+		console.log('car.mediaplayer/client.js::play');
+		window.cordova.exec(null, null, _ID, 'play');
+	};
+	
+	/**
+	 * Pause playback
+	 * @memberOf module:car.mediaplayer.MediaPlayer
+	 * @method pause	 
+	 * @example
+	 *
+	 * // Instantiate a media player object, specifying the player name
+	 * var mediaPlayer = new car.mediaplayer.MediaPlayer('playerName');
+	 * 
+	 * // Pause
+	 * mediaPlayer.pause();
+	 *
+	 *
+	 *
+	 * @example REST
+	 *
+	 * Request:
+	 * http://&lt;car-ip&gt;/car.mediaplayer/pause
+	 *
+	 * Success Response:
+	 * {
+	 * 	"code": 1
+	 * }
+	 *
+	 * Error Response:
+	 * {
+	 *		code: -1,
+	 *		msg: "An error has occurred"
+	 * }
+	 */
+	self.pause = function() {
+		console.log('car.mediaplayer/client.js::pause');
+		window.cordova.exec(null, null, _ID, 'pause');
+	};
+
+	/**
+	 * Stop playback
+	 * @memberOf module:car.mediaplayer.MediaPlayer
+	 * @method stop	 
+	 * @example
+	 *
+	 * // Instantiate a media player object, specifying the player name
+	 * var mediaPlayer = new car.mediaplayer.MediaPlayer('playerName');
+	 * 
+	 * // Stop
+	 * mediaPlayer.stop();
+	 *
+	 *
+	 *
+	 * @example REST
+	 *
+	 * Request:
+	 * http://&lt;car-ip&gt;/car.mediaplayer/stop
+	 *
+	 * Success Response:
+	 * {
+	 * 	"code": 1
+	 * }
+	 *
+	 * Error Response:
+	 * {
+	 *		code: -1,
+	 *		msg: "An error has occurred"
+	 * }
+	 */
+	self.stop = function() {
+		console.log('car.mediaplayer/client.js::stop');
+		window.cordova.exec(null, null, _ID, 'stop');
+	};
+	
+	/**
+	 * Skip to the next track in the active tracksession
+	 * @memberOf module:car.mediaplayer.MediaPlayer
+	 * @method next	 
+	 * @example
+	 *
+	 * // Instantiate a media player object, specifying the player name
+	 * var mediaPlayer = new car.mediaplayer.MediaPlayer('playerName');
+	 * 
+	 * // Skip to the next track
+	 * mediaPlayer.next();
+	 *
+	 *
+	 *
+	 * @example REST
+	 *
+	 * Request:
+	 * http://&lt;car-ip&gt;/car.mediaplayer/next
+	 *
+	 * Success Response:
+	 * {
+	 * 	"code": 1
+	 * }
+	 *
+	 * Error Response:
+	 * {
+	 *		code: -1,
+	 *		msg: "An error has occurred"
+	 * }
+	 */
+	self.next = function() {
+		console.log('car.mediaplayer/client.js::next');
+		window.cordova.exec(null, null, _ID, 'next');
+	};
+	
+	/**
+	 * Skip to the previous track in the active tracksession
+	 * @memberOf module:car.mediaplayer.MediaPlayer
+	 * @method previous	 
+	 * @example
+	 *
+	 * // Instantiate a media player object, specifying the player name
+	 * var mediaPlayer = new car.mediaplayer.MediaPlayer('playerName');
+	 * 
+	 * // Skip to the previous track
+	 * mediaPlayer.previous();
+	 *
+	 *
+	 *
+	 * @example REST
+	 *
+	 * Request:
+	 * http://&lt;car-ip&gt;/car.mediaplayer/previous
+	 *
+	 * Success Response:
+	 * {
+	 * 	"code": 1
+	 * }
+	 *
+	 * Error Response:
+	 * {
+	 *		code: -1,
+	 *		msg: "An error has occurred"
+	 * }
+	 */
+	self.previous = function() {
+		console.log('car.mediaplayer/client.js::previous');
+		window.cordova.exec(null, null, _ID, 'previous');
+	};
+	
+	/**
+	 * Jump to the specified index in the current tracksession
+	 * @param {Number} index The index of the track within the current tracksession.
+	 * @memberOf module:car.mediaplayer.MediaPlayer
+	 * @method jump
+	 * @example
+	 *
+	 * // Instantiate a media player object, specifying the player name
+	 * var mediaPlayer = new car.mediaplayer.MediaPlayer('playerName');
+	 * 
+	 * // Jump to another track in the active tracksession
+	 * mediaPlayer.jump(4);
+	 *
+	 *
+	 *
+	 * @example REST
+	 *
+	 * Request:
+	 * http://&lt;car-ip&gt;/car.mediaplayer/jump?index=4
+	 *
+	 * Success Response:
+	 * {
+	 * 	"code": 1
+	 * }
+	 *
+	 * Error Response:
+	 * {
+	 *		code: -1,
+	 *		msg: "An error has occurred"
+	 * }
+	 */
+	self.jump = function(index) {
+		console.log('car.mediaplayer/client.js::jump', index);
+		window.cordova.exec(null, null, _ID, 'jump', { index: index });
+	};
+	
+	/**
+	 * Seek to a specific position in the current track
+	 * @param {Number} position The track position (in ms).
+	 * @memberOf module:car.mediaplayer.MediaPlayer
+	 * @method seek
+	 * @example
+	 *
+	 * // Instantiate a media player object, specifying the player name
+	 * var mediaPlayer = new car.mediaplayer.MediaPlayer('playerName');
+	 * 
+	 * // Seek
+	 * mediaPlayer.seek(20000);
+	 *
+	 *
+	 *
+	 * @example REST
+	 *
+	 * Request:
+	 * http://&lt;car-ip&gt;/car.mediaplayer/seek?position=20000
+	 *
+	 * Success Response:
+	 * {
+	 * 	"code": 1
+	 * }
+	 *
+	 * Error Response:
+	 * {
+	 *		code: -1,
+	 *		msg: "An error has occurred"
+	 * }
+	 */
+	self.seek = function(position) {
+		console.log('car.mediaplayer/client.js::seek', position);
+		window.cordova.exec(null, null, _ID, 'seek', { position: position });
+	};
+	
+	/**
+	 * Set the playback rate of the media player
+	 * @param {Number} playbackRate The playback rate. A rate of 1.0 is regular play speed. Negative numbers result in
+	 * reverse playback.
+	 * @memberOf module:car.mediaplayer.MediaPlayer
+	 * @method setPlaybackRate
+	 * @example
+	 *
+	 * // Instantiate a media player object, specifying the player name
+	 * var mediaPlayer = new car.mediaplayer.MediaPlayer('playerName');
+	 * 
+	 * // Fast forward 1.5x
+	 * mediaPlayer.setPlaybackRate(1.5);
+	 *
+	 *
+	 *
+	 * @example REST
+	 *
+	 * Request:
+	 * http://&lt;car-ip&gt;/car.mediaplayer/setPlaybackRate?playbackRate=1.5
+	 *
+	 * Success Response:
+	 * {
+	 * 	"code": 1
+	 * }
+	 *
+	 * Error Response:
+	 * {
+	 *		code: -1,
+	 *		msg: "An error has occurred"
+	 * }
+	 */
+	self.setPlaybackRate = function(playbackRate) {
+		console.log('car.mediaplayer/client.js::setPlaybackRate', playbackRate);
+		window.cordova.exec(null, null, _ID, 'setPlaybackRate', { playbackRate: playbackRate });
+	};
+	
+	/**
+	 * Set the shuffle mode for the active tracksession.
+	 * @param {MediaPlayer.ShuffleMode} shuffleMode The shuffle mode. Use values from the <b>MediaPlayer.ShuffleMode</b> enumeration.
+	 * @memberOf module:car.mediaplayer.MediaPlayer
+	 * @method shuffle
+	 * @example
+	 *
+	 * // Instantiate a media player object, specifying the player name
+	 * var mediaPlayer = new car.mediaplayer.MediaPlayer('playerName');
+	 * 
+	 * // Turn shuffle mode on
+	 * mediaPlayer.shuffle(car.mediaplayer.ShuffleMode.SHUFFLE_ON);
+	 *
+	 *
+	 *
+	 * @example REST
+	 *
+	 * Request:
+	 * http://&lt;car-ip&gt;/car.mediaplayer/shuffle?shuffleMode=1
+	 *
+	 * Success Response:
+	 * {
+	 * 	"code": 1
+	 * }
+	 *
+	 * Error Response:
+	 * {
+	 *		code: -1,
+	 *		msg: "An error has occurred"
+	 * }
+	 */
+	self.shuffle = function(shuffleMode) {
+		console.log('car.mediaplayer/client.js::shuffle', shuffleMode);
+		window.cordova.exec(null, null, _ID, 'shuffle', { shuffleMode: shuffleMode });
+	};
+	
+	/**
+	 * Set the repeat mode for the active tracksession
+	 * @param {MediaPlayer.RepeatMode} repeatMode The repeat mode. Use values from the <b>MediaPlayer.RepeatMode</b> enumeration.
+	 * @memberOf module:car.mediaplayer.MediaPlayer
+	 * @method repeat
+	 * @example
+	 *
+	 * // Instantiate a media player object, specifying the player name
+	 * var mediaPlayer = new car.mediaplayer.MediaPlayer('playerName');
+	 * 
+	 * // Turn repeat one mode on
+	 * mediaPlayer.repeat(car.mediaplayer.RepeatMode.REPEAT_ONE);
+	 *
+	 *
+	 *
+	 * @example REST
+	 *
+	 * Request:
+	 * http://&lt;car-ip&gt;/car.mediaplayer/repeat?repeatMode=2
+	 *
+	 * Success Response:
+	 * {
+	 * 	"code": 1
+	 * }
+	 *
+	 * Error Response:
+	 * {
+	 *		code: -1,
+	 *		msg: "An error has occurred"
+	 * }
+	 */
+	self.repeat = function(repeatMode) {
+		console.log('car.mediaplayer/client.js::repeat', repeatMode);
+		window.cordova.exec(null, null, _ID, 'repeat', { repeatMode: repeatMode });
+	};
+
+	/**
+	 * Watch for changes to media sources
+	 * @param {Function} callback The function to call when a change is detected.
+	 * @return {Number} The watch ID.
+	 * @memberOf module:car.mediaplayer.MediaPlayer
+	 * @method watchMediaSource
+	 * @example
+	 * 
+	 * // Define a callback function
+	 * function myCallback(event) {
+	 * }
+	 * 
+	 * // Instantiate a media player object, specifying the name of the player of which to watch
+	 * var mediaPlayer = new car.mediaplayer.MediaPlayer('playerName');
+	 * 
+	 * // Add the watch
+	 * var watchId = mediaPlayer.watchMediaSource(myCallback);
+	 */
+	self.watchMediaSource = function(callback) {
+		var watchId = _utils.createUUID();
+		
+		_watchesMediaSource[watchId] = callback;
+		if (Object.keys(_watchesMediaSource).length === 1) {
+			window.cordova.exec(onMediaSourceChange, null, _ID, 'startEvent', { eventName: Event.MEDIA_SOURCE_CHANGE }, false);
+		}
+
+		return watchId;
+	};
+	
+
+	/**
+	 * Watch for changes to tracksessions
+	 * @param {Function} callback The function to call when a change is detected.
+	 * @return {Number} The watch ID.
+	 * @memberOf module:car.mediaplayer.MediaPlayer
+	 * @method watchTrackSession
+	 * @example
+	 * 
+	 * // Define a callback function
+	 * function myCallback(event) {
+	 * }
+	 * 
+	 * // Instantiate a media player object, specifying the name of the player to watch
+	 * var mediaPlayer = new car.mediaplayer.MediaPlayer('playerName');
+	 * 
+	 * // Add the watch
+	 * var watchId = mediaPlayer.watchTrackSession(myCallback);
+	 */
+	self.watchTrackSession = function(callback) {
+		var watchId = _utils.createUUID();
+		
+		_watchesTrackSession[watchId] = callback;
+		if (Object.keys(_watchesTrackSession).length === 1) {
+			window.cordova.exec(onTrachSessionChange, null, _ID, 'startEvent', { eventName: Event.TRACK_SESSION_CHANGE }, false);
+		}
+
+		return watchId;
+	};
+	
+	/**
+	 * Watch for changes to the media player state
+	 * @param {Function} callback The function to call when a change is detected.
+	 * @memberOf module:car.mediaplayer.MediaPlayer
+	 * @method watchPlayerState
+	 * @return {Number} The watch ID.
+	 * @example
+	 * 
+	 * // Define a callback function
+	 * function myCallback(event) {
+	 * }
+	 * 
+	 * // Instantiate a media player object, specifying the name of the player to watch
+	 * var mediaPlayer = new car.mediaplayer.MediaPlayer('playerName');
+	 * 
+	 * // Add the watch
+	 * var watchId = mediaPlayer.watchPlayerState(myCallback);
+	 */
+	self.watchPlayerState = function(callback) {
+		var watchId = _utils.createUUID();
+		
+		_watchesPlayerState[watchId] = callback;
+		if (Object.keys(_watchesPlayerState).length === 1) {
+			window.cordova.exec(onPlayerStateChange, null, _ID, 'startEvent', { eventName: Event.PLAYER_STATE_CHANGE }, false);
+		}
+
+		return watchId;
+	};
+	
+	/**
+	 * Watch for changes to the current track
+	 * @param {Function} callback The function to call when a change is detected.
+	 * @memberOf module:car.mediaplayer.MediaPlayer
+	 * @method watchTrack
+	 * @return {Number} The watch ID.
+	 * @example
+	 * 
+	 * // Define a callback function
+	 * function myCallback(event) {
+	 * }
+	 * 
+	 * // Instantiate a media player object, specifying the name of the player to watch
+	 * var mediaPlayer = new car.mediaplayer.MediaPlayer('playerName');
+	 * 
+	 * // Add the watch
+	 * var watchId = mediaPlayer.watchTrack(myCallback);
+	 */
+	self.watchTrack = function(callback) {
+		var watchId = _utils.createUUID();
+		
+		_watchesTrack[watchId] = callback;
+		if (Object.keys(_watchesTrack).length === 1) {
+			window.cordova.exec(onTrackChange, null, _ID, 'startEvent', { eventName: Event.TRACK_CHANGE }, false);
+		}
+
+		return watchId;
+	};
+	
+	/**
+	 * Watch for changes to the current track's position
+	 * @param {Function} callback The function to call when a change is detected.
+	 * @memberOf module:car.mediaplayer.MediaPlayer
+	 * @method watchTrackPosition
+	 * @return {Number} The watch ID.
+	 * @example
+	 * 
+	 * // Define a callback function
+	 * function myCallback(event) {
+	 * }
+	 * 
+	 * // Instantiate a media player object, specifying the name of the player to watch
+	 * var mediaPlayer = new car.mediaplayer.MediaPlayer('playerName');
+	 * 
+	 * // Add the watch
+	 * var watchId = mediaPlayer.watchTrackPosition(myCallback);
+	 */
+	self.watchTrackPosition = function(callback) {
+		var watchId = _utils.createUUID();
+		
+		_watchesTrackPosition[watchId] = callback;
+		if (Object.keys(_watchesTrackPosition).length === 1) {
+			window.cordova.exec(onTrackPositionChange, null, _ID, 'startEvent', { eventName: Event.TRACK_POSITION_CHANGE }, false);
+		}
+
+		return watchId;
+	};
+	
+	/**
+	 * Remove a watch
+	 * @param {Number} watchId The watch ID.
+	 * @memberOf module:car.mediaplayer.MediaPlayer
+	 * @method cancelWatch
+	 * @example
+	 * 
+	 * // Instantiate a media player object, specifying the name of the player to watch
+	 * var mediaPlayer = new car.mediaplayer.MediaPlayer('playerName');
+	 * 
+	 * // Add a watch
+	 * var watchId = mediaPlayer.watchMediaSource(function() {});
+	 * 
+	 * // Cancel the watch
+	 * mediaPlayer.cancelWatch(watchId);
+	 */
+	self.cancelWatch = function(watchId) {
+		//is this a radio events watch?
+		if (_watchesMediaSource[watchId]) {
+			delete _watchesMediaSource[watchId];
+			if (Object.keys(_watchesMediaSource).length === 0) {
+				window.cordova.exec(null, null, _ID, 'stopEvent', { eventName: Event.MEDIA_SOURCE_CHANGE }, false);
+			}
+		} else if (_watchesTrackSession[watchId]) {
+			delete _watchesTrackSession[watchId];
+			if (Object.keys(_watchesTrackSession).length === 0) {
+				window.cordova.exec(null, null, _ID, 'stopEvent', { eventName: Event.TRACK_SESSION_CHANGE }, false);
+			}
+		} else if (_watchesPlayerState[watchId]) {
+			delete _watchesPlayerState[watchId];
+			if (Object.keys(_watchesPlayerState).length === 0) {
+				window.cordova.exec(null, null, _ID, 'stopEvent', { eventName: Event.PLAYER_STATE_CHANGE }, false);
+			}
+		} else if (_watchesTrack[watchId]) {
+			delete _watchesTrack[watchId];
+			if (Object.keys(_watchesTrack).length === 0) {
+				window.cordova.exec(null, null, _ID, 'stopEvent', { eventName: Event.TRACK_CHANGE }, false);
+			}
+		} else if (_watchesTrackPosition[watchId]) {
+			delete _watchesTrackPosition[watchId];
+			if (Object.keys(_watchesTrackPosition).length === 0) {
+				window.cordova.exec(null, null, _ID, 'stopEvent', { eventName: Event.TRACK_POSITION_CHANGE }, false);
+			}
+		}
+	};
+	
+	// Initialize the media player
+	if(!open(playerName)) {
+		throw Error('Unable to open MediaPlayer with name "' + playerName + '"');
+	}
+	
+	// Return the instance
+	return this;
+};
+
+/*
+ * Exports are the publicly accessible functions
+ */
+module.exports = {
+		MediaPlayer: MediaPlayer,
+		
+		// Enumeration of media node types.
+		MediaNodeType: MediaNodeType,
+		
+		// Enumeration of media player statuses.
+		PlayerStatus: PlayerStatus,
+		
+		// Enumeration of media source change event types.
+		MediaSourceEvent: MediaSourceEvent,
+		
+		// Enumeration of media source types.
+		MediaSourceType: MediaSourceType,
+		
+		// Enumeration of tracksession change event types.
+		TrackSessionEvent: TrackSessionEvent,
+		
+		//  Enumeration of repeat modes.
+		RepeatMode: RepeatMode,
+		
+		//  Enumeration of shuffle modes.
+		ShuffleMode: ShuffleMode
+};
\ No newline at end of file
diff --git a/plugin/com.qnx.car.radio/plugin.xml b/plugin/com.qnx.car.radio/plugin.xml
new file mode 100644
index 0000000..e7c6d05
--- /dev/null
+++ b/plugin/com.qnx.car.radio/plugin.xml
@@ -0,0 +1,34 @@
+<!--
+Copyright 2013  QNX Software Systems Limited
+
+Licensed under the Apache License, Version 2.0 (the "License"). You
+may not reproduce, modify or distribute this software except in
+compliance with the License. You may obtain a copy of the License
+at: http://www.apache.org/licenses/LICENSE-2.0.
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" basis,
+WITHOUT WARRANTIES OF ANY KIND, either express or implied.
+This file may contain contributions from others, either as
+contributors under the License or as licensors under other terms.
+Please review this entire file for other proprietary rights or license
+notices, as well as the applicable QNX License Guide at
+http://www.qnx.com/legal/licensing/document_archive/current_matrix.pdf
+for other information.
+-->
+<plugin xmlns="http://www.phonegap.com/ns/plugins/1.0"
+	id="com.qnx.car.radio"
+	version="1.0.0">
+	<js-module src="www/client.js">
+		<clobbers target="car.radio" />
+	</js-module>
+
+	<platform name="blackberry10">
+		<source-file src="src/blackberry10/index.js" />
+		<source-file src="src/blackberry10/context.js" />
+		<source-file src="src/blackberry10/radio.js" />
+		<config-file target="www/config.xml" parent="/widget">
+			<feature name="com.qnx.car.radio" value="com.qnx.car.radio" />
+		</config-file>
+	</platform>
+</plugin>
diff --git a/plugin/com.qnx.car.radio/src/blackberry10/context.js b/plugin/com.qnx.car.radio/src/blackberry10/context.js
new file mode 100644
index 0000000..cbd5b7c
--- /dev/null
+++ b/plugin/com.qnx.car.radio/src/blackberry10/context.js
@@ -0,0 +1,64 @@
+/*
+ * Copyright 2013  QNX Software Systems Limited
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"). You
+ * may not reproduce, modify or distribute this software except in
+ * compliance with the License. You may obtain a copy of the License
+ * at: http://www.apache.org/licenses/LICENSE-2.0.
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTIES OF ANY KIND, either express or implied.
+ * This file may contain contributions from others, either as
+ * contributors under the License or as licensors under other terms.
+ * Please review this entire file for other proprietary rights or license
+ * notices, as well as the applicable QNX License Guide at
+ * http://www.qnx.com/legal/licensing/document_archive/current_matrix.pdf
+ * for other information.
+ */
+
+/**
+ * The event context for application events
+ */
+
+var _radio = require("./radio");
+
+/**
+ * Exports are the publicly accessible functions
+ */
+module.exports = {
+	/**
+	 * Method called when the first listener is added for an event
+	 * @param event {String} The event name
+	 * @param trigger {Function} The trigger function to call when the event is fired
+	 */
+	addEventListener: function (event, trigger) {
+		if (event && trigger) {
+			switch (event) {
+				case "radioUpdate":
+					_radio.setTriggerUpdate(trigger);
+					break;
+				case "presetUpdate":
+					_radio.setTriggerPresets(trigger);
+					break;
+			}
+		}
+	},
+
+	/**
+	 * Method called when the last listener is removed for an event
+	 * @param event {String} The event name
+	 */
+	removeEventListener: function (event) {
+		if (event) {
+			switch (event) {
+				case "radioUpdate":
+					_radio.setTriggerUpdate(null);
+					break;
+				case "presetUpdate":
+					_radio.setTriggerPresets(null);
+					break;
+			}
+		}
+	}
+};
diff --git a/plugin/com.qnx.car.radio/src/blackberry10/index.js b/plugin/com.qnx.car.radio/src/blackberry10/index.js
new file mode 100644
index 0000000..41c1f28
--- /dev/null
+++ b/plugin/com.qnx.car.radio/src/blackberry10/index.js
@@ -0,0 +1,264 @@
+/*
+ * Copyright 2013  QNX Software Systems Limited
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"). You
+ * may not reproduce, modify or distribute this software except in
+ * compliance with the License. You may obtain a copy of the License
+ * at: http://www.apache.org/licenses/LICENSE-2.0.
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTIES OF ANY KIND, either express or implied.
+ * This file may contain contributions from others, either as
+ * contributors under the License or as licensors under other terms.
+ * Please review this entire file for other proprietary rights or license
+ * notices, as well as the applicable QNX License Guide at
+ * http://www.qnx.com/legal/licensing/document_archive/current_matrix.pdf
+ * for other information.
+ */
+
+/**
+ * Allows control of radio tuners, presets, and stations.
+ */
+
+var _wwfix = require("../../lib/wwfix"),
+	_radio = require("./radio"),
+	_context = require("./context"),
+	_eventResults = {};
+
+/**
+ * Initializes the extension 
+ */
+function init() {
+	try {
+		_radio.init();
+	} catch (ex) {
+		console.error('Error in webworks ext: radio/index.js:init():', ex);
+	}
+}
+init();
+
+/**
+ * Exports are the publicly accessible functions
+ */
+module.exports = {
+
+	/**
+	 * Turn on event dispatching for a specific event name
+	 * @param {Function} success Function to call if the operation is a success
+	 * @param {Function} fail Function to call if the operation fails
+	 * @param {Object} args The arguments supplied
+	 * @param {Object} env Environment variables
+	 */
+	startEvent: function (success, fail, args, env) {
+		var result = new PluginResult(args, env)
+		var fixedArgs = _wwfix.parseArgs(args);
+		try {
+			if (fixedArgs && fixedArgs.eventName) {
+				_eventResults[fixedArgs.eventName] = result;
+				_context.addEventListener(fixedArgs.eventName, function (data) {
+					result.callbackOk(data, true);
+				});
+				result.noResult(true);
+			} else {
+				throw "Invalid eventName";
+			}
+		} catch (e) {
+			result.error("error in startEvent: " + JSON.stringify(e), false);
+		}
+   },
+
+	/**
+	 * Turn off event dispatching for a specific event name
+	 * @param {Function} success Function to call if the operation is a success
+	 * @param {Function} fail Function to call if the operation fails
+	 * @param {Object} args The arguments supplied
+	 * @param {Object} env Environment variables
+	 */
+	stopEvent: function (success, fail, args, env) {
+		var result = new PluginResult(args, env);
+		var fixedArgs = _wwfix.parseArgs(args);
+		try {
+			if (fixedArgs && fixedArgs.eventName) {
+				//disable the event trigger
+				_context.removeEventListener(fixedArgs.eventName);
+				result.ok(undefined, false);
+
+				//cleanup
+				_eventResults[fixedArgs.eventName].noResult(false);
+				delete _eventResults[fixedArgs.eventName];
+			} else {
+				throw "Invalid eventName";
+			}
+		} catch (e) {
+			result.error("error in stopEvent: " + JSON.stringify(e), false);
+		}
+	},
+
+	/**
+	 * Returns the list of available tuners.
+	 * @param success {Function} Function to call if the operation is a success
+	 * @param fail {Function} Function to call if the operation fails
+	 * @param args {Object} The arguments supplied. Available arguments for this call are: N/A
+	 * @param env {Object} Environment variables
+	 */
+	getTuners: function(success, fail, args, env) {
+		var result = new PluginResult(args, env)
+		try {
+			var data = _radio.getTuners();
+			result.ok(data, false);
+		} catch (e) {
+			result.error(JSON.stringify(e), false);
+		}
+	},
+			
+	/**
+	 * Sets the active tuner by name.
+	 * @param success {Function} Function to call if the operation is a success
+	 * @param fail {Function} Function to call if the operation fails
+	 * @param args {Object} The arguments supplied
+	 * @param env {Object} Environment variables
+	 */
+	setTuner: function(success, fail, args, env) {
+		var result = new PluginResult(args, env)
+		var fixedArgs = _wwfix.parseArgs(args);
+		try {
+			_radio.setTuner(fixedArgs.tuner);
+			result.ok(undefined, false);
+		} catch (e) {
+			result.error(JSON.stringify(e), false);
+		}
+	},
+	
+	/**
+	 * Tune to a specific station, optionally targeting a specific tuner. If the specified
+	 * tuner is not the active tuner, then the station will be automatically selected the next
+	 * time that tuner is set as active.
+	 * @param success {Function} Function to call if the operation is a success
+	 * @param fail {Function} Function to call if the operation fails
+	 * @param args {Object} The arguments supplied
+	 * @param env {Object} Environment variables
+	 */
+	setStation: function(success, fail, args, env) {
+		var result = new PluginResult(args, env)
+		var fixedArgs = _wwfix.parseArgs(args);
+		try {
+			var tuner = (typeof fixedArgs.tuner !== 'undefined') ? fixedArgs.tuner : _radio.getStatus().tuner;
+			_radio.setStation(fixedArgs.station, tuner);
+			result.ok(undefined, false);
+		} catch (e) {
+			result.error(JSON.stringify(e), false);
+		}
+	},
+	
+	/**
+	 * Get the presets for the current tuner. Optionally, a tuner name can be specified, returning
+	 * presets for the specified tuner.
+	 * @param success {Function} Function to call if the operation is a success
+	 * @param fail {Function} Function to call if the operation fails
+	 * @param args {Object} The arguments supplied
+	 * @param env {Object} Environment variables
+	 */
+	getPresets: function(success, fail, args, env) {
+		var result = new PluginResult(args, env)
+		var fixedArgs = _wwfix.parseArgs(args);
+		try {
+			var tuner = (typeof fixedArgs.tuner !== 'undefined') ? fixedArgs.tuner : _radio.getStatus().tuner;
+			var data = _radio.getPresets(tuner);
+			result.ok(data, false);
+		} catch (e) {
+			result.error(JSON.stringify(e), false);
+		}
+	},
+	
+	/**
+	 * Sets the entire list of presets for the specified tuner(s).
+	 * @param success {Function} Function to call if the operation is a success
+	 * @param fail {Function} Function to call if the operation fails
+	 * @param args {Object} The arguments supplied
+	 * @param env {Object} Environment variables
+	 */
+	setPreset: function(success, fail, args, env) {
+		var result = new PluginResult(args, env)
+		var fixedArgs = _wwfix.parseArgs(args);
+		try {
+			var tuner = (typeof fixedArgs.tuner !== 'undefined') ? fixedArgs.tuner : _radio.getStatus().tuner
+			var station = (typeof fixedArgs.station !== 'undefined') ? fixedArgs.station : _radio.getStatus().station
+			_radio.setPreset(fixedArgs.index, fixedArgs.group, station, tuner);
+			result.ok(undefined, false);
+		} catch (e) {
+			result.error(JSON.stringify(e), false);
+		}
+	},
+	
+	/**
+	 * Seek for the next radio station in the given direction
+	 * @param success {Function} Function to call if the operation is a success
+	 * @param fail {Function} Function to call if the operation fails
+	 * @param args {Object} The arguments supplied
+	 * @param env {Object} Environment variables
+	 */
+	seek: function(success, fail, args, env) {
+		var result = new PluginResult(args, env)
+		var fixedArgs = _wwfix.parseArgs(args);
+		try {
+			_radio.seek(fixedArgs.direction);
+			result.ok(undefined, false);
+		} catch (e) {
+			result.error(JSON.stringify(e), false);
+		}
+	},
+	
+	/**
+	 * Scan for available radio stations in the given direction
+	 * @param success {Function} Function to call if the operation is a success
+	 * @param fail {Function} Function to call if the operation fails
+	 * @param args {Object} The arguments supplied
+	 * @param env {Object} Environment variables
+	 */
+	scan: function(success, fail, args, env) {
+		var result = new PluginResult(args, env)
+		var fixedArgs = _wwfix.parseArgs(args);
+		try {
+			_radio.scan(fixedArgs.direction);
+			result.ok(undefined, false);
+		} catch (e) {
+			result.error(JSON.stringify(e), false);
+		}
+	},
+	
+	/**
+	 * Stop scanning
+	 * @param success {Function} Function to call if the operation is a success
+	 * @param fail {Function} Function to call if the operation fails
+	 * @param args {Object} The arguments supplied
+	 * @param env {Object} Environment variables
+	 */
+	scanStop: function(success, fail, args, env) {
+		var result = new PluginResult(args, env)
+		try {
+			_radio.scanStop();
+			result.ok(undefined, false);
+		} catch (e) {
+			result.error(JSON.stringify(e), false);
+		}
+	},
+	
+	/**
+	 * Get the current station metadata.
+	 * @param success {Function} Function to call if the operation is a success
+	 * @param fail {Function} Function to call if the operation fails
+	 * @param args {Object} The arguments supplied. Available arguments for this call are: N/A
+	 * @param env {Object} Environment variables
+	 */
+	getStatus: function(success, fail, args, env) {
+		var result = new PluginResult(args, env)
+		try {
+			var data = _radio.getStatus();
+			result.ok(data, false);
+		} catch (e) {
+			result.error(JSON.stringify(e), false);
+		}
+	},
+};
+
diff --git a/plugin/com.qnx.car.radio/src/blackberry10/radio.js b/plugin/com.qnx.car.radio/src/blackberry10/radio.js
new file mode 100644
index 0000000..b85661a
--- /dev/null
+++ b/plugin/com.qnx.car.radio/src/blackberry10/radio.js
@@ -0,0 +1,322 @@
+/*
+ * Copyright 2013  QNX Software Systems Limited
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"). You
+ * may not reproduce, modify or distribute this software except in
+ * compliance with the License. You may obtain a copy of the License
+ * at: http://www.apache.org/licenses/LICENSE-2.0.
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTIES OF ANY KIND, either express or implied.
+ * This file may contain contributions from others, either as
+ * contributors under the License or as licensors under other terms.
+ * Please review this entire file for other proprietary rights or license
+ * notices, as well as the applicable QNX License Guide at
+ * http://www.qnx.com/legal/licensing/document_archive/current_matrix.pdf
+ * for other information.
+ */
+
+/**
+ * The abstraction layer for radio functionality.
+ */
+
+var	_pps = qnx.webplatform.pps,
+	_tunersPPS,
+	_statusPPS,
+	_statusWriterPPS,
+	_commandPPS,
+	_triggerUpdate,
+	_triggerPresets,
+	_scanTimer,
+	SIMULATION_MODE = true;
+
+/**
+ * Get the current status.
+ * @return {Object} A radio status object.
+ * Ex:
+ * 
+ * {
+ * 	tuner: 'fm',
+ * 	station: 91.5,
+ * 	artist: 'Bjork',
+ * 	genre: 'News & Entertainment',
+ * 	song: 'All is Full of Love',
+ * 	stationName: 'CBC Radio 1',
+ * 	hd: false
+ * }
+ */
+function getStatus() {
+	var status = _statusPPS.data.status;
+	
+	return {
+		tuner		: status.tuner,
+		station 	: status[status.tuner].station,
+		artist		: status.artist,
+		genre		: status.genre,
+		song		: status.song,
+		stationName	: status.station,
+		hd			: status.hd
+	};
+}
+
+/**
+ * Returns the list of available tuners.
+ * @return {Object} An object containing attributes corresponding to each tuner object. The attribute name
+ * is the name of the tuner.
+ */
+function getTuners() {
+	var tuners = [];
+	var keys = Object.keys(_tunersPPS.data.tuners);
+	for (var i=0; i<keys.length; i++) {
+		var tuner = {
+			tuner: keys[i],
+			type: _tunersPPS.data.tuners[keys[i]].type
+		}
+		switch (tuner.type) {
+			case 'analog': 
+				tuner.settings = {
+					rangeMin: _tunersPPS.data.tuners[keys[i]].rangeMin,
+					rangeMax: _tunersPPS.data.tuners[keys[i]].rangeMax,
+					rangeStep: _tunersPPS.data.tuners[keys[i]].rangeStep,
+				};
+				break;
+
+			default:
+				console.error('car.radio::getTuners: Unknown tuner type: ' + tuner.type);
+				continue;
+		}
+		tuners.push(tuner);
+	}
+	return tuners;
+};
+
+/**
+ * Get the presets for the current tuner. Optionally, a tuner name can be specified, returning
+ * presets for the specified tuner.
+ * @param {String} tuner The tuner for the presets 
+ * @return {Array} An array of presets.
+ */
+function getPresets(tuner) {
+		var presets = [];
+
+		var ppsPresets = _statusPPS.data.status[tuner].presets;
+		for (var i=0; i<ppsPresets.length; i++) {
+			presets.push({
+				tuner: tuner,
+				group: tuner + '1',
+				index: i,
+				station: ppsPresets[i]
+			});
+		}
+		return presets;
+};
+
+/**
+ * Exports are the publicly accessible functions
+ */
+module.exports = {
+	/**
+	 * Initializes the extension 
+	 */
+	init: function() {
+		//_tunersPPS
+		_tunersPPS = _pps.createObject("/pps/radio/tuners", _pps.PPSMode.DELTA);
+		_tunersPPS.open(_pps.FileMode.RDONLY);
+		
+		//_statusPPS
+		_statusPPS = _pps.createObject("/pps/radio/status", _pps.PPSMode.DELTA);
+		_statusPPS.onNewData = function(data) {
+			//status updates
+			if (_triggerUpdate) {
+				_triggerUpdate(getStatus());
+			}
+			//preset updates
+			if (_triggerPresets && data && data.changed) {
+				var tuners = getTuners();
+				for (var i=0; i<tuners.length; i++) {
+					if (typeof data.changed[tuners[i].tuner] !== 'undefined') {
+						_triggerPresets(getPresets(tuners[i].tuner));
+					}
+				}
+			}
+		};
+		_statusPPS.open(_pps.FileMode.RDONLY);
+		
+		//writing pps commands
+		if (SIMULATION_MODE) {
+			_commandPPS = _pps.createObject("/pps/radio/status", _pps.PPSMode.DELTA);
+		} else {
+			_commandPPS = _pps.createObject("/pps/radio/command", _pps.PPSMode.DELTA);
+		}
+		_commandPPS.open(_pps.FileMode.WRONLY);
+
+		//status writer, used to save presets
+		_statusWriterPPS = _pps.createObject("/pps/radio/status", _pps.PPSMode.DELTA);
+		_statusWriterPPS.open(_pps.FileMode.WRONLY);
+	},
+		
+	/**
+	 * Sets the trigger function to call when a status event is fired
+	 * @param trigger {Function} The trigger function to call when the event is fired
+	 */
+	setTriggerUpdate: function(trigger) {
+		_triggerUpdate = trigger;
+	},
+	
+
+	/**
+	 * Sets the trigger function to call when a preset event is fired
+	 * @param trigger {Function} The trigger function to call when the event is fired
+	 */
+	setTriggerPresets: function(trigger) {
+		_triggerPresets = trigger;
+	},
+	
+	/**
+	 * Returns the list of available tuners.
+	 * @return {Object} An object containing attributes corresponding to each tuner object. The attribute name
+	 * is the name of the tuner.
+	 */
+	getTuners: function() {
+		return getTuners();
+	},
+
+	/**
+	 * Sets the active tuner by name.
+	 * @param tuner {String} The name of tuner to set as active
+	 */
+	setTuner: function(tuner) {
+		_commandPPS.write({tuner: tuner});
+	},	
+	
+	/**
+	 * Tune to a specific station, optionally targeting a specific tuner. If the specified
+	 * tuner is not the active tuner, then the station will be automatically selected the next
+	 * time that tuner is set as active.
+	 * @param station {Number} The target station
+	 * @param tuner {String} (optional) The target tuner name
+	 */
+	setStation: function(station, tuner) {
+		if (SIMULATION_MODE) {
+			var obj = {};
+			obj[tuner] = _statusPPS.data.status[tuner];
+			obj[tuner].station = station;
+			
+			_commandPPS.write(obj);
+		} else {
+			// If the station is not for the active tuner, then write the selected station
+			// directly to the status PPS object since nothing needs to happen at the radio
+			// service level.
+			if(tuner != _statusPPS.data.status.tuner) {
+				var obj = {};
+				obj[tuner] = _statusPPS.data.status[tuner];
+				obj[tuner].station = station;
+
+				_statusWriterPPS.write(obj);
+			}
+			
+			// If the station is for the current tuner, then send the tune command to the command PPS
+			_commandPPS.write({ tune: station });
+		}
+	},
+	
+	/**
+	 * Get the presets for the current tuner. Optionally, a tuner name can be specified, returning
+	 * presets for the specified tuner.
+	 * @param {String} tuner The tuner for the presets 
+	 * @return {Array} An array of presets.
+	 */
+	getPresets: function(tuner) {
+		return getPresets(tuner);
+	},
+	
+	/**
+	 * Sets the current station as a preset at the specified index. A station and tuner can optionally
+	 * be specified to set the non-current station as a preset, and/or for the non-active tuner. 
+	 * @param index {Number} The preset index
+	 * @param group {Number} The preset group
+	 * @param station {Number} (optional) The station to set as the preset. If not specified, the current station will be used.
+	 * @param tuner {String} (optional) The station's tuner. If not specified, the active tuner will be used.
+	 */
+	setPreset: function(index, group, station, tuner) {
+		var obj = {};
+		obj[tuner] = _statusPPS.data.status[tuner];
+		obj[tuner].presets[index] = station;
+		
+		// TODO: Ensure station preset is within the range of the specified tuner
+		// TODO: Handle group
+		_statusWriterPPS.write(obj);
+	},
+	
+	/**
+	 * Seek for the next radio station in the given direction
+	 * @param direction {String} The direction to seek ('up' or 'down')
+	 */
+	seek: function(direction) {
+		if (SIMULATION_MODE) {
+			var tuner = _tunersPPS.data.tuners[_statusPPS.data.status.tuner];
+			
+			var numSteps = (tuner.rangeMax - tuner.rangeMin) / tuner.rangeStep;
+			var rand = Math.ceil(Math.random() / 5 * numSteps);
+			if (direction == 'down') {
+				rand = -rand;
+			}
+			
+			var currStation = parseFloat(_statusPPS.data.status[_statusPPS.data.status.tuner].station);
+			var targetStation = currStation + (rand  * tuner.rangeStep);
+			if (targetStation < tuner.rangeMin) {
+				targetStation = tuner.rangeMax - (tuner.rangeMin - targetStation);
+			} else if (targetStation > tuner.rangeMax) {
+				targetStation = tuner.rangeMin + (targetStation - tuner.rangeMax);
+			}
+			
+			//ensure proper number of decimals
+			var strStation = new String(currStation)
+			var decpos = strStation.indexOf('.');
+			if (decpos > -1) {
+				targetStation = new Number(targetStation + '').toFixed(strStation.length - decpos - 1);
+			}
+			
+			this.setStation(targetStation, _statusPPS.data.status.tuner);
+		} else {
+			_commandPPS.write({ seek: direction });
+		}
+	},
+	
+	/**
+	 * Scan for available radio stations in the given direction.
+	 * @param direction {String} The direction to scan ('up' or 'down')
+	 */
+	scan: function(direction) {
+		if (_scanTimer !== undefined) {
+			clearInterval(_scanTimer);
+		}
+
+		var self = this;
+			_scanTimer = setInterval(function() { self.seek(direction) }, 3000);
+			this.seek(direction);
+	},
+	
+	/**
+	 * Stop station scanning if in progress.
+	 */
+	scanStop: function() {
+		if(_scanTimer !== undefined) {
+			clearInterval(_scanTimer);
+		}
+		
+		//get the server side to stop seeking in the middle of a seek.
+		if (!SIMULATION_MODE) {
+			_commandPPS.write({ seek: "stop" });
+		}
+	},
+	
+	/**
+	 * Get the current status.
+	 * @return {Object} A radio status object.
+	 */
+	getStatus: function() {
+		return getStatus();
+	},
+};
diff --git a/plugin/com.qnx.car.radio/www/client.js b/plugin/com.qnx.car.radio/www/client.js
new file mode 100644
index 0000000..f48fe30
--- /dev/null
+++ b/plugin/com.qnx.car.radio/www/client.js
@@ -0,0 +1,637 @@
+/*
+ * Copyright 2013  QNX Software Systems Limited
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"). You
+ * may not reproduce, modify or distribute this software except in
+ * compliance with the License. You may obtain a copy of the License
+ * at: http://www.apache.org/licenses/LICENSE-2.0.
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTIES OF ANY KIND, either express or implied.
+ * This file may contain contributions from others, either as
+ * contributors under the License or as licensors under other terms.
+ * Please review this entire file for other proprietary rights or license
+ * notices, as well as the applicable QNX License Guide at
+ * http://www.qnx.com/legal/licensing/document_archive/current_matrix.pdf
+ * for other information.
+ */
+
+/**
+ * @module car.radio
+ * @static
+ *
+ * @description Manages the radio interface
+ */
+
+var _ID = "com.qnx.car.radio",
+	_self = {},
+	_utils = cordova.require('cordova/utils'),
+	_watchesRadio = {};
+	_watchesPresets = {};
+
+/**
+ * Handles radio update events
+ * @param data {Array} The updated data provided by the event 
+ * @private
+ */
+function onUpdateRadio(data) {
+	var keys = Object.keys(_watchesRadio);
+	for (var i=0; i<keys.length; i++) {
+		setTimeout(_watchesRadio[keys[i]](data), 0);
+	}
+}
+
+/**
+ * Handles preset update events 
+ * @param data {Array} The updated data provided by the event 
+ * @private
+ */
+function onUpdatePresets(data) {
+	var keys = Object.keys(_watchesPresets);
+	for (var i=0; i<keys.length; i++) {
+		setTimeout(_watchesPresets[keys[i]](data), 0);
+	}
+}
+
+/**
+ * Watch for metadata updates
+ * @param {Function} callback The function to call when a change is detected.
+ * @return {Number} An ID for the added watch.
+ * @memberOf module:car.radio
+ * @method watchRadio 
+ * @example
+ * 
+ * //define a callback function
+ * function myCallback(metadata) {
+ *		console.log("tuner = " + data.tuner + "\n" +
+ *					"artist = " + data.artist + "\n" +
+ *					"genre = " + data.genre + "\n" +
+ *					"song = " + data.song + "\n" +
+ *					"station = " + data.station + "\n" +
+ *					"stationName = " + data.stationName + "\n" +
+ *					"hd = " + data.hd
+ *		);
+ * }
+ * 
+ * var watchId = car.radio.watchRadio(myCallback);
+ */
+_self.watchRadio = function (callback) {
+	var watchId = _utils.createUUID();
+	
+	_watchesRadio[watchId] = callback;
+	if (Object.keys(_watchesRadio).length === 1) {
+		window.cordova.exec(onUpdateRadio, null, _ID, 'startEvent', { eventName: 'radioUpdate' }, false);
+	}
+
+	return watchId;
+};
+
+/**
+ * Watch for preset updates
+ * @param {Function} callback The function to call when a change is detected.
+ * @return {Number} An ID for the added watch.
+ * @memberOf module:car.radio
+ * @method watchPresets  
+ * @example
+ * 
+ * function myCallback(presets) {
+ *		//iterate through all the presets
+ *		for (var i=0; i&lt;presets.length; i++) {
+ *			console.log("preset tuner = " + presets[i].tuner + "\n" +
+ *						"preset station = " + presets[i].station + "\n" +
+ *						"preset index = " + presets[i].index + "\n" +
+ *						"preset group = " + presets[i].group
+ *			);
+ *		}
+ * }
+ * 
+ * var watchId = car.radio.watchPresets(myCallback);
+ */
+_self.watchPresets = function (callback) {
+	var watchId = _utils.createUUID();
+	
+	_watchesPresets[watchId] = callback;
+	if (Object.keys(_watchesPresets).length === 1) {
+		window.cordova.exec(onUpdatePresets, null, _ID, 'startEvent', { eventName: 'presetUpdate' }, false);
+	}
+
+	return watchId;
+};
+
+/**
+ * Stop watching for metadata updates
+ * @param {Number} watchId The watch ID as returned by <i>car.radio.watchRadio()</i> or <i>car.radio.watchPresets()</i>.
+ * @memberOf module:car.radio
+ * @method cancelWatch   
+ * @example
+ * 
+ * car.radio.cancelWatch(watchId);
+ */
+_self.cancelWatch = function (watchId) {
+	//is this a radio events watch?
+	if (_watchesRadio[watchId]) {
+		delete _watchesRadio[watchId];
+		if (Object.keys(_watchesRadio).length === 0) {
+			window.cordova.exec(null, null, _ID, 'stopEvent', { eventName: 'radioUpdate' }, false);
+		}
+	} else if (_watchesPresets[watchId]) {
+		delete _watchesPresets[watchId];
+		if (Object.keys(_watchesPresets).length === 0) {
+			window.cordova.exec(null, null, _ID, 'stopEvent', { eventName: 'presetUpdate' }, false);
+		}
+	}
+};
+
+/**
+ * Return the list of available tuners
+ * @param {Function} successCallback The function to call on success.
+ * @param {Function} [errorCallback] The function to call if there is an error.
+ * @memberOf module:car.radio
+ * @method getTuners  
+ * @example 
+ *
+ * //define your callback function(s)
+ * function successCallback(tuners) {
+ *		//iterate through all the tuners
+ *		for (var i=0; i&lt;tuners.length; i++) {
+ *			console.log("tuner name = " + tuners[i].tuner + "\n" +
+ *						"tuner type = " + tuners[i].type + "\n" +
+ *						"tuner range min = " + tuners[i].settings.rangeMin + "\n" +
+ *						"tuner range max = " + tuners[i].settings.rangeMax + "\n" +
+ *						"tuner range step = " + tuners[i].settings.rangeStep
+ *			);
+ *		}
+ * }
+ *
+ * function errorCallback(error) {
+ *		console.log(error.code, error.msg);
+ * }
+ *
+ * //call the method
+ * car.radio.getTuners(successCallback, errorCallback);
+ *
+ *
+ *
+ * @example REST
+ *
+ * Request:
+ * http://&lt;car-ip&gt;/car/radio/getTuners
+ *
+ * Success Response:
+ * {
+ *		code: 1,
+ *		data: [ 
+ * 			{ 
+ *				tuner: 'am', 
+ *				type: 'analog', 
+ *				settings: {
+ *					rangeMin: 880,
+ *					rangeMax: 1600,
+ *					rangeStep: 10
+ *				}
+ *			}, { 
+ *				tuner: 'fm', 
+ *				type: 'analog', 
+ *				settings: {
+ *					rangeMin: 88.9,
+ *					rangeMax: 107.1,
+ *					rangeStep: 0.2
+ *				}
+ *			}
+ *		]
+ * }
+ *
+ * Error Response:
+ * {
+ *		code: -1,
+ *		msg: "An error has occurred"
+ * }
+ */
+_self.getTuners = function(successCallback, errorCallback) {
+	window.cordova.exec(successCallback, errorCallback, _ID, 'getTuners', null, false);
+};
+		
+/**
+ * Set the active tuner by name
+ * @param {String} tuner The name of tuner to set as active.
+ * @param {Function} [successCallback] The function to call on success.
+ * @param {Function} [errorCallback] The function to call if there is an error.
+ * @memberOf module:car.radio
+ * @method setTuner
+ * @example 
+ *
+ * //define your callback function(s)
+ * function successCallback() {
+ *		console.log('tuner was successfully set');
+ * }
+ *
+ * function errorCallback(error) {
+ *		console.log(error.code, error.msg);
+ * }
+ *
+ * //call the method
+ * car.radio.setTuner('fm', successCallback, errorCallback);
+ *
+ *
+ *
+ * @example REST
+ *
+ * Request:
+ * http://&lt;car-ip&gt;/car/radio/setTuner?tuner=fm
+ *
+ * Success Response:
+ * {
+ *		code: 1,
+ * }
+ *
+ * Error Response:
+ * {
+ *		code: -1,
+ *		msg: "An error has occurred"
+ * }
+ */
+_self.setTuner = function(tuner, successCallback, errorCallback) {
+	var args = { 
+		tuner: tuner 
+	};
+	window.cordova.exec(successCallback, errorCallback, _ID, 'setTuner', args, false);
+};
+
+/**
+ * @description <p>Tune to a specific station, optionally targeting a specific tuner
+ * <p>If the specified tuner is not the active tuner, then the station will be 
+ * automatically selected the next time that tuner is set as active.
+ * @param {Number} station The target station.
+ * @param {Function} successCallback The function to call on success.
+ * @param {Function} [errorCallback] The function to call if there is an error.
+ * @param {String} [tuner] The tuner name. If not specified, the active tuner is used.
+ * @memberOf module:car.radio
+ * @method setStation
+ * @example 
+ *
+ * //define your callback function(s)
+ * function successCallback() {
+ *		console.log('station was successfully set');
+ * }
+ *
+ * function errorCallback(error) {
+ *		console.log(error.code, error.msg);
+ * }
+ *
+ * //call the method
+ * car.radio.setStation(88.5, successCallback, errorCallback);
+ *
+ *
+ *
+ * @example REST
+ *
+ * Request:
+ * http://&lt;car-ip&gt;/car/radio/setStation?station=88.5
+ *
+ * Success Response:
+ * {
+ *		code: 1,
+ * }
+ *
+ * Error Response:
+ * {
+ *		code: -1,
+ *		msg: "An error has occurred"
+ * }
+ */
+_self.setStation = function(station, successCallback, errorCallback, tuner) {
+	var args = { 
+		station: station 
+	};
+	if (tuner) {
+		args.tuner = tuner;
+	}
+	window.cordova.exec(successCallback, errorCallback, _ID, 'setStation', args, false);
+};
+
+/**
+ * @description <p>Get the presets for the current tuner
+ * <p>Optionally, a tuner name can be specified, returning
+ * presets for the specified tuner.
+ * @param {Function} successCallback The function to call on success.
+ * @param {Function} [errorCallback] The function to call if there is an error.
+ * @param {String} [tuner] The tuner of the presets. If not specified, the active tuner is used.
+ * @memberOf module:car.radio
+ * @method getPresets
+ * @example 
+ *
+ * //define your callback function(s)
+ * function successCallback(presets) {
+ *		//iterate through all the presets
+ *		for (var i=0; i&lt;presets.length; i++) {
+ *			console.log("preset tuner = " + presets[i].tuner + "\n" +
+ *						"preset station = " + presets[i].station + "\n" +
+ *						"preset index = " + presets[i].index + "\n" +
+ *						"preset group = " + presets[i].group
+ *			);
+ *		}
+ * }
+ *
+ * function errorCallback(error) {
+ *		console.log(error.code, error.msg);
+ * }
+ *
+ * //call the method
+ * car.radio.getPresets(successCallback, errorCallback);
+ *
+ *
+ *
+ * @example REST
+ *
+ * Request:
+ * http://&lt;car-ip&gt;/car/radio/getPresets
+ *
+ * Success Response:
+ * {
+ *		code: 1,
+ *		data: [ 
+ * 			{ 
+ *				tuner: 'am', 
+ *				station: '880', 
+ *				index: 0, 
+ *				group: 'am1', 
+ *			}, { 
+ *				tuner: 'am', 
+ *				station: '1010', 
+ *				index: 1, 
+ *				group: 'am1', 
+ *			},{
+ *				...	
+ *			}
+ *		]
+ * }
+ *
+ * Error Response:
+ * {
+ *		code: -1,
+ *		msg: "An error has occurred"
+ * }
+ */
+_self.getPresets = function(successCallback, errorCallback, tuner) {
+	var args = {};
+	if (tuner) {
+		args.tuner = tuner;
+	}
+    window.cordova.exec(successCallback, errorCallback, _ID, 'getPresets', args, false);
+};
+
+/**
+ * @description <p>Set the current station as a preset at the specified index
+ * <p>You can optionally specify a different station and tuner as a preset. 
+ * @param {Number} index The preset index.
+ * @param {String} group The preset group.
+ * @param {Number} [station] The station to set as the preset. If this is not specified, the current station is used.
+ * @param {String} [tuner] The tuner of the presets. If not specified, the active tuner is used.
+ * @param {Function} [successCallback] The function to call on success.
+ * @param {Function} [errorCallback] The function to call if there is an error.
+ * @memberOf module:car.radio
+ * @method setPreset
+ * @example 
+ *
+ * //define your callback function(s)
+ * function successCallback() {
+ *		console.log('preset was successfully set');
+ * }
+ *
+ * function errorCallback(error) {
+ *		console.log(error.code, error.msg);
+ * }
+ *
+ * //call the method
+ * car.radio.setPreset(0, 'am1', 1030, 'am', successCallback, errorCallback);
+ *
+ *
+ *
+ * @example REST
+ *
+ * Request:
+ * http://&lt;car-ip&gt;/car/radio/setPreset?index=0&group=am1&station=1030&tuner=am
+ *
+ * Success Response:
+ * {
+ *		code: 1,
+ * }
+ *
+ * Error Response:
+ * {
+ *		code: -1,
+ *		msg: "An error has occurred"
+ * }
+ */
+_self.setPreset = function(index, group, station, tuner, successCallback, errorCallback) {
+	var args = { 
+		index: index,
+		group: group
+	};
+	if (station) {
+		args["station"] = station;
+	}
+	if (tuner) {
+		args["tuner"] = tuner;
+	}
+	window.cordova.exec(successCallback, errorCallback, _ID, 'setPreset', args, false);
+};
+
+/**
+ * Seek for the next radio station in the specified direction
+ * @param {String} direction The direction to seek ('up' or 'down').
+ * @param {Function} [successCallback] The function to call on success.
+ * @param {Function} [errorCallback] The function to call if there is an error.
+ * @memberOf module:car.radio
+ * @method seek
+ * @example 
+ *
+ * //define your callback function(s)
+ * function successCallback() {
+ *		console.log('seek was successfully called');
+ * }
+ *
+ * function errorCallback(error) {
+ *		console.log(error.code, error.msg);
+ * }
+ *
+ * //call the method
+ * car.radio.seek('up', successCallback, errorCallback);
+ *
+ *
+ *
+ * @example REST
+ *
+ * Request:
+ * http://&lt;car-ip&gt;/car/radio/seek?direction=up
+ *
+ * Success Response:
+ * {
+ *		code: 1,
+ * }
+ *
+ * Error Response:
+ * {
+ *		code: -1,
+ *		msg: "An error has occurred"
+ * }
+ */
+_self.seek = function(direction, successCallback, errorCallback) {
+	var args = { 
+		direction: direction 
+	};
+    window.cordova.exec(successCallback, errorCallback, _ID, 'seek', args, false);
+};
+
+/**
+ * Scan for available radio stations in the specified direction
+ * @param {String} direction The direction to seek ('up' or 'down').
+ * @param {Function} [successCallback] The function to call on success.
+ * @param {Function} [errorCallback] The function to call if there is an error.
+ * @memberOf module:car.radio
+ * @method scan
+ * @example 
+ *
+ * //define your callback function(s)
+ * function successCallback() {
+ *		console.log('scan was successfully called');
+ * }
+ *
+ * function errorCallback(error) {
+ *		console.log(error.code, error.msg);
+ * }
+ *
+ * //call the method
+ * car.radio.scan('up', successCallback, errorCallback);
+ *
+ *
+ *
+ * @example REST
+ *
+ * Request:
+ * http://&lt;car-ip&gt;/car/radio/scan?direction=up
+ *
+ * Success Response:
+ * {
+ *		code: 1,
+ * }
+ *
+ * Error Response:
+ * {
+ *		code: -1,
+ *		msg: "An error has occurred"
+ * }
+ */
+_self.scan = function(direction, successCallback, errorCallback) {
+	var args = { 
+		direction: direction 
+	};
+    window.cordova.exec(successCallback, errorCallback, _ID, 'scan', args, false);
+};
+
+/**
+ * Stop station scanning if in progress
+ * @param {Function} [successCallback] The function to call on success.
+ * @param {Function} [errorCallback] The function to call if there is an error.
+ * @memberOf module:car.radio
+ * @method scanStop
+ * @example 
+ *
+ * //define your callback function(s)
+ * function successCallback() {
+ *		console.log('scanStop was successfully called');
+ * }
+ *
+ * function errorCallback(error) {
+ *		console.log(error.code, error.msg);
+ * }
+ *
+ * //call the method
+ * car.radio.scanStop(successCallback, errorCallback);
+ *
+ *
+ *
+ * @example REST
+ *
+ * Request:
+ * http://&lt;car-ip&gt;/car/radio/scanStop
+ *
+ * Success Response:
+ * {
+ *		code: 1,
+ * }
+ *
+ * Error Response:
+ * {
+ *		code: -1,
+ *		msg: "An error has occurred"
+ * }
+ */
+_self.scanStop = function(successCallback, errorCallback) {
+    window.cordova.exec(successCallback, errorCallback, _ID, 'scanStop', null, false);
+};
+
+/**
+ * Get the current station metadata
+ * @param {Function} [successCallback] The function to call on success.
+ * @param {Function} [errorCallback] The function to call if there is an error.
+ * @memberOf module:car.radio
+ * @method getStatus
+ * @example 
+ *
+ * //define your callback function(s)
+ * function successCallback(data) {
+ *			console.log("tuner = " + data.tuner + "\n" +
+ *						"artist = " + data.artist + "\n" +
+ *						"genre = " + data.genre + "\n" +
+ *						"song = " + data.song + "\n" +
+ *						"station = " + data.station + "\n" +
+ *						"stationName = " + data.stationName + "\n" +
+ *						"hd = " + data.hd
+ *			);
+ *		}
+ * }
+ *
+ * function errorCallback(error) {
+ *		console.log(error.code, error.msg);
+ * }
+ *
+ * //call the method
+ * car.radio.getStatus(successCallback, errorCallback);
+ *
+ *
+ *
+ * @example REST
+ *
+ * Request:
+ * http://&lt;car-ip&gt;/car/radio/getStatus
+ *
+ * Success Response:
+ * {
+ *		code: 1,
+ *		data: {
+ *     		tuner: 'fm'
+ *     		artist: 'Bjork',
+ *     		genre: 'News & Entertainment',
+ *     		song: 'All is Full of Love',
+ *     		station: 91.5,
+ *     		stationName: 'CBC Radio 1',
+ *     		hd: false
+ *		}
+ * }
+ *
+ * Error Response:
+ * {
+ *		code: -1,
+ *		msg: "An error has occurred"
+ * }
+ */
+_self.getStatus = function(successCallback, errorCallback) {
+	window.cordova.exec(successCallback, errorCallback, _ID, 'getStatus', null, false);
+};
+
+
+//Export
+module.exports = _self;
+
diff --git a/plugin/com.qnx.radio/plugin.xml b/plugin/com.qnx.radio/plugin.xml
deleted file mode 100644
index c112ee8..0000000
--- a/plugin/com.qnx.radio/plugin.xml
+++ /dev/null
@@ -1,34 +0,0 @@
-<!--
-Copyright 2013  QNX Software Systems Limited
-
-Licensed under the Apache License, Version 2.0 (the "License"). You
-may not reproduce, modify or distribute this software except in
-compliance with the License. You may obtain a copy of the License
-at: http://www.apache.org/licenses/LICENSE-2.0.
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" basis,
-WITHOUT WARRANTIES OF ANY KIND, either express or implied.
-This file may contain contributions from others, either as
-contributors under the License or as licensors under other terms.
-Please review this entire file for other proprietary rights or license
-notices, as well as the applicable QNX License Guide at
-http://www.qnx.com/legal/licensing/document_archive/current_matrix.pdf
-for other information.
--->
-<plugin xmlns="http://www.phonegap.com/ns/plugins/1.0"
-	id="com.qnx.radio"
-	version="1.0.0">
-	<js-module src="www/client.js">
-		<clobbers target="qnx.radio" />
-	</js-module>
-
-	<platform name="blackberry10">
-		<source-file src="src/blackberry10/index.js" />
-		<source-file src="src/blackberry10/context.js" />
-		<source-file src="src/blackberry10/radio.js" />
-		<config-file target="www/config.xml" parent="/widget">
-			<feature name="com.qnx.radio" value="com.qnx.radio" />
-		</config-file>
-	</platform>
-</plugin>
diff --git a/plugin/com.qnx.radio/src/blackberry10/context.js b/plugin/com.qnx.radio/src/blackberry10/context.js
deleted file mode 100644
index cbd5b7c..0000000
--- a/plugin/com.qnx.radio/src/blackberry10/context.js
+++ /dev/null
@@ -1,64 +0,0 @@
-/*
- * Copyright 2013  QNX Software Systems Limited
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"). You
- * may not reproduce, modify or distribute this software except in
- * compliance with the License. You may obtain a copy of the License
- * at: http://www.apache.org/licenses/LICENSE-2.0.
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTIES OF ANY KIND, either express or implied.
- * This file may contain contributions from others, either as
- * contributors under the License or as licensors under other terms.
- * Please review this entire file for other proprietary rights or license
- * notices, as well as the applicable QNX License Guide at
- * http://www.qnx.com/legal/licensing/document_archive/current_matrix.pdf
- * for other information.
- */
-
-/**
- * The event context for application events
- */
-
-var _radio = require("./radio");
-
-/**
- * Exports are the publicly accessible functions
- */
-module.exports = {
-	/**
-	 * Method called when the first listener is added for an event
-	 * @param event {String} The event name
-	 * @param trigger {Function} The trigger function to call when the event is fired
-	 */
-	addEventListener: function (event, trigger) {
-		if (event && trigger) {
-			switch (event) {
-				case "radioUpdate":
-					_radio.setTriggerUpdate(trigger);
-					break;
-				case "presetUpdate":
-					_radio.setTriggerPresets(trigger);
-					break;
-			}
-		}
-	},
-
-	/**
-	 * Method called when the last listener is removed for an event
-	 * @param event {String} The event name
-	 */
-	removeEventListener: function (event) {
-		if (event) {
-			switch (event) {
-				case "radioUpdate":
-					_radio.setTriggerUpdate(null);
-					break;
-				case "presetUpdate":
-					_radio.setTriggerPresets(null);
-					break;
-			}
-		}
-	}
-};
diff --git a/plugin/com.qnx.radio/src/blackberry10/index.js b/plugin/com.qnx.radio/src/blackberry10/index.js
deleted file mode 100644
index 41c1f28..0000000
--- a/plugin/com.qnx.radio/src/blackberry10/index.js
+++ /dev/null
@@ -1,264 +0,0 @@
-/*
- * Copyright 2013  QNX Software Systems Limited
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"). You
- * may not reproduce, modify or distribute this software except in
- * compliance with the License. You may obtain a copy of the License
- * at: http://www.apache.org/licenses/LICENSE-2.0.
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTIES OF ANY KIND, either express or implied.
- * This file may contain contributions from others, either as
- * contributors under the License or as licensors under other terms.
- * Please review this entire file for other proprietary rights or license
- * notices, as well as the applicable QNX License Guide at
- * http://www.qnx.com/legal/licensing/document_archive/current_matrix.pdf
- * for other information.
- */
-
-/**
- * Allows control of radio tuners, presets, and stations.
- */
-
-var _wwfix = require("../../lib/wwfix"),
-	_radio = require("./radio"),
-	_context = require("./context"),
-	_eventResults = {};
-
-/**
- * Initializes the extension 
- */
-function init() {
-	try {
-		_radio.init();
-	} catch (ex) {
-		console.error('Error in webworks ext: radio/index.js:init():', ex);
-	}
-}
-init();
-
-/**
- * Exports are the publicly accessible functions
- */
-module.exports = {
-
-	/**
-	 * Turn on event dispatching for a specific event name
-	 * @param {Function} success Function to call if the operation is a success
-	 * @param {Function} fail Function to call if the operation fails
-	 * @param {Object} args The arguments supplied
-	 * @param {Object} env Environment variables
-	 */
-	startEvent: function (success, fail, args, env) {
-		var result = new PluginResult(args, env)
-		var fixedArgs = _wwfix.parseArgs(args);
-		try {
-			if (fixedArgs && fixedArgs.eventName) {
-				_eventResults[fixedArgs.eventName] = result;
-				_context.addEventListener(fixedArgs.eventName, function (data) {
-					result.callbackOk(data, true);
-				});
-				result.noResult(true);
-			} else {
-				throw "Invalid eventName";
-			}
-		} catch (e) {
-			result.error("error in startEvent: " + JSON.stringify(e), false);
-		}
-   },
-
-	/**
-	 * Turn off event dispatching for a specific event name
-	 * @param {Function} success Function to call if the operation is a success
-	 * @param {Function} fail Function to call if the operation fails
-	 * @param {Object} args The arguments supplied
-	 * @param {Object} env Environment variables
-	 */
-	stopEvent: function (success, fail, args, env) {
-		var result = new PluginResult(args, env);
-		var fixedArgs = _wwfix.parseArgs(args);
-		try {
-			if (fixedArgs && fixedArgs.eventName) {
-				//disable the event trigger
-				_context.removeEventListener(fixedArgs.eventName);
-				result.ok(undefined, false);
-
-				//cleanup
-				_eventResults[fixedArgs.eventName].noResult(false);
-				delete _eventResults[fixedArgs.eventName];
-			} else {
-				throw "Invalid eventName";
-			}
-		} catch (e) {
-			result.error("error in stopEvent: " + JSON.stringify(e), false);
-		}
-	},
-
-	/**
-	 * Returns the list of available tuners.
-	 * @param success {Function} Function to call if the operation is a success
-	 * @param fail {Function} Function to call if the operation fails
-	 * @param args {Object} The arguments supplied. Available arguments for this call are: N/A
-	 * @param env {Object} Environment variables
-	 */
-	getTuners: function(success, fail, args, env) {
-		var result = new PluginResult(args, env)
-		try {
-			var data = _radio.getTuners();
-			result.ok(data, false);
-		} catch (e) {
-			result.error(JSON.stringify(e), false);
-		}
-	},
-			
-	/**
-	 * Sets the active tuner by name.
-	 * @param success {Function} Function to call if the operation is a success
-	 * @param fail {Function} Function to call if the operation fails
-	 * @param args {Object} The arguments supplied
-	 * @param env {Object} Environment variables
-	 */
-	setTuner: function(success, fail, args, env) {
-		var result = new PluginResult(args, env)
-		var fixedArgs = _wwfix.parseArgs(args);
-		try {
-			_radio.setTuner(fixedArgs.tuner);
-			result.ok(undefined, false);
-		} catch (e) {
-			result.error(JSON.stringify(e), false);
-		}
-	},
-	
-	/**
-	 * Tune to a specific station, optionally targeting a specific tuner. If the specified
-	 * tuner is not the active tuner, then the station will be automatically selected the next
-	 * time that tuner is set as active.
-	 * @param success {Function} Function to call if the operation is a success
-	 * @param fail {Function} Function to call if the operation fails
-	 * @param args {Object} The arguments supplied
-	 * @param env {Object} Environment variables
-	 */
-	setStation: function(success, fail, args, env) {
-		var result = new PluginResult(args, env)
-		var fixedArgs = _wwfix.parseArgs(args);
-		try {
-			var tuner = (typeof fixedArgs.tuner !== 'undefined') ? fixedArgs.tuner : _radio.getStatus().tuner;
-			_radio.setStation(fixedArgs.station, tuner);
-			result.ok(undefined, false);
-		} catch (e) {
-			result.error(JSON.stringify(e), false);
-		}
-	},
-	
-	/**
-	 * Get the presets for the current tuner. Optionally, a tuner name can be specified, returning
-	 * presets for the specified tuner.
-	 * @param success {Function} Function to call if the operation is a success
-	 * @param fail {Function} Function to call if the operation fails
-	 * @param args {Object} The arguments supplied
-	 * @param env {Object} Environment variables
-	 */
-	getPresets: function(success, fail, args, env) {
-		var result = new PluginResult(args, env)
-		var fixedArgs = _wwfix.parseArgs(args);
-		try {
-			var tuner = (typeof fixedArgs.tuner !== 'undefined') ? fixedArgs.tuner : _radio.getStatus().tuner;
-			var data = _radio.getPresets(tuner);
-			result.ok(data, false);
-		} catch (e) {
-			result.error(JSON.stringify(e), false);
-		}
-	},
-	
-	/**
-	 * Sets the entire list of presets for the specified tuner(s).
-	 * @param success {Function} Function to call if the operation is a success
-	 * @param fail {Function} Function to call if the operation fails
-	 * @param args {Object} The arguments supplied
-	 * @param env {Object} Environment variables
-	 */
-	setPreset: function(success, fail, args, env) {
-		var result = new PluginResult(args, env)
-		var fixedArgs = _wwfix.parseArgs(args);
-		try {
-			var tuner = (typeof fixedArgs.tuner !== 'undefined') ? fixedArgs.tuner : _radio.getStatus().tuner
-			var station = (typeof fixedArgs.station !== 'undefined') ? fixedArgs.station : _radio.getStatus().station
-			_radio.setPreset(fixedArgs.index, fixedArgs.group, station, tuner);
-			result.ok(undefined, false);
-		} catch (e) {
-			result.error(JSON.stringify(e), false);
-		}
-	},
-	
-	/**
-	 * Seek for the next radio station in the given direction
-	 * @param success {Function} Function to call if the operation is a success
-	 * @param fail {Function} Function to call if the operation fails
-	 * @param args {Object} The arguments supplied
-	 * @param env {Object} Environment variables
-	 */
-	seek: function(success, fail, args, env) {
-		var result = new PluginResult(args, env)
-		var fixedArgs = _wwfix.parseArgs(args);
-		try {
-			_radio.seek(fixedArgs.direction);
-			result.ok(undefined, false);
-		} catch (e) {
-			result.error(JSON.stringify(e), false);
-		}
-	},
-	
-	/**
-	 * Scan for available radio stations in the given direction
-	 * @param success {Function} Function to call if the operation is a success
-	 * @param fail {Function} Function to call if the operation fails
-	 * @param args {Object} The arguments supplied
-	 * @param env {Object} Environment variables
-	 */
-	scan: function(success, fail, args, env) {
-		var result = new PluginResult(args, env)
-		var fixedArgs = _wwfix.parseArgs(args);
-		try {
-			_radio.scan(fixedArgs.direction);
-			result.ok(undefined, false);
-		} catch (e) {
-			result.error(JSON.stringify(e), false);
-		}
-	},
-	
-	/**
-	 * Stop scanning
-	 * @param success {Function} Function to call if the operation is a success
-	 * @param fail {Function} Function to call if the operation fails
-	 * @param args {Object} The arguments supplied
-	 * @param env {Object} Environment variables
-	 */
-	scanStop: function(success, fail, args, env) {
-		var result = new PluginResult(args, env)
-		try {
-			_radio.scanStop();
-			result.ok(undefined, false);
-		} catch (e) {
-			result.error(JSON.stringify(e), false);
-		}
-	},
-	
-	/**
-	 * Get the current station metadata.
-	 * @param success {Function} Function to call if the operation is a success
-	 * @param fail {Function} Function to call if the operation fails
-	 * @param args {Object} The arguments supplied. Available arguments for this call are: N/A
-	 * @param env {Object} Environment variables
-	 */
-	getStatus: function(success, fail, args, env) {
-		var result = new PluginResult(args, env)
-		try {
-			var data = _radio.getStatus();
-			result.ok(data, false);
-		} catch (e) {
-			result.error(JSON.stringify(e), false);
-		}
-	},
-};
-
diff --git a/plugin/com.qnx.radio/src/blackberry10/radio.js b/plugin/com.qnx.radio/src/blackberry10/radio.js
deleted file mode 100644
index 2322a49..0000000
--- a/plugin/com.qnx.radio/src/blackberry10/radio.js
+++ /dev/null
@@ -1,322 +0,0 @@
-/*
- * Copyright 2013  QNX Software Systems Limited
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"). You
- * may not reproduce, modify or distribute this software except in
- * compliance with the License. You may obtain a copy of the License
- * at: http://www.apache.org/licenses/LICENSE-2.0.
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTIES OF ANY KIND, either express or implied.
- * This file may contain contributions from others, either as
- * contributors under the License or as licensors under other terms.
- * Please review this entire file for other proprietary rights or license
- * notices, as well as the applicable QNX License Guide at
- * http://www.qnx.com/legal/licensing/document_archive/current_matrix.pdf
- * for other information.
- */
-
-/**
- * The abstraction layer for radio functionality.
- */
-
-var	_pps = qnx.webplatform.pps,
-	_tunersPPS,
-	_statusPPS,
-	_statusWriterPPS,
-	_commandPPS,
-	_triggerUpdate,
-	_triggerPresets,
-	_scanTimer,
-	SIMULATION_MODE = true;
-
-/**
- * Get the current status.
- * @return {Object} A radio status object.
- * Ex:
- * 
- * {
- * 	tuner: 'fm',
- * 	station: 91.5,
- * 	artist: 'Bjork',
- * 	genre: 'News & Entertainment',
- * 	song: 'All is Full of Love',
- * 	stationName: 'CBC Radio 1',
- * 	hd: false
- * }
- */
-function getStatus() {
-	var status = _statusPPS.data.status;
-	
-	return {
-		tuner		: status.tuner,
-		station 	: status[status.tuner].station,
-		artist		: status.artist,
-		genre		: status.genre,
-		song		: status.song,
-		stationName	: status.station,
-		hd			: status.hd
-	};
-}
-
-/**
- * Returns the list of available tuners.
- * @return {Object} An object containing attributes corresponding to each tuner object. The attribute name
- * is the name of the tuner.
- */
-function getTuners() {
-	var tuners = [];
-	var keys = Object.keys(_tunersPPS.data.tuners);
-	for (var i=0; i<keys.length; i++) {
-		var tuner = {
-			tuner: keys[i],
-			type: _tunersPPS.data.tuners[keys[i]].type
-		}
-		switch (tuner.type) {
-			case 'analog': 
-				tuner.settings = {
-					rangeMin: _tunersPPS.data.tuners[keys[i]].rangeMin,
-					rangeMax: _tunersPPS.data.tuners[keys[i]].rangeMax,
-					rangeStep: _tunersPPS.data.tuners[keys[i]].rangeStep,
-				};
-				break;
-
-			default:
-				console.error('car.radio::getTuners: Unknown tuner type: ' + tuner.type);
-				continue;
-		}
-		tuners.push(tuner);
-	}
-	return tuners;
-};
-
-/**
- * Get the presets for the current tuner. Optionally, a tuner name can be specified, returning
- * presets for the specified tuner.
- * @param {String} tuner The tuner for the presets 
- * @return {Array} An array of presets.
- */
-function getPresets(tuner) {
-		var presets = [];
-
-		var ppsPresets = _statusPPS.data.status[tuner].presets;
-		for (var i=0; i<ppsPresets.length; i++) {
-			presets.push({
-				tuner: tuner,
-				group: tuner + '1',
-				index: i,
-				station: ppsPresets[i]
-			});
-		}
-		return presets;
-};
-
-/**
- * Exports are the publicly accessible functions
- */
-module.exports = {
-	/**
-	 * Initializes the extension 
-	 */
-	init: function() {
-		//_tunersPPS
-		_tunersPPS = _pps.createObject("/pps/radio/tuners", _pps.PPSMode.DELTA);
-		_tunersPPS.open(_pps.FileMode.RDONLY);
-		
-		//_statusPPS
-		_statusPPS = _pps.createObject("/pps/radio/status", _pps.PPSMode.DELTA);
-		_statusPPS.onNewData = function(data) {
-			//status updates
-			if (_triggerUpdate) {
-				_triggerUpdate(getStatus());
-			}
-			//preset updates
-			if (_triggerPresets && data && data.changed) {
-				var tuners = getTuners();
-				for (var i=0; i<tuners.length; i++) {
-					if (typeof data.changed[tuners[i].tuner] !== 'undefined') {
-						_triggerPresets(getPresets(tuners[i].tuner));
-					}
-				}
-			}
-		};
-		_statusPPS.open(_pps.FileMode.RDONLY);
-		
-		//writing pps commands
-		_commandPPS = _pps.createObject("/pps/radio/status", _pps.PPSMode.DELTA);
-		if (SIMULATION_MODE) {
-			_commandPPS.open(_pps.FileMode.WRONLY);
-		} else {
-			_commandPPS.open(_pps.FileMode.WRONLY);
-		}
-
-		//status writer, used to save presets
-		_statusWriterPPS = _pps.createObject();
-		_statusWriterPPS.open("/pps/radio/status", JNEXT.PPS_WRONLY);
-	},
-		
-	/**
-	 * Sets the trigger function to call when a status event is fired
-	 * @param trigger {Function} The trigger function to call when the event is fired
-	 */
-	setTriggerUpdate: function(trigger) {
-		_triggerUpdate = trigger;
-	},
-	
-
-	/**
-	 * Sets the trigger function to call when a preset event is fired
-	 * @param trigger {Function} The trigger function to call when the event is fired
-	 */
-	setTriggerPresets: function(trigger) {
-		_triggerPresets = trigger;
-	},
-	
-	/**
-	 * Returns the list of available tuners.
-	 * @return {Object} An object containing attributes corresponding to each tuner object. The attribute name
-	 * is the name of the tuner.
-	 */
-	getTuners: function() {
-		return getTuners();
-	},
-
-	/**
-	 * Sets the active tuner by name.
-	 * @param tuner {String} The name of tuner to set as active
-	 */
-	setTuner: function(tuner) {
-		_commandPPS.write({tuner: tuner});
-	},	
-	
-	/**
-	 * Tune to a specific station, optionally targeting a specific tuner. If the specified
-	 * tuner is not the active tuner, then the station will be automatically selected the next
-	 * time that tuner is set as active.
-	 * @param station {Number} The target station
-	 * @param tuner {String} (optional) The target tuner name
-	 */
-	setStation: function(station, tuner) {
-		if (SIMULATION_MODE) {
-			var obj = {};
-			obj[tuner] = _statusPPS.data.status[tuner];
-			obj[tuner].station = station;
-			
-			_commandPPS.write(obj);
-		} else {
-			// If the station is not for the active tuner, then write the selected station
-			// directly to the status PPS object since nothing needs to happen at the radio
-			// service level.
-			if(tuner != _statusPPS.data.status.tuner) {
-				var obj = {};
-				obj[tuner] = _statusPPS.data.status[tuner];
-				obj[tuner].station = station;
-
-				_statusWriterPPS.write(obj);
-			}
-			
-			// If the station is for the current tuner, then send the tune command to the command PPS
-			_commandPPS.write({ tune: station });
-		}
-	},
-	
-	/**
-	 * Get the presets for the current tuner. Optionally, a tuner name can be specified, returning
-	 * presets for the specified tuner.
-	 * @param {String} tuner The tuner for the presets 
-	 * @return {Array} An array of presets.
-	 */
-	getPresets: function(tuner) {
-		return getPresets(tuner);
-	},
-	
-	/**
-	 * Sets the current station as a preset at the specified index. A station and tuner can optionally
-	 * be specified to set the non-current station as a preset, and/or for the non-active tuner. 
-	 * @param index {Number} The preset index
-	 * @param group {Number} The preset group
-	 * @param station {Number} (optional) The station to set as the preset. If not specified, the current station will be used.
-	 * @param tuner {String} (optional) The station's tuner. If not specified, the active tuner will be used.
-	 */
-	setPreset: function(index, group, station, tuner) {
-		var obj = {};
-		obj[tuner] = _statusPPS.data.status[tuner];
-		obj[tuner].presets[index] = station;
-		
-		// TODO: Ensure station preset is within the range of the specified tuner
-		// TODO: Handle group
-		_statusWriterPPS.write(obj);
-	},
-	
-	/**
-	 * Seek for the next radio station in the given direction
-	 * @param direction {String} The direction to seek ('up' or 'down')
-	 */
-	seek: function(direction) {
-		if (SIMULATION_MODE) {
-			var tuner = _tunersPPS.data.tuners[_statusPPS.data.status.tuner];
-			
-			var numSteps = (tuner.rangeMax - tuner.rangeMin) / tuner.rangeStep;
-			var rand = Math.ceil(Math.random() / 5 * numSteps);
-			if (direction == 'down') {
-				rand = -rand;
-			}
-			
-			var currStation = parseFloat(_statusPPS.data.status[_statusPPS.data.status.tuner].station);
-			var targetStation = currStation + (rand  * tuner.rangeStep);
-			if (targetStation < tuner.rangeMin) {
-				targetStation = tuner.rangeMax - (tuner.rangeMin - targetStation);
-			} else if (targetStation > tuner.rangeMax) {
-				targetStation = tuner.rangeMin + (targetStation - tuner.rangeMax);
-			}
-			
-			//ensure proper number of decimals
-			var strStation = new String(currStation)
-			var decpos = strStation.indexOf('.');
-			if (decpos > -1) {
-				targetStation = new Number(targetStation + '').toFixed(strStation.length - decpos - 1);
-			}
-			
-			this.setStation(targetStation, _statusPPS.data.status.tuner);
-		} else {
-			_commandPPS.write({ seek: direction });
-		}
-	},
-	
-	/**
-	 * Scan for available radio stations in the given direction.
-	 * @param direction {String} The direction to scan ('up' or 'down')
-	 */
-	scan: function(direction) {
-		if (_scanTimer !== undefined) {
-			clearInterval(_scanTimer);
-		}
-
-		var self = this;
-			_scanTimer = setInterval(function() { self.seek(direction) }, 3000);
-			this.seek(direction);
-	},
-	
-	/**
-	 * Stop station scanning if in progress.
-	 */
-	scanStop: function() {
-		if(_scanTimer !== undefined) {
-			clearInterval(_scanTimer);
-		}
-		
-		//get the server side to stop seeking in the middle of a seek.
-		if (!SIMULATION_MODE) {
-			_commandPPS.write({ seek: "stop" });
-		}
-	},
-	
-	/**
-	 * Get the current status.
-	 * @return {Object} A radio status object.
-	 */
-	getStatus: function() {
-		return getStatus();
-	},
-};
diff --git a/plugin/com.qnx.radio/www/client.js b/plugin/com.qnx.radio/www/client.js
deleted file mode 100644
index 1311058..0000000
--- a/plugin/com.qnx.radio/www/client.js
+++ /dev/null
@@ -1,637 +0,0 @@
-/*
- * Copyright 2013  QNX Software Systems Limited
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"). You
- * may not reproduce, modify or distribute this software except in
- * compliance with the License. You may obtain a copy of the License
- * at: http://www.apache.org/licenses/LICENSE-2.0.
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTIES OF ANY KIND, either express or implied.
- * This file may contain contributions from others, either as
- * contributors under the License or as licensors under other terms.
- * Please review this entire file for other proprietary rights or license
- * notices, as well as the applicable QNX License Guide at
- * http://www.qnx.com/legal/licensing/document_archive/current_matrix.pdf
- * for other information.
- */
-
-/**
- * @module car.radio
- * @static
- *
- * @description Manages the radio interface
- */
-
-var _ID = "com.qnx.radio",
-	_self = {},
-	_utils = cordova.require('cordova/utils'),
-	_watchesRadio = {};
-	_watchesPresets = {};
-
-/**
- * Handles radio update events
- * @param data {Array} The updated data provided by the event 
- * @private
- */
-function onUpdateRadio(data) {
-	var keys = Object.keys(_watchesRadio);
-	for (var i=0; i<keys.length; i++) {
-		setTimeout(_watchesRadio[keys[i]](data), 0);
-	}
-}
-
-/**
- * Handles preset update events 
- * @param data {Array} The updated data provided by the event 
- * @private
- */
-function onUpdatePresets(data) {
-	var keys = Object.keys(_watchesPresets);
-	for (var i=0; i<keys.length; i++) {
-		setTimeout(_watchesPresets[keys[i]](data), 0);
-	}
-}
-
-/**
- * Watch for metadata updates
- * @param {Function} callback The function to call when a change is detected.
- * @return {Number} An ID for the added watch.
- * @memberOf module:car.radio
- * @method watchRadio 
- * @example
- * 
- * //define a callback function
- * function myCallback(metadata) {
- *		console.log("tuner = " + data.tuner + "\n" +
- *					"artist = " + data.artist + "\n" +
- *					"genre = " + data.genre + "\n" +
- *					"song = " + data.song + "\n" +
- *					"station = " + data.station + "\n" +
- *					"stationName = " + data.stationName + "\n" +
- *					"hd = " + data.hd
- *		);
- * }
- * 
- * var watchId = car.radio.watchRadio(myCallback);
- */
-_self.watchRadio = function (callback) {
-	var watchId = _utils.createUUID();
-	
-	_watchesRadio[watchId] = callback;
-	if (Object.keys(_watchesRadio).length === 1) {
-		window.cordova.exec(onUpdateRadio, null, _ID, 'startEvent', { eventName: 'radioupdate' }, false);
-	}
-
-	return watchId;
-};
-
-/**
- * Watch for preset updates
- * @param {Function} callback The function to call when a change is detected.
- * @return {Number} An ID for the added watch.
- * @memberOf module:car.radio
- * @method watchPresets  
- * @example
- * 
- * function myCallback(presets) {
- *		//iterate through all the presets
- *		for (var i=0; i&lt;presets.length; i++) {
- *			console.log("preset tuner = " + presets[i].tuner + "\n" +
- *						"preset station = " + presets[i].station + "\n" +
- *						"preset index = " + presets[i].index + "\n" +
- *						"preset group = " + presets[i].group
- *			);
- *		}
- * }
- * 
- * var watchId = car.radio.watchPresets(myCallback);
- */
-_self.watchPresets = function (callback) {
-	var watchId = _utils.createUUID();
-	
-	_watchesPresets[watchId] = callback;
-	if (Object.keys(_watchesPresets).length === 1) {
-		window.cordova.exec(onUpdatePresets, null, _ID, 'startEvent', { eventName: 'presetUpdate' }, false);
-	}
-
-	return watchId;
-};
-
-/**
- * Stop watching for metadata updates
- * @param {Number} watchId The watch ID as returned by <i>car.radio.watchRadio()</i> or <i>car.radio.watchPresets()</i>.
- * @memberOf module:car.radio
- * @method cancelWatch   
- * @example
- * 
- * car.radio.cancelWatch(watchId);
- */
-_self.cancelWatch = function (watchId) {
-	//is this a radio events watch?
-	if (_watchesRadio[watchId]) {
-		delete _watchesRadio[watchId];
-		if (Object.keys(_watchesRadio).length === 0) {
-			window.cordova.exec(null, null, _ID, 'stopEvent', { eventName: 'radioUpdate' }, false);
-		}
-	} else if (_watchesPresets[watchId]) {
-		delete _watchesPresets[watchId];
-		if (Object.keys(_watchesPresets).length === 0) {
-			window.cordova.exec(null, null, _ID, 'stopEvent', { eventName: 'presetUpdate' }, false);
-		}
-	}
-};
-
-/**
- * Return the list of available tuners
- * @param {Function} successCallback The function to call on success.
- * @param {Function} [errorCallback] The function to call if there is an error.
- * @memberOf module:car.radio
- * @method getTuners  
- * @example 
- *
- * //define your callback function(s)
- * function successCallback(tuners) {
- *		//iterate through all the tuners
- *		for (var i=0; i&lt;tuners.length; i++) {
- *			console.log("tuner name = " + tuners[i].tuner + "\n" +
- *						"tuner type = " + tuners[i].type + "\n" +
- *						"tuner range min = " + tuners[i].settings.rangeMin + "\n" +
- *						"tuner range max = " + tuners[i].settings.rangeMax + "\n" +
- *						"tuner range step = " + tuners[i].settings.rangeStep
- *			);
- *		}
- * }
- *
- * function errorCallback(error) {
- *		console.log(error.code, error.msg);
- * }
- *
- * //call the method
- * car.radio.getTuners(successCallback, errorCallback);
- *
- *
- *
- * @example REST
- *
- * Request:
- * http://&lt;car-ip&gt;/car/radio/getTuners
- *
- * Success Response:
- * {
- *		code: 1,
- *		data: [ 
- * 			{ 
- *				tuner: 'am', 
- *				type: 'analog', 
- *				settings: {
- *					rangeMin: 880,
- *					rangeMax: 1600,
- *					rangeStep: 10
- *				}
- *			}, { 
- *				tuner: 'fm', 
- *				type: 'analog', 
- *				settings: {
- *					rangeMin: 88.9,
- *					rangeMax: 107.1,
- *					rangeStep: 0.2
- *				}
- *			}
- *		]
- * }
- *
- * Error Response:
- * {
- *		code: -1,
- *		msg: "An error has occurred"
- * }
- */
-_self.getTuners = function(successCallback, errorCallback) {
-	window.cordova.exec(successCallback, errorCallback, _ID, 'getTuners', null, false);
-};
-		
-/**
- * Set the active tuner by name
- * @param {String} tuner The name of tuner to set as active.
- * @param {Function} [successCallback] The function to call on success.
- * @param {Function} [errorCallback] The function to call if there is an error.
- * @memberOf module:car.radio
- * @method setTuner
- * @example 
- *
- * //define your callback function(s)
- * function successCallback() {
- *		console.log('tuner was successfully set');
- * }
- *
- * function errorCallback(error) {
- *		console.log(error.code, error.msg);
- * }
- *
- * //call the method
- * car.radio.setTuner('fm', successCallback, errorCallback);
- *
- *
- *
- * @example REST
- *
- * Request:
- * http://&lt;car-ip&gt;/car/radio/setTuner?tuner=fm
- *
- * Success Response:
- * {
- *		code: 1,
- * }
- *
- * Error Response:
- * {
- *		code: -1,
- *		msg: "An error has occurred"
- * }
- */
-_self.setTuner = function(tuner, successCallback, errorCallback) {
-	var args = { 
-		tuner: tuner 
-	};
-	window.cordova.exec(successCallback, errorCallback, _ID, 'setTuner', args, false);
-};
-
-/**
- * @description <p>Tune to a specific station, optionally targeting a specific tuner
- * <p>If the specified tuner is not the active tuner, then the station will be 
- * automatically selected the next time that tuner is set as active.
- * @param {Number} station The target station.
- * @param {Function} successCallback The function to call on success.
- * @param {Function} [errorCallback] The function to call if there is an error.
- * @param {String} [tuner] The tuner name. If not specified, the active tuner is used.
- * @memberOf module:car.radio
- * @method setStation
- * @example 
- *
- * //define your callback function(s)
- * function successCallback() {
- *		console.log('station was successfully set');
- * }
- *
- * function errorCallback(error) {
- *		console.log(error.code, error.msg);
- * }
- *
- * //call the method
- * car.radio.setStation(88.5, successCallback, errorCallback);
- *
- *
- *
- * @example REST
- *
- * Request:
- * http://&lt;car-ip&gt;/car/radio/setStation?station=88.5
- *
- * Success Response:
- * {
- *		code: 1,
- * }
- *
- * Error Response:
- * {
- *		code: -1,
- *		msg: "An error has occurred"
- * }
- */
-_self.setStation = function(station, successCallback, errorCallback, tuner) {
-	var args = { 
-		station: station 
-	};
-	if (tuner) {
-		args.tuner = tuner;
-	}
-	window.cordova.exec(successCallback, errorCallback, _ID, 'setStation', args, false);
-};
-
-/**
- * @description <p>Get the presets for the current tuner
- * <p>Optionally, a tuner name can be specified, returning
- * presets for the specified tuner.
- * @param {Function} successCallback The function to call on success.
- * @param {Function} [errorCallback] The function to call if there is an error.
- * @param {String} [tuner] The tuner of the presets. If not specified, the active tuner is used.
- * @memberOf module:car.radio
- * @method getPresets
- * @example 
- *
- * //define your callback function(s)
- * function successCallback(presets) {
- *		//iterate through all the presets
- *		for (var i=0; i&lt;presets.length; i++) {
- *			console.log("preset tuner = " + presets[i].tuner + "\n" +
- *						"preset station = " + presets[i].station + "\n" +
- *						"preset index = " + presets[i].index + "\n" +
- *						"preset group = " + presets[i].group
- *			);
- *		}
- * }
- *
- * function errorCallback(error) {
- *		console.log(error.code, error.msg);
- * }
- *
- * //call the method
- * car.radio.getPresets(successCallback, errorCallback);
- *
- *
- *
- * @example REST
- *
- * Request:
- * http://&lt;car-ip&gt;/car/radio/getPresets
- *
- * Success Response:
- * {
- *		code: 1,
- *		data: [ 
- * 			{ 
- *				tuner: 'am', 
- *				station: '880', 
- *				index: 0, 
- *				group: 'am1', 
- *			}, { 
- *				tuner: 'am', 
- *				station: '1010', 
- *				index: 1, 
- *				group: 'am1', 
- *			},{
- *				...	
- *			}
- *		]
- * }
- *
- * Error Response:
- * {
- *		code: -1,
- *		msg: "An error has occurred"
- * }
- */
-_self.getPresets = function(successCallback, errorCallback, tuner) {
-	var args = {};
-	if (tuner) {
-		args.tuner = tuner;
-	}
-    window.cordova.exec(successCallback, errorCallback, _ID, 'getPresets', args, false);
-};
-
-/**
- * @description <p>Set the current station as a preset at the specified index
- * <p>You can optionally specify a different station and tuner as a preset. 
- * @param {Number} index The preset index.
- * @param {String} group The preset group.
- * @param {Number} [station] The station to set as the preset. If this is not specified, the current station is used.
- * @param {String} [tuner] The tuner of the presets. If not specified, the active tuner is used.
- * @param {Function} [successCallback] The function to call on success.
- * @param {Function} [errorCallback] The function to call if there is an error.
- * @memberOf module:car.radio
- * @method setPreset
- * @example 
- *
- * //define your callback function(s)
- * function successCallback() {
- *		console.log('preset was successfully set');
- * }
- *
- * function errorCallback(error) {
- *		console.log(error.code, error.msg);
- * }
- *
- * //call the method
- * car.radio.setPreset(0, 'am1', 1030, 'am', successCallback, errorCallback);
- *
- *
- *
- * @example REST
- *
- * Request:
- * http://&lt;car-ip&gt;/car/radio/setPreset?index=0&group=am1&station=1030&tuner=am
- *
- * Success Response:
- * {
- *		code: 1,
- * }
- *
- * Error Response:
- * {
- *		code: -1,
- *		msg: "An error has occurred"
- * }
- */
-_self.setPreset = function(index, group, station, tuner, successCallback, errorCallback) {
-	var args = { 
-		index: index,
-		group: group
-	};
-	if (station) {
-		args["station"] = station;
-	}
-	if (tuner) {
-		args["tuner"] = tuner;
-	}
-	window.cordova.exec(successCallback, errorCallback, _ID, 'setPreset', args, false);
-};
-
-/**
- * Seek for the next radio station in the specified direction
- * @param {String} direction The direction to seek ('up' or 'down').
- * @param {Function} [successCallback] The function to call on success.
- * @param {Function} [errorCallback] The function to call if there is an error.
- * @memberOf module:car.radio
- * @method seek
- * @example 
- *
- * //define your callback function(s)
- * function successCallback() {
- *		console.log('seek was successfully called');
- * }
- *
- * function errorCallback(error) {
- *		console.log(error.code, error.msg);
- * }
- *
- * //call the method
- * car.radio.seek('up', successCallback, errorCallback);
- *
- *
- *
- * @example REST
- *
- * Request:
- * http://&lt;car-ip&gt;/car/radio/seek?direction=up
- *
- * Success Response:
- * {
- *		code: 1,
- * }
- *
- * Error Response:
- * {
- *		code: -1,
- *		msg: "An error has occurred"
- * }
- */
-_self.seek = function(direction, successCallback, errorCallback) {
-	var args = { 
-		direction: direction 
-	};
-    window.cordova.exec(successCallback, errorCallback, _ID, 'seek', args, false);
-};
-
-/**
- * Scan for available radio stations in the specified direction
- * @param {String} direction The direction to seek ('up' or 'down').
- * @param {Function} [successCallback] The function to call on success.
- * @param {Function} [errorCallback] The function to call if there is an error.
- * @memberOf module:car.radio
- * @method scan
- * @example 
- *
- * //define your callback function(s)
- * function successCallback() {
- *		console.log('scan was successfully called');
- * }
- *
- * function errorCallback(error) {
- *		console.log(error.code, error.msg);
- * }
- *
- * //call the method
- * car.radio.scan('up', successCallback, errorCallback);
- *
- *
- *
- * @example REST
- *
- * Request:
- * http://&lt;car-ip&gt;/car/radio/scan?direction=up
- *
- * Success Response:
- * {
- *		code: 1,
- * }
- *
- * Error Response:
- * {
- *		code: -1,
- *		msg: "An error has occurred"
- * }
- */
-_self.scan = function(direction, successCallback, errorCallback) {
-	var args = { 
-		direction: direction 
-	};
-    window.cordova.exec(successCallback, errorCallback, _ID, 'scan', args, false);
-};
-
-/**
- * Stop station scanning if in progress
- * @param {Function} [successCallback] The function to call on success.
- * @param {Function} [errorCallback] The function to call if there is an error.
- * @memberOf module:car.radio
- * @method scanStop
- * @example 
- *
- * //define your callback function(s)
- * function successCallback() {
- *		console.log('scanStop was successfully called');
- * }
- *
- * function errorCallback(error) {
- *		console.log(error.code, error.msg);
- * }
- *
- * //call the method
- * car.radio.scanStop(successCallback, errorCallback);
- *
- *
- *
- * @example REST
- *
- * Request:
- * http://&lt;car-ip&gt;/car/radio/scanStop
- *
- * Success Response:
- * {
- *		code: 1,
- * }
- *
- * Error Response:
- * {
- *		code: -1,
- *		msg: "An error has occurred"
- * }
- */
-_self.scanStop = function(successCallback, errorCallback) {
-    window.cordova.exec(successCallback, errorCallback, _ID, 'scanStop', null, false);
-};
-
-/**
- * Get the current station metadata
- * @param {Function} [successCallback] The function to call on success.
- * @param {Function} [errorCallback] The function to call if there is an error.
- * @memberOf module:car.radio
- * @method getStatus
- * @example 
- *
- * //define your callback function(s)
- * function successCallback(data) {
- *			console.log("tuner = " + data.tuner + "\n" +
- *						"artist = " + data.artist + "\n" +
- *						"genre = " + data.genre + "\n" +
- *						"song = " + data.song + "\n" +
- *						"station = " + data.station + "\n" +
- *						"stationName = " + data.stationName + "\n" +
- *						"hd = " + data.hd
- *			);
- *		}
- * }
- *
- * function errorCallback(error) {
- *		console.log(error.code, error.msg);
- * }
- *
- * //call the method
- * car.radio.getStatus(successCallback, errorCallback);
- *
- *
- *
- * @example REST
- *
- * Request:
- * http://&lt;car-ip&gt;/car/radio/getStatus
- *
- * Success Response:
- * {
- *		code: 1,
- *		data: {
- *     		tuner: 'fm'
- *     		artist: 'Bjork',
- *     		genre: 'News & Entertainment',
- *     		song: 'All is Full of Love',
- *     		station: 91.5,
- *     		stationName: 'CBC Radio 1',
- *     		hd: false
- *		}
- * }
- *
- * Error Response:
- * {
- *		code: -1,
- *		msg: "An error has occurred"
- * }
- */
-_self.getStatus = function(successCallback, errorCallback) {
-	window.cordova.exec(successCallback, errorCallback, _ID, 'getStatus', null, false);
-};
-
-
-//Export
-module.exports = _self;
-
diff --git a/plugin/com.qnx.settings/src/blackberry10/index.js b/plugin/com.qnx.settings/src/blackberry10/index.js
index 512fc9c..ef44976 100644
--- a/plugin/com.qnx.settings/src/blackberry10/index.js
+++ b/plugin/com.qnx.settings/src/blackberry10/index.js
@@ -32,18 +32,6 @@ var _wwfix = require("../../lib/wwfix"),
 	},
 	_listeners = {};
 
-/*
- * Initializes the extension 
- */
-function init() {
-	try {
-		_settings.init();
-	} catch (ex) {
-		console.error('Error in webworks ext: settings/index.js:init():', ex);
-	}
-}
-init();
-
 
 /**
  * Exports are the publicly accessible functions
-- 
1.7.10.msysgit.1

